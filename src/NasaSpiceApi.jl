################################################################################
#   
#      ##    #    #     #     ####     ##    #####
#     #  #    #  #      #    #        #  #   #    #
#    #    #    ##       #     ####   #    #  #    #
#    ######    ##       #         #  ######  #####
#    #    #   #  #      #    #    #  #    #  #   #
#    #    #  #    #     #     ####   #    #  #    #
#
#   axis and angle to rotation
#
################################################################################
#-Abstract
#
#   axisar returns a 3x3 double rotation matrix that rotates
#   vectors by a specified angle about a specified axis.
#
#-I/O
#
#   Given:
#
#      axis    an arbitrary, non-zero, double precision 3x1 array
#              defining a rotation axis
#
#      angle   the double precision scalar angle in radians
#              defining the measure of rotation about 'axis'
#
#   the call:
#
#      r = axisar( axis, angle)
#
#   returns:
#
#      r   a double precision 3x3 array representing the coordinate
#          transformation determined by 'axis' and 'angle', i.e. the
#          application of 'r' to a 3x1 array returns the result
#          of rotating the vector about 'axis' through 'angle' radians
#
#   Please note cspice_raxisa is not guaranteed to invert the
#   operation of axisar.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine axisar_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # axisar
#       (r::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        axisar(
            axis::Array{Float64,1}, # Array_3_ConstSpiceDouble
            angle::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(axis) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        r = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        r_ptr = pointer(r)
        
#       make transposed copies of all input arrays and their pointers
        axis_t = axis'
        axis_ptr = pointer(axis_t)
        
#       ccall((:axisar_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),axis,angle,r)
        ccall((:axisar_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Ptr{Float64}),
            axis_ptr,angle,r_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example:
#
#      %
#      % Define an axis and an angle for rotation.
#      %
#      axis = [ 1.; 2.; 3. ];
#      angle = .1 * cspice_twopi;
#
#      %
#      % Determine the rotation matrix.
#      %
#      rot_mat = axisar( axis, angle );
#
#      %
#      % Now calculate the rotation axis and angle based on the
#      % matrix as input.
#      %
#      [ axout, angout ] = cspice_raxisa( rot_mat);
#
#      %
#      % Now input the axout and angout to axisar to
#      % compare against the original rotation matrix rot_mat.
#      %
#      rot_out = axisar( axout, angout );
#      rot_mat - rot_out
#
#   MATLAB outputs:
#
#         1.0e-15 *
#
#                        0  -0.11102230246252   0.05551115123126
#         0.11102230246252                  0                  0
#        -0.05551115123126   0.02775557561563                  0
#
#     The zero matrix accurate to round-off error. A numerical
#     demonstration of equality.
#
#-Version
#
#   -Mice Version 1.0.0, 29-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####   #####   #####   ######  ######
#    #    #  #    #  #    #  #    #  #       #
#    #####   #    #  #    #  #    #  #####   #####
#    #    #  #    #  #    #  #    #  #       #
#    #    #  #    #  #    #  #    #  #       #
#    #####    ####   #####   #####   ######  #
#
#   body name/id code definition
#
################################################################################
#-Abstract
#
#   boddef Define a body name/ID code pair for later translation via
#  cspice_bodn2c or cspice_bodc2n.
#
#-I/O
#
#   Given:
#
#      name   the scalar string defining the name to associate to the ID value
#             'code'.
#
#             The case and positions of blanks in a name are significant.
#             cspice_bodc2n returns the same string (case and space) most
#             recently mapped to a code. When 'name' consists of more than one
#             word, the words require separation by at least one blank.
#
#             The kernel sub-system stores 'name' as described in the
#             boddef call, but creates an equivalence class based on
#             'name' for comparisons in cspice_bodn2c. This class ignores
#             leading and trailing whitespace, compresses interior whitespace
#             to a single space, and ignores character case.
#
#             The following strings belong to the same equivalence
#             class:
#
#                       'JUPITER BARYCENTER'
#                       'Jupiter Barycenter'
#                       'JUPITER BARYCENTER   '
#                       'JUPITER    BARYCENTER'
#                       '   JUPITER BARYCENTER'
#
#             However, 'JUPITERBARYCENTER' is distinct from the names above.
#
#      code   the integer defining the NAIF ID code corresponding
#             to 'name'.
#
#   the call:
#
#      boddef( name, code )
#
#   performs the mapping assignment
#
#      'name' -> 'code'
#
#   and
#
#      'code' -> 'name'
#
#   The 'code' -> 'name' assignment supersedes any other mapping for 'code'.
#
#-Particulars
#
#   boddef is one of five related subroutines,
#
#      cspice_bods2c      Body string to code
#      cspice_bodc2s      Body code to string
#      cspice_bodn2c      Body name to code
#      cspice_bodc2n      Body code to name
#      boddef      Body name/code definition
#
#   cspice_bods2c, cspice_bodc2s, cspice_bodn2c, and cspice_bodc2n
#   perform translations between body names and their corresponding
#   integer ID codes which are used in SPICE files and routines.
#
#   cspice_bods2c is a slightly more general version of cspice_bodn2c:
#   support for strings containing ID codes in string format enables a caller
#   to identify a body using a string, even when no name is associated with
#   that body.
#
#   cspice_bodc2s is a general version of cspice_bodc2n; the routine returns
#   either the name assigned in the body ID to name mapping or a string
#   representation of the 'code' value if no mapping exists.
#
#   boddef assigns a body name to ID mapping. The mapping has
#   priority in name-to-ID and ID-to-name translations.
#
#   Refer to NAIF_IDS.REQ for the list of name/code associations built
#   into SPICE, and for details concerning adding new name/code
#   associations at run time by loading text kernels.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine boddef_c.
#
#   MICE.REQ
#   NAIF_IDS.REQ
#
    function # boddef
#       (name::AbstractString,  # Ptr{ConstSpiceChar}
#        code::Int32) =   # SpiceInt
        boddef()
        
#       enforce input array sizes
#       allocate the output parameters
        name = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        name_ptr = pointer(name)
        code = Array{Int32}(1);  # SpiceInt
        code_ptr = pointer(code)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:boddef_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceInt),name,code)
        ccall((:boddef_c,libNasaSpice),Void,
            (Ptr{AbstractString},Ptr{Int32}),
            name_ptr,code_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return name[1], code[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Map a non-existent code and name to each other.
#      %
#      boddef( 'spud',  -69 );
#
#      %
#      % Retrieve the code for name 'spud'.
#      %
#      [ code, found ] = cspice_bodn2c( 'spud' );
#
#      %
#      % Check we found a mapping.
#      %
#      if ( found )
#         txt = sprintf( 'ID for spud : %i', code );
#      else
#         txt = 'Found no mapping for spud.';
#      end
#
#      disp( txt )
#
#      %
#      % Retrieve the name for ID -69.
#      %
#      [ name, found ] = cspice_bodc2n( -69 );
#
#      %
#      % Check we found a mapping.
#      %
#      if (found)
#         txt = sprintf( 'Name for -69: %s', name );
#      else
#         txt = 'Found no mapping for -69.';
#      end
#
#     disp( txt )
#
#   MATLAB outputs:
#
#      ID for spud : -69
#      Name for -69: spud.
#
#-Version
#
#   -Mice Version 1.0.1, 16-MAY-2009 (EDW)
#
#       Edit to Particulars section to document the cspice_bodc2s routine.
#       Extended argument descriptions in the I/O section.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                                    #####
#    #####    ####   #####   #    # #     #   ####
#    #    #  #    #  #    #  ##   #       #  #    #
#    #####   #    #  #    #  # #  #  #####   #
#    #    #  #    #  #    #  #  # # #        #
#    #    #  #    #  #    #  #   ## #        #    #
#    #####    ####   #####   #    # #######   ####
#
#   body name to code
#
################################################################################
#-Abstract
#
#   bodn2c translates the name of a body or object to the corresponding
#   SPICE integer ID code.
#
#-I/O
#
#   Given:
#
#      name   name(s) of a body or object,  such as a planet, satellite, comet,
#             asteroid, barycenter, DSN station, spacecraft, or instrument,
#             "known" to the SPICE system, whether through hard-coded
#             registration or run-time registration in the SPICE kernel pool
#
#             [n,m] = size(name); char = class(name)
#
#             Case and leading and trailing blanks in a name are not
#             significant. However when a name is made up of more than one
#             word, they must be separated by at least one blank. That is,
#             all of the following strings are equivalent names:
#
#                      'JUPITER BARYCENTER'
#                      'Jupiter Barycenter'
#                      'JUPITER BARYCENTER   '
#                      'JUPITER    BARYCENTER'
#                      '   JUPITER BARYCENTER'
#
#              However, 'JUPITERBARYCENTER' is not equivalent to the names
#              above.
#
#   the call:
#
#      [code, found] = bodn2c( name )
#
#   returns:
#
#      code    containing the SPICE code(s) assigned either by SPICE or the
#              user to 'name'.
#
#              [1,n] = size(code); int32 = class(code)
#
#      found   flag(s) indicating if the kernel subsystem translated 'name' to
#              a corresponding 'code'.
#
#              [1,n] = size(found); logical = class(found)
#
#              'found' and 'code' return with the same vectorization
#              measure (N) as 'name'.
#
#-Particulars
#
#   A sister version of this routine exists named mice_bodn2c that returns
#   the output arguments as fields in a single structure.
#
#   bodn2c is one of five related subroutines,
#
#      cspice_bods2c      Body string to code
#      cspice_bodc2s      Body code to string
#      bodn2c      Body name to code
#      cspice_bodc2n      Body code to name
#      cspice_boddef      Body name/code definition
#
#   cspice_bods2c, cspice_bodc2s, bodn2c, and cspice_bodc2n
#   perform translations between body names and their corresponding
#   integer ID codes which are used in SPICE files and routines.
#
#   cspice_bods2c is a slightly more general version of bodn2c:
#   support for strings containing ID codes in string format enables a caller
#   to identify a body using a string, even when no name is associated with
#   that body.
#
#   cspice_bodc2s is a general version of cspice_bodc2n; the routine returns
#   either the name assigned in the body ID to name mapping or a string
#   representation of the 'code' value if no mapping exists.
#
#   cspice_boddef assigns a body name to ID mapping. The mapping has
#   priority in name-to-ID and ID-to-name translations.
#
#   Programmers writing user interface code should consider using the
#   Mice routine cspice_bods2c. cspice_bods2c provides more flexibility
#   in handling input strings, since it accepts both body names and
#   strings representing integer ID codes, for example '399'.
#
#   Refer to NAIF_IDS.REQ for the list of name/code associations built
#   into SPICE, and for details concerning adding new name/code
#   associations at run time by loading text kernels.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine bodn2c_c.
#
#   MICE.REQ
#   NAIF_IDS.REQ
#
    function # bodn2c
#       (code::Int32,  # Ptr{SpiceInt}
#        found::Int32) =   # Ptr{SpiceBoolean}
        bodn2c(
            name::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        code = Array{Int32}(1);  # Ptr{SpiceInt}
        code_ptr = pointer(code)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:bodn2c_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceInt},Ptr{SpiceBoolean}),name,code,found)
        ccall((:bodn2c_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32},Ptr{Int32}),
            name,code_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return code[1], convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Retrieve the NAIF ID associated to a body name.
#      %
#      disp( 'Scalar:' )
#      name            = 'Hyperion';
#      [ code, found ] = bodn2c( name );
#
#      %
#      % Output the mapping if it exists.
#      %
#      if ( found )
#         txt = sprintf( 'Body code %i maps to name %s', ...
#                         code, name );
#         disp(txt)
#      end
#
#      disp(' ')
#
#      %
#      % Create an array of body names. Include one unknown name.
#      %
#      disp( 'Vector:' )
#      name           = strvcat( 'Triton', 'Mimas', ...
#                                'Oberon', 'Callisto', 'Halo' );
#      [ code, found] = bodn2c( name );
#
#      n_elements = size(code,2);
#
#      %
#      % Loop over the output array.
#      %
#      for n=1:n_elements
#
#         %
#         % Check for a valid name/code mapping.
#         %
#         if( found(n) )
#            txt = sprintf( 'Body code %i maps to name %s', ...
#                            code(n), name(n,:) );
#            disp(txt)
#         else
#            txt = sprintf( 'Unknown body name %s', name(n,:) );
#            disp(txt)
#         end
#
#      end
#
#   MATLAB outputs:
#
#      Scalar:
#      Body code 607 maps to name Hyperion
#
#      Vector:
#      Body code 801 maps to name Triton
#      Body code 601 maps to name Mimas
#      Body code 704 maps to name Oberon
#      Body code 504 maps to name Callisto
#      Unknown body name Halo
#
#-Version
#
#   -Mice Version 1.0.2, 12-MAR-2012 (EDW), SCK (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#       Corrected minor typo in header.
#
#   -Mice Version 1.0.1, 16-MAY-2009 (EDW)
#
#       Edit to Particulars section to document the cspice_bodc2s routine.
#       Extended argument descriptions in the I/O section.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                                    #####
#    #####    ####   #####    ####  #     #   ####
#    #    #  #    #  #    #  #            #  #    #
#    #####   #    #  #    #   ####   #####   #
#    #    #  #    #  #    #       # #        #
#    #    #  #    #  #    #  #    # #        #    #
#    #####    ####   #####    ####  #######   ####
#
#   body name to code
#
################################################################################
#-Abstract
#
#   bods2c translates a string containing a body name or ID code to the
#   corresponding integer code.
#
#-I/O
#
#   Given:
#
#      name   containing the name or ID code of a body or  object, such as a
#             planet, satellite, comet, asteroid, barycenter, DSN station,
#             spacecraft, or instrument.
#
#             [n,m] = size(name); char = class(name)
#
#             If `name' contains the name of a body or object, that name must be
#             "known" to the SPICE system, whether through hard-coded
#             registration or run-time registration in the SPICE kernel pool.
#
#             Case and leading and trailing blanks in `name' are not
#             significant. However when a name is made up of more than one
#             word, they must be separated by at least one blank.  That is, all
#             of the following strings are equivalent names:
#
#                     'JUPITER BARYCENTER'
#                     'Jupiter Barycenter'
#                     'JUPITER BARYCENTER   '
#                     'JUPITER    BARYCENTER'
#                     '   JUPITER BARYCENTER'
#
#             However, 'JUPITERBARYCENTER' is not equivalent to the names above.
#
#             If NAME is a string representation of an integer, for example
#
#                '399'
#
#             the string will be translated to the equivalent integer datum.
#             The input integer need not be one recognized by the SPICE system:
#             the integer need not be a built-in NAIF ID code, nor need it be
#             associated with a name via run-time registration.
#
#   the call:
#
#      [code, found] = bods2c( name )
#
#   returns:
#
#      code    containing the SPICE code(s) for 'name' if 'name' contains the
#              name of a body or object as determined by the SPICE name-code
#              mapping subsystem. If the input argument 'name' represents an
#              integer, the same integer is returned in 'code'. If neither
#              mapping exists 'code' returns as 0.
#
#              [1,n] = size(code); int32 = class(code)
#
#      found   the flag(s) indicating if the kernel subsystem translated 'name'
#              to a corresponding 'code'.
#
#              [1,n] = size(found); logical = class(found)
#
#              'found' and 'code' return with the same vectorization
#              measure (N) as 'name'.
#
#-Particulars
#
#   A sister version of this routine exists named mice_bods2c that returns
#   the output arguments as fields in a single structure.
#
#   bods2c is one of five related subroutines,
#
#      bods2c      Body string to code
#      cspice_bodc2s      Body code to string
#      cspice_bodn2c      Body name to code
#      cspice_bodc2n      Body code to name
#      cspice_boddef      Body name/code definition
#
#   bods2c, cspice_bodc2s, cspice_bodn2c, and cspice_bodc2n
#   perform translations between body names and their corresponding
#   integer ID codes which are used in SPICE files and routines.
#
#   bods2c is a slightly more general version of cspice_bodn2c:
#   support for strings containing ID codes in string format enables a caller
#   to identify a body using a string, even when no name is associated with
#   that body.
#
#   cspice_bodc2s is a general version of cspice_bodc2n; the routine returns
#   either the name assigned in the body ID to name mapping or a string
#   representation of the 'code' value if no mapping exists.
#
#   cspice_boddef assigns a body name to ID mapping. The mapping has
#   priority in name-to-ID and ID-to-name translations.
#
#   Refer to NAIF_IDS.REQ for the list of name/code associations built
#   into SPICE, and for details concerning adding new name/code
#   associations at run time by loading text kernels.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine bods2c_c.
#
#   MICE.REQ
#   NAIF_IDS.REQ
#
    function # bods2c
#       (code::Int32,  # Ptr{SpiceInt}
#        found::Int32) =   # Ptr{SpiceBoolean}
        bods2c(
            name::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        code = Array{Int32}(1);  # Ptr{SpiceInt}
        code_ptr = pointer(code)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:bods2c_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceInt},Ptr{SpiceBoolean}),name,code,found)
        ccall((:bods2c_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32},Ptr{Int32}),
            name,code_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return code[1], convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Retrieve the NAIF ID associated to a body name.
#      %
#      disp( 'Scalar:' )
#      name         = 'Hyperion';
#      [code,found] = bods2c( name );
#
#      %
#      % Output the mapping if it exists.
#      %
#      if ( found )
#         txt = sprintf( 'AbstractString %s maps to ID %i', ...
#                         name, code );
#         disp(txt)
#      end
#
#      disp(' ')
#
#      %
#      % Create an array of strings. Include one string not an integer
#      % and unknown to the SPICE system.
#      %
#      disp( 'Vector:' )
#      name          = strvcat( 'Cassini'   , '399',  ...
#                               'Planet Bob', 'MARS', ...
#                               '-123456'   , '987654' );
#      [code, found] = bods2c( name );
#
#      n_elements = size(code,2);
#
#      %
#      % Loop over the output array.
#      %
#      for n=1:n_elements
#
#         %
#         % Check for a valid name/ID mapping.
#         %
#         if( found(n))
#            txt = sprintf( 'AbstractString %s maps to ID %i', ...
#                            name(n,:), code(n) );
#            disp(txt)
#         else
#            txt = sprintf( 'Unknown string ID %s', name(n,:) );
#            disp(txt)
#         end
#
#      end
#
#   MATLAB outputs:
#
#      Scalar:
#      AbstractString Hyperion maps to ID 607
#
#      Vector:
#      AbstractString Cassini    maps to ID -82
#      AbstractString 399        maps to ID 399
#      Unknown string ID Planet Bob
#      AbstractString MARS       maps to ID 499
#      AbstractString -123456    maps to ID -123456
#      AbstractString 987654     maps to ID 987654
#
#-Version
#
#   -Mice Version 1.0.2, 12-MAR-2012 (EDW), SCK (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.1, 16-MAY-2009 (EDW)
#
#       Edit to Particulars section to document the cspice_bodc2s routine.
#       Extended argument descriptions in the I/O section.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####   #####   #    #   ####   #####
#    #    #  #    #  #    #  #    #  #    #  #    #
#    #####   #    #  #    #  #    #  #       #    #
#    #    #  #    #  #    #  #    #  #       #    #
#    #    #  #    #  #    #   #  #   #    #  #    #
#    #####    ####   #####     ##     ####   #####
#
#   fetch constants for a body from the kernel pool
#   physical constants for a body
#
################################################################################
#-Abstract
#
#   bodvcd returns from the kernel pool the double precision values
#   of an item associated with a body, where the body is specified by an
#   integer ID code.
#
#-I/O
#
#   Given:
#
#      body     the scalar NAIF integer ID code for a body of interest.
#               For example, if the body is the earth, the code is
#               399.
#
#      item     the scalar string item name to return. Together, the NAIF
#               ID code of the body and the item name combine to form a
#               kernel variable name, e.g.,
#
#                    'BODY599_RADII'
#                    'BODY401_POLE_RA'
#
#               The values associated with the kernel variable having
#               the name constructed as shown are sought.  Below
#               we'll take the shortcut of calling this kernel variable
#               the "requested kernel variable."
#
#               Note that 'item' *is* case-sensitive.  This attribute
#               is inherited from the case-sensitivity of kernel
#               variable names.
#
#      maxn     the scalar integer defining the maximum number of values
#               the call returns.
#
#   the call:
#
#      values = bodvcd(body, item, maxn)
#
#   returns:
#
#     values   an array of at most 'maxn' double precision values
#              associated with the requested kernel variable.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine bodvcd_c.
#
#   MICE.REQ
#   KERNEL.REQ
#   NAIF_IDS.REQ
#
    function # bodvcd
#       (values::Float64) =   # Ptr{SpiceDouble}
        bodvcd(
            body::Int32, # SpiceInt
            item::AbstractString, # Ptr{ConstSpiceChar}
            maxn::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        values = Array{Float64}(1);  # Ptr{SpiceDouble}
        values_ptr = pointer(values)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:bodvcd_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,Ptr{ConstSpiceChar},SpiceInt,Ptr{SpiceInt},Ptr{SpiceDouble}),body,item,maxn,dim,values)
        ccall((:bodvcd_c,libNasaSpice),Void,
            (Int32,Ptr{UInt8},Int32,Ptr{Float64}),
            body,item,maxn,values_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return values[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK
#      %  file and a leapseconds file. Use a meta
#      %  kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % When the kernel variable
#      %
#      %    BODY399_RADII
#      %
#      % is present in the kernel pool---normally because a PCK
#      % defining this variable has been loaded (as is the case
#      % here)---the call
#      %
#      values1 = bodvcd( 399, 'RADII', 3)
#
#      %
#      % returns the dimension and values associated with the
#      % variable "BODY399_RADII".
#      %
#
#      %
#      % The 'item' variable possesses case sensitivity.
#      %
#      try
#
#         %
#         % A call with improper case in 'item' will fail.
#         %
#         values2 = bodvcd( 399, 'radii', 3)
#
#      catch
#
#         %
#         % Catch the error, return the error string to the user.
#         %
#         disp( 'Expected error signaled:' )
#         disp( ' ' )
#         disp( lasterr )
#
#      end
#
#      %
#      %  It's always good form to unload kernels after use,
#      %  particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      values1 =
#
#         1.0e+03 *
#
#         6.37814000000000
#         6.37814000000000
#         6.35675000000000
#
#      Expected error signaled:
#
#      SPICE(KERNELVARNOTFOUND): [bodvrd_c->BODVRD] The variable
#      BODY399_radii could not be found in the kernel pool.
#
#-Version
#
#   -Mice Version 1.1.0, 23-FEB-2009, EDW (JPL)
#
#      Added zzmice_str call on input 'item' to convert string cells to
#      character arrays if 'item' has type string cells. Added proper
#      markers for usage string variable types.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####   #####   #    #  #####   #####
#    #    #  #    #  #    #  #    #  #    #  #    #
#    #####   #    #  #    #  #    #  #    #  #    #
#    #    #  #    #  #    #  #    #  #####   #    #
#    #    #  #    #  #    #   #  #   #   #   #    #
#    #####    ####   #####     ##    #    #  #####
#
#   fetch constants for a body from the kernel pool
#   physical constants for a body
#
################################################################################
#-Abstract
#
#   bodvrd fetches from the kernel pool the double
#   precision values of an item associated with a body.
#
#-I/O
#
#   Given:
#
#      bodynm   the scalar string name of the body for which 'item'
#               is requested. 'bodynm' is case-insensitive, and leading
#               and trailing  blanks in 'bodynm' are not significant.
#               Optionally, you may supply the integer ID code for the
#               object as an integer string.  For example both 'MOON'
#               and '301' are legitimate strings that indicate the
#               moon is the body of interest.
#
#      item     the scalar string item name to return. Together, the NAIF
#               ID code of the body and the item name combine to form a
#               kernel variable name, e.g.,
#
#                    'BODY599_RADII'
#                    'BODY401_POLE_RA'
#
#               The values associated with the kernel variable having
#               the name constructed as shown are sought.  Below
#               we'll take the shortcut of calling this kernel variable
#               the "requested kernel variable."
#
#               Note that 'item' *is* case-sensitive.  This attribute
#               is inherited from the case-sensitivity of kernel
#               variable names.
#
#      maxn     the scalar integer defining the maximum number of values
#               the call returns.
#
#   the call:
#
#      values = bodvrd(body, item, maxn)
#
#   returns:
#
#     values   an array of at most 'maxn' double precision values
#              associated with the requested kernel variable.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine bodvrd_c.
#
#   MICE.REQ
#   KERNEL.REQ
#   NAIF_IDS.REQ
#
    function # bodvrd
#       (values::Float64) =   # Ptr{SpiceDouble}
        bodvrd(
            body::AbstractString, # Ptr{ConstSpiceChar}
            item::AbstractString, # Ptr{ConstSpiceChar}
            maxn::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters TODO use maxn
        values = Array{Float64}(1);  # Ptr{SpiceDouble}
        values[1] = 3.14;
        values_ptr = pointer(values)
        dims = Array{UInt32}(1);
        dims_ptr = pointer(dims)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:bodvrd_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceInt,Ptr{SpiceInt},Ptr{SpiceDouble}),body,item,maxn,dim,values)
        ccall((:bodvrd_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Int32,Ptr{Int32},Ptr{Float64}),
            body,item,1,dims_ptr,values_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return values[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK
#      %  file and a leapseconds file. Use a meta
#      %  kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % When the kernel variable
#      %
#      %    BODY399_RADII
#      %
#      % is present in the kernel pool---normally because a PCK
#      % defining this variable has been loaded (as is the case
#      % here)---the call
#      %
#      values1 = bodvrd( 'EARTH', 'RADII', 3)
#
#      %
#      % returns the dimension and values associated with the
#      % variable "BODY399_RADII".
#      %
#
#      %
#      % The call lacks case sensitivity in the 'bodynm' variable.
#      %
#     values2 = bodvrd( 'earth', 'RADII', 3)
#
#      %
#      % The 'item' variable possesses case sensitivity.
#      %
#      try
#
#         %
#         % A call with improper case in 'item' will fail.
#         %
#         values3 = bodvrd( 'EARTH', 'radii', 3)
#
#      catch
#
#         %
#         % Catch the error, return the error string to the user.
#         %
#         disp( 'Expected error signaled:' )
#         disp( ' ' )
#         disp( lasterr )
#
#      end
#
#      %
#      %  It's always good form to unload kernels after use,
#      %  particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      values1 =
#
#         1.0e+03 *
#
#         6.37814000000000
#         6.37814000000000
#         6.35675000000000
#
#      values2 =
#
#         1.0e+03 *
#
#         6.37814000000000
#         6.37814000000000
#         6.35675000000000
#
#      Expected error signaled:
#
#      SPICE(KERNELVARNOTFOUND): [bodvrd_c->BODVRD] The variable
#      BODY399_radii could not be found in the kernel pool.
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#              #     #####    ###     ###
#    #####    ##    #     #  #   #   #   #
#    #    #  # #    #     # # #   # # #   #
#    #####     #     ###### #  #  # #  #  #
#    #    #    #          # #   # # #   # #
#    #    #    #    #     #  #   #   #   #
#    #####   #####   #####    ###     ###
#
#   besselian date 1900.0
#
################################################################################
#-Abstract
#
#   b1900 returns the of the Julian Date corresponding to 
#   Besselian Date 1900.0: 2415020.31352.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      b1900 = b1900
#
#   returns:
#
#     b1900   the value 2415020.31352, the Julian Date corresponding 
#             to Besselian Date 1900.0.
#
#             [1,1] = size(b1900); double = class(b1900)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine b1900_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # b1900
        b1900()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:b1900_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:b1900_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Display the B1900 date in 16.8 format
#      %
#      disp( sprintf( '%16.8f', b1900) )
#
#   MATLAB outputs:
#
#      2415020.31352000
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#              #     #####  #######   ###
#    #####    ##    #     # #        #   #
#    #    #  # #    #     # #       # #   #
#    #####     #     ######  #####  #  #  #
#    #    #    #          #       # #   # #
#    #    #    #    #     # #     #  #   #
#    #####   #####   #####   #####    ###
#
#   besselian date 1950.0
#
################################################################################
#-Abstract
#
#   b1950 returns the value of the Julian Date corresponding
#   to Besselian Date 1950.0: 2433282.42345905.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      b1950 = b1950
#
#   returns:
#
#     b1950   the value 2433282.42345905, the Julian Date
#             corresponding to Besselian Date 1950.0
#
#             [1,1] = size(b1950); double = class(b1950)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine b1950_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # b1950
        b1950()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:b1950_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:b1950_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Display the B1950 date in 16.8 format
#      %
#      disp( sprintf( '%16.8f', b1950) )
#
#   MATLAB outputs:
#
#      2433282.42345905
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#     ####    ####   #    # #     #  ######  #
#    #    #  #    #  #    #       #  #       #
#    #       #       #    #  #####   #####   #
#    #       #  ###  #    # #        #       #
#    #    #  #    #   #  #  #        #       #
#     ####    ####     ##   #######  ######  ######
#
#   center and generating vectors to ellipse
#
################################################################################
#-Abstract
#
#   cgv2el forms a SPICE ellipse from a center vector and two generating
#   vectors.
#
#-I/O
#
#   Given:
#
#      center   the location for an ellipse center.
#
#               [3,1] = size(center); double = class(center)
#
#      vec1 &
#      vec2     the two vectors defining the ellipse (the generating vectors)
#               with the 'center' in three-dimensional space. The ellipse is
#               the set of points
#
#                  center  +  cos(theta) vec1  +  sin(theta) vec2
#
#               where theta ranges over the interval (-pi, pi].
#
#               'vec1' and 'vec2' need not be linearly independent.
#
#               [3,1] = size(vec1); double = class(vec1)
#
#               [3,1] = size(vec2); double = class(vec2)
#
#   the call:
#
#      ellipse = cgv2el( center, vec1, vec2 )
#
#   returns:
#
#      ellipse   a structure describing a SPICE ellipse defined by the input
#                vectors. 
#
#                [1,1] = size(ellipse); struct = class(ellipse)
#
#                The structure has the fields:
#
#                center:    [3,1] = size(center); double = class(center)
#                semiMinor: [3,1] = size(semiMinor); double = class(semiMinor)
#                semiMajor: [3,1] = size(semiMajor); double = class(semiMajor)
#
#-Particulars
#
#   SPICE ellipses serve to simplify calling sequences and reduce
#   the chance for error in declaring and describing argument lists
#   involving ellipses.
#
#   The set of ellipse conversion routines is
#
#      cgv2el( Center and generating vectors to ellipse )
#      cspice_el2cgv( Ellipse to center and generating vectors )
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine cgv2el_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # cgv2el
#       (ellipse::NasaSpice.Ellipse) =   # Ptr{SpiceEllipse}
        cgv2el(
            center::Array{Float64,1}, # Array_3_ConstSpiceDouble
            vec1::Array{Float64,1}, # Array_3_ConstSpiceDouble
            vec2::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(center) != 3
            error("Incorrect size for parameter 1")
        end
        if length(vec1) != 3
            error("Incorrect size for parameter 2")
        end
        if length(vec2) != 3
            error("Incorrect size for parameter 3")
        end
#       allocate the output parameters
        ellipse = Ellipse()
        ioellipse = IOBuffer()
        StrPack.pack( ioellipse, ellipse)
        ellipse_ptr = convert( Ptr{Ptr{SpiceEllipse}}, convert( Ptr{Void}, pointer(ioellipse.data) ) )
        
#       make transposed copies of all input arrays and their pointers
        center_t = center'
        center_ptr = pointer(center_t)
        vec1_t = vec1'
        vec1_ptr = pointer(vec1_t)
        vec2_t = vec2'
        vec2_ptr = pointer(vec2_t)
        
#       ccall((:cgv2el_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Ptr{SpiceEllipse}),center,vec1,vec2,ellipse)
        ccall((:cgv2el_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Ptr{SpiceEllipse}}),
            center_ptr,vec1_ptr,vec2_ptr,ellipse_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(ioellipse,0)
        ellipse = StrPack.unpack( ioellipse, Ellipse )
        return ellipse
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define the center and two linearly independent
#      % generating vectors of an ellipse (the vectors need not
#      % be linearly independent).
#      %
#      center = [ -1.;  1.; -1. ];
#      vec1   = [  1.;  1.;  1. ];
#      vec2   = [  1.; -1.;  1. ];
#
#      %
#      % Create the CSPICE_ELLIPSE structure.
#      %
#      ellipse = cgv2el( center, vec1, vec2 );
#
#      ellipse.semiMinor
#      ellipse.semiMajor
#      ellipse.center
#
#   MATLAB outputs for ellipse.semiMinor:
#
#         ans =
#
#             0.0000
#             1.4142
#             0.0000
#
#   MATLAB outputs for ellipse.semiMajor:
#
#         ans =
#
#             1.4142
#            -0.0000
#             1.4142
#
#   MATLAB outputs for ellipse.center:
#
#         ans =
#
#             -1
#              1
#             -1
#
#-Version
#
#   -Mice Version 1.0.1, 09-NOV-2012, EDW (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 30-DEC-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #   ####   #        ####
#    #    #  #   #   #    #  #       #
#    #       ####    #       #        ####
#    #       #  #    #       #            #
#    #    #  #   #   #    #  #       #    #
#     ####   #    #   ####   ######   ####
#
#   close a ck file
#
################################################################################
#-Abstract
#
#   ckcls closes a CK file opened for read or write.
#
#-I/O
#
#   Given:
#
#      handle  the scalar integer file handle for an open CK file
#
#   the call:
#
#      ckcls( handle )
#
#   closes the file indicated by 'handle'. The close operation
#   tests the file to ensure the presence of data segments.
#
#-Particulars
#
#   A ckcls call should balance every cspice_ckopn
#   call.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ckcls_c.
#
#   MICE.REQ
#   CK.REQ
#
    function # ckcls
#       (handle::Int32) =   # SpiceInt
        ckcls()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ckcls_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:ckcls_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define needed parameters, a name for the CK, the
#      % file internal name, and the number of characters
#      % to reserve for a comment block.
#      %
#      CK1        = 'type1.bc';
#      IFNAME     = 'CK';
#      NCOMCH     = 10;
#
#      %
#      % Open a new kernel.
#      %
#       handle = cspice_ckopn( CK1, IFNAME, NCOMCH);
#
#         ... do some writes to the open CK file ...
#
#      %
#      % SAFELY close the file
#      %
#      ckcls( handle )
#
#-Version
#
#   -Mice Version 1.1.0, 22-JUL-2009, EDW (JPL)
#
#      Corrected the function definition name. This wrapper had a
#      the function name "cspice_ckopn" instead of "ckcls."
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #   ####   #####
#    #    #  #   #   #    #  #    #
#    #       ####    #       #    #
#    #       #  #    #  ###  #####
#    #    #  #   #   #    #  #
#     ####   #    #   ####   #
#
#   get ck pointing
#
################################################################################
#-Abstract
#
#   ckgp returns pointing (attitude) for a specified
#   object at a user specified spacecraft clock time.
#
#-I/O
#
#   Given:
#
#      inst     NAIF ID for the instrument, spacecraft, or other structure for
#               which pointing is requested. The frame fixed to this object is
#               called the "instrument frame" or "instrument-fixed" frame.
#
#               [1,1] = size(inst); int32 = class(inst)
#
#      sclkdp   encoded spacecraft clock time(s) for which pointing is
#               requested.
#
#               [1,n] = size(sclkdp); double = class(sclkdp)
#
#      tol      time tolerance given in ticks (+/-), the units of encoded
#               spacecraft clock time, about 'sclkdp'
#
#               [1,1] = size(tol); double = class(tol)
#
#                  The C-matrix returned by ckgp, if any, is the one
#                  whose time tag is closest to 'sclkdp' and within 'tol'
#                  units of 'sclkdp'.
#
#               In general, because using a non-zero tolerance affects
#               selection of the segment from which the data is obtained,
#               users are strongly discouraged from using a non-zero
#               tolerance when reading CKs with continuous data. Using
#               a non-zero tolerance should be reserved exclusively to
#               reading CKs with discrete data because in practice
#               obtaining data from such CKs using a zero tolerance is
#               often not possible due to time round off.
#
#      ref      naming the desired reference frame for the returned pointing.
#
#               [1,m] = size(ref); char = class(ref)
#
#   the call:
#
#      [ cmat, clkout, found ] = ckgp( inst, sclkdp, tol, ref )
#
#   returns:
#
#      cmat     rotation matrix(ces) that transform components of a vector
#               expressed in the frame specified by 'ref' to components
#               expressed in the frame tied to the instrument, spacecraft, or
#               other structure at time(s) 'clkout'.
#
#               If [1,1] = size(sclkdp) then [3,3]   = size(cmat)
#               If [1,n] = size(sclkdp) then [3,3,n] = size(cmat)
#                                             double = class(cmat)
#
#      clkout   the double precision scalar or double precision 1xN array of
#               encoded spacecraft clock time(s) associated with the returned
#               C-matrix 'cmat' (this value may differ from the requested
#               time, but never by more than the input tolerance 'tol')
#
#      found    the flag(s) indicating if the requested pointing is found.
#
#               [1,n] = size(found); logical = class(found)
#
#               'cmat', 'clkout' and 'found' return with the same vectorization
#               measure (N) as 'sclkdp'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ckgp_c.
#
#   MICE.REQ
#   CK.REQ
#   SCLK.REQ
#
    function # ckgp
#       (cmat::Array{Float64,2}(3,3),  # Array_3_Array_3_SpiceDouble
#        clkout::Float64,  # Ptr{SpiceDouble}
#        found::Int32) =   # Ptr{SpiceBoolean}
        ckgp(
            inst::Int32, # SpiceInt
            sclkdp::Float64, # SpiceDouble
            tol::Float64, # SpiceDouble
            ref::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        cmat = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        cmat_ptr = pointer(cmat)
        clkout = Array{Float64}(1);  # Ptr{SpiceDouble}
        clkout_ptr = pointer(clkout)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ckgp_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceDouble,SpiceDouble,Ptr{ConstSpiceChar},Array_3_Array_3_SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceBoolean}),inst,sclkdp,tol,ref,cmat,clkout,found)
        ccall((:ckgp_c,libNasaSpice),Void,
            (Int32,Float64,Float64,Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Int32}),
            inst,sclkdp,tol,ref,cmat_ptr,clkout_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return cmat', clkout[1], convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the CK pointing file.
#      %
#      CK     = '/kernels/voyager2/ck/vg2_jup_qmw_na.bc';
#      cspice_furnsh( CK )
#
#      %
#      % Need to load a Voyager 2 SCLK kernel to convert from
#      % clock string to ticks.  Although not required for
#      % the Voyager spacecraft clocks, most modern spacecraft
#      % clocks require a leapseconds kernel to be loaded in
#      % addition to an SCLK kernel.
#      %
#      SCLK   = '/kernels/voyager2/sclk/vg200004.tsc';
#      cspice_furnsh( SCLK )
#
#      %
#      % The code for the Voyager 2 spacecraft clock is -32
#      %
#      SC     =  -32;
#
#      %
#      % The code for the narrow angle camera on the Voyager 2
#      % spacecraft is -32001.
#      %
#      INST   =  -32001;
#
#      %
#      % Spacecraft clock times for successive Voyager images always
#      % differ by more than 0:0:400.  This is an acceptable
#      % tolerance, and must be converted to "ticks" (units of
#      % encoded SCLK) for input to ckgp .
#      %
#      TOLVGR = '0:0:400';
#
#      %
#      % The reference frame we want is FK4.
#      %
#      REF    = 'FK4';
#
#      %
#      % The narrow angle camera boresight has direction
#      % ( 0, 0, 1 ) in camera (instrument) frame.
#      %
#      BORE   = [ 0.; 0.; 1.];
#      NPICS  = 2;
#
#      %
#      % Two Voyager 2 clock strings of interest.
#      %
#      SCLKCH =  strvcat( '2/18381:54:768' , '4/08970:58:768' );
#
#      %
#      % Convert tolerance from VGR formatted character string
#      % SCLK to ticks, which are units of encoded SCLK.
#      %
#      toltik = cspice_sctiks( SC, TOLVGR );
#
#      %
#      % ckgp requires encoded spacecraft clock time.
#      %
#      sclkdp = cspice_scencd( SC, SCLKCH );
#
#      %
#      % Retrieve the 'REF' reference frame to 'INST' reference frame
#      % transformation matrix at time sclkdp with a tolerance
#      % 'toltik'.
#      %
#      %   [INST] = [cmat][ref]
#      %
#      [ cmat, clkout, found ] = ckgp( INST, sclkdp, toltik, REF );
#
#      for n=1:2
#
#         if( found(n) )
#
#            %
#            % Transform the 'BORE' vector from 'INST' reference frame to
#            % 'REF' frame.
#            %                T
#            %  [ref] = [cmat] [INST]
#            %
#            bore_ref = cmat(:,:,n)' * BORE;
#
#            txt = sprintf( 'At SCLK time       : %s', SCLKCH(n,:) );
#            disp( txt )
#
#            txt = sprintf( 'The boresight vector: %16.8f %16.8f %16.8f', ...
#                                                                 bore_ref );
#            disp( txt )
#            disp( ' ' )
#
#         else
#
#            txt = sprintf( 'At SCLK time       : %s pointing not found', ...
#                                                              SCLKCH(n,:) );
#            disp( txt )
#            disp( ' ' )
#
#         end
#
#      end
#
#   MATLAB outputs:
#
#      At SCLK time       : 2/18381:54:768
#      The boresight vector:      -0.08938892       0.94794277       0.30563724
#
#      At SCLK time       : 4/08970:58:768 pointing not found
#
#-Version
#
#   -Mice Version 1.2.0, 11-JUN-2013, EDW (JPL), SCK (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#      "logical" call replaced with "zzmice_logical."
#
#   -Mice Version 1.1.1, 03-JUN-2010, BVS (JPL)
#
#      Edits to header. Added warning regarding non-zero tolerance.
#
#   -Mice Version 1.1.0, 23-FEB-2009, EDW (JPL)
#
#      Added zzmice_str call on input 'ref' to convert string cells to
#      character arrays if 'ref' has type string cells. Added proper
#      markers for usage string variable types.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #   ####   #####     ##    #    #
#    #    #  #   #   #    #  #    #   #  #   #    #
#    #       ####    #       #    #  #    #  #    #
#    #       #  #    #  ###  #####   ######  #    #
#    #    #  #   #   #    #  #       #    #   #  #
#     ####   #    #   ####   #       #    #    ##
#
#   get ck pointing and angular velocity
#
################################################################################
#-Abstract
#
#   ckgpav returns pointing (attitude) and angular velocity
#   for a specified object at a user specified spacecraft clock time.
#
#-I/O
#
#   Given:
#
#      inst     NAIF ID for the instrument, spacecraft, or other structure for
#               which pointing is requested. The frame fixed to this object is
#               called the "instrument frame" or "instrument-fixed" frame.
#
#               [1,1] = size(inst); int32 = class(inst)
#
#      sclkdp   encoded spacecraft clock time(s) for which pointing is
#               requested.
#
#               [1,n] = size(sclkdp); double = class(sclkdp)
#
#      tol      time tolerance given in ticks (+/-), the units of encoded
#               spacecraft clock time, about 'sclkdp'
#
#               [1,1] = size(tol); double = class(tol)
#
#                  The C-matrix returned by ckgpav, if any, is the one
#                  whose time tag is closest to 'sclkdp' and within 'tol'
#                  units of 'sclkdp'.
#
#               In general, because using a non-zero tolerance affects
#               selection of the segment from which the data is obtained,
#               users are strongly discouraged from using a non-zero
#               tolerance when reading CKs with continuous data. Using
#               a non-zero tolerance should be reserved exclusively to
#               reading CKs with discrete data because in practice
#               obtaining data from such CKs using a zero tolerance is
#               often not possible due to time round off.
#
#      ref      naming the desired reference frame for the returned pointing.
#
#               [1,m] = size(ref); char = class(ref)
#
#   the call:
#
#      [ cmat, av, clkout, found ] = ckgpav( inst, sclkdp, tol, ref)
#
#   returns:
#
#      cmat     rotation matrix(ces) that transform components of a vector
#               expressed in the frame specified by 'ref' to components
#               expressed in the frame tied to the instrument, spacecraft, or
#               other structure at time(s) 'clkout'.
#
#               If [1,1] = size(sclkdp) then [3,3]   = size(cmat)
#               If [1,n] = size(sclkdp) then [3,3,n] = size(cmat)
#                                             double = class(cmat)
#
#      av       angular velocity measured in radians per second (this is the
#               axis about which the reference frame tied to the instrument is
#               rotating in the right-handed sense at time 'clkout')
#
#               [3,n] = size(av); double = class(av)
#
#      clkout   encoded spacecraft clock time(s) associated with the returned
#               C-matrix 'cmat' (this value may differ from the requested time,
#               but never by more than the input tolerance 'tol').
#
#               [1,n] = size(clkout); double = class(clkout)
#
#      found    the flag(s) indicating if the requested pointing is found.
#
#               [1,n] = size(found); logical = class(found)
#
#               'cmat', 'av', 'clkout', and 'found' return with the same
#               vectorization measure (N) as 'sclkdp'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ckgpav_c.
#
#   MICE.REQ
#   CK.REQ
#   SCLK.REQ
#
    function # ckgpav
#       (cmat::Array{Float64,2}(3,3),  # Array_3_Array_3_SpiceDouble
#        av::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        clkout::Float64,  # Ptr{SpiceDouble}
#        found::Int32) =   # Ptr{SpiceBoolean}
        ckgpav(
            inst::Int32, # SpiceInt
            sclkdp::Float64, # SpiceDouble
            tol::Float64, # SpiceDouble
            ref::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        cmat = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        cmat_ptr = pointer(cmat)
        av = Array{Float64,1}(3);  # Array_3_SpiceDouble
        av_ptr = pointer(av)
        clkout = Array{Float64}(1);  # Ptr{SpiceDouble}
        clkout_ptr = pointer(clkout)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ckgpav_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceDouble,SpiceDouble,Ptr{ConstSpiceChar},Array_3_Array_3_SpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceBoolean}),inst,sclkdp,tol,ref,cmat,av,clkout,found)
        ccall((:ckgpav_c,libNasaSpice),Void,
            (Int32,Float64,Float64,Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Int32}),
            inst,sclkdp,tol,ref,cmat_ptr,av_ptr,clkout_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return cmat', av, clkout[1], convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the CK pointing file.
#      %
#      CK     = '/kernels/cassini/ck/030810_031019_c39_port1_pa.bc';
#      cspice_furnsh( CK )
#
#      %
#      % Need to load a Cassini SCLK kernel to convert from
#      % clock string to ticks and the leapseconds kernel.
#      %
#      SCLK   = '/kernels/cassini/sclk/cas00082.tsc';
#      cspice_furnsh( SCLK )
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % The code for the Cassini spacecraft is -82
#      %
#      SC     = -82;
#
#      % The code for the Cassini spacecraft bus is -82000.
#      %
#      INST   = -82000;
#
#      %
#      % The reference frame we want is J2000.
#      %
#      REF    = 'J2000';
#
#      %
#      % The bus boresight has direction ( 0, 0, 1 ) in the
#      % bus (instrument) frame.
#      %
#      BORE   = [ 0.; 0.; 1.];
#
#      %
#      % The spacecraft clock ticks every 1/256 of a second.
#      %
#      TICS   =  256.;
#
#      %
#      % Two Cassini clock strings of interest.
#      %
#      SCLKCH =  strvcat( '1440000000.000' , '1445000000.000' );
#
#      %
#      % Calculate a tolerance for pointing data. Use 5 seconds,
#      % convert to ticks by multiplying by the number of ticks
#      % per second.
#      %
#      toltik = 5. * TICS;
#
#      %
#      % ckgpav requires encoded spacecraft clock time.
#      %
#      sclkdp = cspice_scencd( SC, SCLKCH );
#
#      %
#      % Retrieve the 'REF' reference frame to 'INST' reference frame
#      % transformation matrix at time sclkdp with a tolerance
#      % 'toltik'.
#      %
#      %   [INST] = [cmat][ref]
#      %
#      [ cmat, av, clkout, found ] = ckgpav( INST, sclkdp, toltik, REF);
#
#      for n=1:2
#
#         if( found(n) )
#
#            %
#            % Transform the 'BORE' vector from 'INST' reference frame to
#            % 'REF' frame.
#            %                T
#            %  [ref] = [cmat] [INST]
#            %
#            bore_ref = cmat(:,:,n)' * BORE;
#
#            txt = sprintf( 'At SCLK time               : %s', SCLKCH(n,:) );
#            disp( txt )
#
#            txt = sprintf(                                             ...
#                  'The boresight vector       : %11.8f %11.8f %11.8f', ...
#                                                               bore_ref );
#            disp( txt )
#
#            txt = sprintf(                                            ...
#                 'The angular velocity vector: %10.7e %10.7e %10.7e', ...
#                                                               av(:,n) );
#            disp( txt )
#
#            disp( ' ' )
#
#         else
#
#            txt = sprintf( 'At SCLK time       : %s pointing not found', ...
#                                                              SCLKCH(n,:) );
#            disp( txt )
#            disp( ' ' )
#
#         end
#
#      end
#
#   MATLAB outputs:
#
#      At SCLK time               : 1440000000.000
#      The boresight vector       : -0.25517775  0.88933091  0.37944018
#      The angular velocity vector: -3.1532789e-13 -7.8841788e-09 1.7857623e-08
#
#      At SCLK time               : 1445000000.000
#      The boresight vector       : -0.31149356  0.87452887  0.37171362
#      The angular velocity vector: -8.0798136e-11 -7.1102943e-10 1.5325493e-09
#
#-Version
#
#   -Mice Version 1.2.0, 08-NOV-2012, EDW (JPL), SCK (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#      "logical" call replaced with "zzmice_logical."
#
#   -Mice Version 1.1.1, 03-JUN-2010, BVS (JPL)
#
#      Edits to header. Added warning regarding non-zero tolerance.
#
#   -Mice Version 1.1.0, 23-FEB-2009, EDW (JPL)
#
#      Added zzmice_str call on input 'ref' to convert string cells to
#      character arrays if 'ref' has type string cells. Added proper
#      markers for usage string variable types.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #   ####   #####   #    #
#    #    #  #   #   #    #  #    #  ##   #
#    #       ####    #    #  #    #  # #  #
#    #       #  #    #    #  #####   #  # #
#    #    #  #   #   #    #  #       #   ##
#     ####   #    #   ####   #       #    #
#
#   open a new ck file
#
################################################################################
#-Abstract
#
#   ckopn opens a new CK file, returning the handle
#   of the opened file.
#
#-I/O
#
#   Given:
#
#      fname    a scalar string defining the name of the CK file
#               to open
#
#      ifname   a scalar string defining the descriptive internal
#               filename for the CK
#
#      ncomch   the scalar integer number of characters to
#               reserve for comments.
#
#   the call:
#
#      handle = ckopn( name, ifname, ncomch )
#
#   returns:
#
#      handle   a scalar integer file handle assigned to 'fname'
#
#-Particulars
#
#   A cspice_ckcls call should balance every ckopn
#   call.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ckopn_c.
#
#   MICE.REQ
#   CK.REQ
#
    function # ckopn
#       (handle::Int32) =   # Ptr{SpiceInt}
        ckopn(
            name::AbstractString, # Ptr{ConstSpiceChar}
            ifname::AbstractString, # Ptr{ConstSpiceChar}
            ncomch::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # Ptr{SpiceInt}
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ckopn_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceInt,Ptr{SpiceInt}),name,ifname,ncomch,handle)
        ccall((:ckopn_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Int32,Ptr{Int32}),
            name,ifname,ncomch,handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define needed parameters, a name for the CK, the
#      % file internal name, and the number of characters
#      % to reserve for a comment block.
#      %
#      CK1        = 'type1.bc';
#      IFNAME     = 'CK';
#      NCOMCH     = 10;
#
#      %
#      % Open a new kernel.
#      %
#       handle = ckopn( CK1, IFNAME, NCOMCH);
#
#         ... do some writes to the open CK file ...
#
#      %
#      % SAFELY close the file
#      %
#      cspice_ckcls( handle )
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #          #     ####   #    #   #####
#    #    #  #          #    #    #  #    #     #
#    #       #          #    #       ######     #
#    #       #          #    #  ###  #    #     #
#    #    #  #          #    #    #  #    #     #
#     ####   ######     #     ####   #    #     #
#
#   measured velocity of light in a vacuum
#
################################################################################
#-Abstract
#
#   clight returns the value for the constant speed of light  
#   in a vacuum (IAU official value, in km/sec).
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      clight = clight
#
#   returns:
#
#      clight   the IAU official value for the speed of light in 
#               vacuo: 299792.458 km/sec.
#
#               [1,1] = size(clight); double = class(clight)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine clight_c.
#
#   MICE.REQ
#
    function # clight
        clight()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:clight_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:clight_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> speed_of_light = clight
#
#      speed_of_light =
#
#         2.9979e+05
#
#      >> sprintf( 'Speed of light: %10.3f', clight )
#
#      ans =
#
#      Speed of light: 299792.458
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #       #####    ####    ####   #
#    #    #  #       #    #  #    #  #    #  #
#    #       #       #    #  #    #  #    #  #
#    #       #       #####   #    #  #    #  #
#    #    #  #       #       #    #  #    #  #
#     ####   ######  #        ####    ####   ######
#
#   CLEAR the pool of kernel variables
#
################################################################################
#-Abstract
#
#   clpool clears the kernel pool.
#
#-I/O
#
#   The call:
#
#      clpool
#
#   deletes all variable assignments loaded into the kernel
#   pool.
#
#-Particulars
#
#   Note, clpool deletes ALL pool assignments, including those
#   from cspice_boddef and the cspice_pipool, cspice_pdpool, cspice_pcpool
#   set. Use cspice_unload to remove the assignments loaded from a
#   particular kernel.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine clpool_c.
#
#   MICE.REQ
#   KERNEL.REQ
#
    function # clpool
        clpool()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:clpool_c,"/home/don/.julia/v0.3/cspice.so"),Void,())
        ccall((:clpool_c,libNasaSpice),Void,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        return 
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Place a value into the kernel pool. Recall
#      % the routines for direct insertion
#      % of pool assignments have arrays for input,
#      % but in MATLAB a scalar is a 1x1 array.
#      %
#      cspice_pdpool( 'TEST_VAR', -666. )
#
#      %
#      % Check for the variable assignment to TEST_VAR.
#      % cspice_gdpool returns an empty array if the variable
#      % does not exist in the kernel pool.
#      %
#      dvals = cspice_gdpool( 'TEST_VAR', 0, 1 );
#
#      if ( ~isempty(dvals) )
#         disp( sprintf( 'TEST_VAR value: %f', dvals ) )
#      end
#
#      %
#      % Now clear the kernel pool.
#      %
#      clpool
#
#      %
#      % Again, check for the TEST_VAR assignment.
#      %
#      dvals = cspice_gdpool( 'TEST_VAR', 0, 1 );
#
#      if ( isempty(dvals)  )
#         disp( 'TEST_VAR not in kernel pool' )
#      end
#
#   MATLAB outputs, after the first cspice_gdpool call:
#
#      TEST_VAR value: -666.000000
#
#   Demonstrating the existence of the assignment on the
#   kernel pool.
#
#   MATLAB outputs, after the second cspice_gdpool call:
#
#      TEST_VAR not in kernel pool
#
#   The variable assignment no longer exists in the kernel pool.
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    ####   #    #     #     ####    ####
#    #    #  #    #  ##   #     #    #    #  #
#    #       #    #  # #  #     #    #        ####
#    #       #    #  #  # #     #    #            #
#    #    #  #    #  #   ##     #    #    #  #    #
#     ####    ####   #    #     #     ####    ####
#
#   state from conic elements
#
################################################################################
#-Abstract
#
#   conics determines the state (position, velocity) of an orbiting
#   body from a set of elliptic, hyperbolic, or parabolic orbital elements.
#
#-I/O
#
#   Given:
#
#      elts    a double precision 8-vector or 8xN array containing the conic
#              osculating elements describing the orbit of a body around
#              a primary. The elements are, in order:
#
#                 RP      Perifocal distance.
#                 ECC     Eccentricity.
#                 INC     Inclination.
#                 LNODE   Longitude of the ascending node.
#                 ARGP    Argument of periapse.
#                 M0      Mean anomaly at epoch.
#                 T0      Epoch.
#                 MU      Gravitational parameter.
#
#                 Units are km, rad, rad/sec, km**3/sec**2.
#
#                 The epoch T0 is given in ephemeris seconds past J2000.
#                 T0 is the instant at which the state of the body is
#                 specified by the elements.
#
#      et      the double precision scalar or 1XN-vector of ephemeris
#              time(s) at which to determine the state of the orbiting body
#
#   the call:
#
#      state = conics(elts, et)
#
#   returns
#
#      state   a double precision Cartesian 6-vector or 6xN array
#              representing the state (position and velocity) of
#              the body at time 'et' in kilometers and kilometers-per-second
#              (the first three components of 'state' represent the x-,
#              y-, and z-components of the body's position; the last three
#              components form the corresponding velocity vector)
#
#              'state' returns with the same vectorization measure (N) as
#              'elts' and 'et'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine conics_c.
#
#   MICE.REQ
#
    function # conics
#       (state::Array{Float64,1}(6)) =   # Array_6_SpiceDouble
        conics(
            elts::Array{Float64,1}, # Array_8_ConstSpiceDouble
            et::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(elts) != 8
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        
#       make transposed copies of all input arrays and their pointers
        elts_t = elts'
        elts_ptr = pointer(elts_t)
        
#       ccall((:conics_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_8_ConstSpiceDouble,SpiceDouble,Array_6_SpiceDouble),elts,et,state)
        ccall((:conics_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Ptr{Float64}),
            elts_ptr,et,state_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return state
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Calculate the perturbation between the
#      % state elements of the Moon at some time as determined
#      % from SPK data and the corresponding state elements
#      % determined from propagation of osculating elements.
#      %
#      % Load the meta kernel listing the needed SPK, PCK, LSK
#      % kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Convert the time of interest, provided as a string, to ephemeris time
#      %
#      et = cspice_str2et( 'Dec 25, 2007' );
#
#      %
#      % Call cspice_spkezr to retrieve the Moon state
#      % w.r.t. the earth in the 'J2000' frame. Use 'NONE' as aberration
#      % correction since we are comparing geometric states.
#      %
#      [state, ltime] = cspice_spkezr( 'Moon', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % cspice_oscelt requires body mass information, so load a
#      % mass PCK kernel that contains gravitation constants.
#      %
#      cspice_furnsh( '/kernels/gen/pck/masses3.tpc' )
#
#      %
#      % Read the gravitational parameter for Earth.
#      %
#      mu = cspice_bodvrd( 'EARTH', 'GM', 1 );
#
#      %
#      % Execute the cspice_oscelt call to convert the state 6-vector
#      % to the osculating elements 8-vector, 'elts', at 'et'. The osculating
#      % elements are relative to the same frame as 'state'.
#      %
#      % The elements describe the nominal orbit the Moon would follow
#      % in the absence of all other bodies in the solar system and
#      % and all non-gravitational forces.
#      %
#      % Note: the cspice_bodvrd call returns data as arrays, so
#      % to access the gravitational parameter (the only value in
#      % the array), we use 'mu(1)'.
#      %
#      elts = cspice_oscelt( state, et, mu(1) );
#
#      %
#      % Now, select a time one week from the initial epoch.
#      %
#      later = et + 7. * cspice_spd;
#
#      %
#      % Use the osculating elements to calculate the state vector
#      % of the Moon at the 'later' epoch.
#      %
#      later_state = conics( elts, later );
#
#      %
#      % Now retrieve the Moon's state at time 'later' from SPK
#      % data.
#      %
#      [state, ltime] = cspice_spkezr('Moon', later, 'J2000', 'NONE', 'EARTH');
#
#      %
#      % Display the absolute diff between the vector output by
#      % conics and the state vector returned by cspice_spkezr.
#      %
#      pert = later_state - state;
#
#      txt = sprintf( 'Perturbation in     x: %16.8f', pert(1) );
#      disp( txt )
#
#      txt = sprintf( 'Perturbation in     y: %16.8f', pert(2) );
#      disp( txt )
#
#      txt = sprintf( 'Perturbation in     z: %16.8f', pert(3) );
#      disp( txt )
#
#      txt = sprintf( 'Perturbation in dx/dt: %16.8f', pert(4) );
#      disp( txt )
#
#      txt = sprintf( 'Perturbation in dy/dt: %16.8f', pert(5) );
#      disp( txt )
#
#      txt = sprintf( 'Perturbation in dz/dt: %16.8f', pert(6) );
#      disp( txt )
#
#   MATLAB outputs:
#
#      Perturbation in     x:   -7488.81617036
#      Perturbation in     y:     397.60470311
#      Perturbation in     z:     195.74584983
#      Perturbation in dx/dt:      -0.03615259
#      Perturbation in dy/dt:      -0.00127924
#      Perturbation in dz/dt:      -0.00201456
#
#   Example (2):
#
#      %
#      % Calculate the magnitude of the perturbation between the
#      % position and velocity vectors of the Moon w.r.t. earth as
#      % calculated from conics and as retrieved from an SPK file.
#      %
#      % Load the meta kernel listing the needed SPK, PCK, LSK
#      % kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Convert the time of interest, provided as a string, to ephemeris time
#      %
#      et1 = cspice_str2et( 'Jan 1, 2007' );
#
#      %
#      % Make the cspice_spkezr call to retrieve the state of the
#      % Moon w.r.t. the earth in J2000. Use 'NONE' as aberration
#      % correction since we are comparing geometric states.
#      %
#      [state1, ltime] = cspice_spkezr( 'Moon', et1, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % cspice_oscelt requires body mass information, so load a
#      % mass PCK kernel that contains gravitation constants.
#      %
#      cspice_furnsh( '/kernels/gen/pck/masses3.tpc' )
#
#      %
#      % Read the gravitational parameter for Earth.
#      %
#      mu    = cspice_bodvrd( 'EARTH', 'GM', 1 );
#
#      elts1 = cspice_oscelt( state1, et1, mu(1) );
#
#      %
#      % We want to propagate the osculating elements in 'elts1'
#      % by N time steps. Create an array of N copies of 'elts1'
#      %
#      N     = 30;
#      elts  = repmat( elts1, 1, N );
#
#      %
#      % Create an array of N ephemeris times in steps of one day (measured
#      % in seconds) from 'et1'.
#      %
#      et             = [1:N]*cspice_spd + et1;
#
#      twobody        = conics( elts, et );
#      [state, ltime] = cspice_spkezr( 'Moon', et, 'J2000', 'NONE', 'EARTH' );
#      utc            = cspice_et2utc( et, 'C', 0 );
#
#      for n=1:N
#         txt = sprintf(                                       ...
#                '%s perturbation: ||r|| %10.4f, ||v|| %6.4f', ...
#                 utc(n,:)                                   , ...
#                 norm( state(1:3,n) - twobody(1:3,n) )      , ...
#                 norm( state(4:6,n) - twobody(4:6,n) )            );
#         disp( txt )
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#                       ... partial output ...
#
#      2007 JAN 12 00:00:00 perturbation: ||r||  5011.4764, ||v|| 0.0282
#      2007 JAN 13 00:00:00 perturbation: ||r||  7828.6919, ||v|| 0.0381
#      2007 JAN 14 00:00:00 perturbation: ||r|| 11573.2356, ||v|| 0.0498
#      2007 JAN 15 00:00:00 perturbation: ||r|| 16336.4334, ||v|| 0.0628
#      2007 JAN 16 00:00:00 perturbation: ||r|| 22123.4631, ||v|| 0.0765
#      2007 JAN 17 00:00:00 perturbation: ||r|| 28830.2006, ||v|| 0.0902
#      2007 JAN 18 00:00:00 perturbation: ||r|| 36232.8928, ||v|| 0.1033
#      2007 JAN 19 00:00:00 perturbation: ||r|| 43994.5246, ||v|| 0.1154
#
#                                ...
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    ####   #    #  #    #  #####    #####
#    #    #  #    #  ##   #  #    #  #    #     #
#    #       #    #  # #  #  #    #  #    #     #
#    #       #    #  #  # #  #    #  #####      #
#    #    #  #    #  #   ##   #  #   #   #      #
#     ####    ####   #    #    ##    #    #     #
#
#   convert units
#
################################################################################
#-Abstract
#
#   convrt converts a measurement in a specified unit
#   to another specified unit.
#
#-I/O
#
#   Given:
#
#      x     a double precision scalar or 1xN array representing a
#            measurement in the units specified by 'in'
#
#      in    the scalar sting specifying the units associated with
#            measurement 'x'
#
#      out   represents the units desired for the measurement 'x'
#
#            Acceptable units for 'in' and 'out':
#
#              Angles:                 'RADIANS'
#                                      'DEGREES'
#                                      'ARCMINUTES'
#                                      'ARCSECONDS'
#                                      'HOURANGLE'
#                                      'MINUTEANGLE'
#                                      'SECONDANGLE'
#
#              Metric Distances:       'METERS'
#                                      'KM'
#                                      'CM'
#                                      'MM'
#
#              English Distances:      'FEET'
#                                      'INCHES'
#                                      'YARDS'
#                                      'STATUTE_MILES'
#                                      'NAUTICAL_MILES'
#
#              Astrometric Distances:  'AU'
#                                      'PARSECS'
#                                      'LIGHTSECS'
#                                      'LIGHTYEARS' julian lightyears
#
#              Time:                   'SECONDS'
#                                      'MINUTES'
#                                      'HOURS'
#                                      'DAYS'
#                                      'JULIAN_YEARS'
#                                      'TROPICAL_YEARS'
#                                      'YEARS' (same as julian years)
#
#      Neither 'in' nor 'out' are case sensitive.
#
#   the call:
#
#      y = convrt( x, in, out)
#
#   returns:
#
#      y   a double precision scalar or 1xN array representing the input
#          'x' measurement converted to the units defined by 'out'
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine convrt_c.
#
#   MICE.REQ
#
    function # convrt
#       (y::Float64) =   # Ptr{SpiceDouble}
        convrt(
            x::Float64, # SpiceDouble
            _in::AbstractString, # Ptr{ConstSpiceChar}
            out::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        y = Array{Float64}(1);  # Ptr{SpiceDouble}
        y_ptr = pointer(y)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:convrt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{SpiceDouble}),x,_in,out,y)
        ccall((:convrt_c,libNasaSpice),Void,
            (Float64,Ptr{UInt8},Ptr{UInt8},Ptr{Float64}),
            x,_in,out,y_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return y[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#    Example(1):
#
#      %
#      % Convert 300 miles (statute miles) to kilometers.
#      %
#      dist_sm = 300;
#      dist_km = convrt( dist_sm, 'statute_miles', 'km' )
#
#   MATLAB outputs:
#
#      dist_km =
#
#        482.8032
#
#   Example(2):
#
#      %
#      % Determine the number of lightyears in a vector of parsec values.
#      %
#      parsec     = [1, 3, 5];
#      lightyears = convrt( parsec, 'parsecs', 'lightyears' )
#
#   MATLAB outputs:
#
#      lightyears =
#
#          3.2616    9.7847   16.3078
#
#-Version
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 07-MAR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    #   #  #       #         ##     #####
#    #    #    # #   #       #        #  #      #
#    #          #    #       #       #    #     #
#    #          #    #       #       ######     #
#    #    #     #    #       #       #    #     #
#     ####      #    ######  ######  #    #     #
#
#   cylindrical to latitudinal
#
################################################################################
#-Abstract
#
#   cyllat converts cylindrical coordinates to latitudinal
#   coordinates.
#
#-I/O
#
#   Given:
#
#      r      a double precision scalar or double precision 1xN array
#             describing the distance of the point of interest from z axis
#
#      lonc   a double precision scalar or double precision 1xN array
#             describing the cylindrical angle of the point of interest
#             from the XZ plane measured in radians
#
#      z      a double precision scalar or double precision 1xN array
#             describing the height of the point above the XY plane
#
#   the call:
#
#      [radius, lon, lat] = cyllat( r, lonc, z)
#
#   returns:
#
#      radius   a double precision scalar or double precision 1xN array
#               describing the distance of the position from origin
#
#      lon      a double precision scalar or double precision 1xN array
#               describing the angle of the position from the XZ plane
#               measured in radians
#
#      lat      a double precision scalar or double precision 1xN array
#               describing the angle of the position from the XY plane
#               measured in radians
#
#               The argument 'radius' returns in the same units associated
#               with 'r' and 'z'.
#
#               'radius', 'lon', and 'lat' return with the same
#               vectorization measure (N) as the 'r', 'lonc', and 'z'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine cyllat_c.
#
#   MICE.REQ
#
    function # cyllat
#       (radius::Float64,  # Ptr{SpiceDouble}
#        lon::Float64,  # Ptr{SpiceDouble}
#        lat::Float64) =   # Ptr{SpiceDouble}
        cyllat(
            r::Float64, # SpiceDouble
            lonc::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        radius = Array{Float64}(1);  # Ptr{SpiceDouble}
        radius_ptr = pointer(radius)
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        lat = Array{Float64}(1);  # Ptr{SpiceDouble}
        lat_ptr = pointer(lat)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:cyllat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),r,lonc,z,radius,lon,lat)
        ccall((:cyllat_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            r,lonc,z,radius_ptr,lon_ptr,lat_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return radius[1], lon[1], lat[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to cylindrical
#      % coordinates.
#      %
#      [r, lon, z]           = cspice_reccyl(pos);
#
#      %
#      % Convert the cylindrical coords to latitudinal.
#      %
#      [radius3, lon3, lat3] = cyllat(r, lon, z);
#
#      %
#      % Convert the latitudinal to rectangular.
#      %
#      [rectan]              = cspice_latrec(radius3, lon3, lat3);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-13 *
#
#                     0                  0  -0.25349834013312
#     -0.00436475351630                  0  -0.00153127196389
#                     0  -0.00121380425711   0.00203951344664
#
#      The relative error between the original array of position vectors
#      and the array that resulted from the various coordinate conversion
#      has magnitude on the order of 10^(-13).  A numerical
#      demonstration of equality.
#
#   Example (2):
#
#      %
#      % Define six sets of cylindrical coordinates, 'lonc' expressed
#      % in degrees - converted to radians by use of cspice_rpd.
#      %
#      r     = [ 1.,  1.,   1.,   1.,   0.,  0. ];
#      lonc  = [ 0., 90., 180., 180., 180., 33. ] * cspice_rpd;
#      z     = [ 0.,  0.,   1.,  -1.,   1.,  0. ];
#
#      %
#      % ...convert the cylindrical coordinates to latitudinal coordinates
#      %
#      [rad, lon, lat] = cyllat(r, lonc, z);
#
#      %
#      % ...convert angular measure to degrees.
#      %
#      lonc = lonc * cspice_dpr;
#      lon  = lon  * cspice_dpr;
#      lat  = lat  * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r         lonc        z        radius      lon        lat   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; lonc; z; rad; lon; lat ];
#
#      txt = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r         lonc        z        radius      lon        lat
#     --------   --------   --------   --------   --------   --------
#       1.0000     0.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     1.0000    90.0000     0.0000
#       1.0000   180.0000     1.0000     1.4142   180.0000    45.0000
#       1.0000   180.0000    -1.0000     1.4142   180.0000   -45.0000
#       0.0000   180.0000     1.0000     1.0000   180.0000    90.0000
#       0.0000    33.0000     0.0000     0.0000    33.0000     0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 01-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    #   #  #       #####   ######   ####
#    #    #    # #   #       #    #  #       #    #
#    #          #    #       #    #  #####   #
#    #          #    #       #####   #       #
#    #    #     #    #       #   #   #       #    #
#     ####      #    ######  #    #  ######   ####
#
#   cylindrical to rectangular
#
################################################################################
#-Abstract
#
#   cylrec converts cylindrical coordinates to rectangular
#   (Cartesian) coordinates.
#
#-I/O
#
#   Given:
#
#      r      a double precision scalar or double precision 1xN array
#             describing the distance of the point of interest from z axis.
#
#      lon    a double precision scalar or double precision 1xN array
#             describing the cylindrical angle of the point of interest
#             from the XZ plane measured in radians
#
#      z      a double precision scalar or double precision 1xN array
#             describing the height of the point above the XY plane
#
#   the call:
#
#      rectan = cylrec( r, lon, z)
#
#   returns:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#               The argument 'rectan' returns in the same units associated
#               with 'r' and 'z'.
#
#               'rectan' returns with the same vectorization measure (N) as
#               'r', 'lon', and 'z'
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine cylrec_c.
#
#   MICE.REQ
#
    function # cylrec
#       (rectan::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        cylrec(
            r::Float64, # SpiceDouble
            lon::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rectan = Array{Float64,1}(3);  # Array_3_SpiceDouble
        rectan_ptr = pointer(rectan)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:cylrec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble),r,lon,z,rectan)
        ccall((:cylrec_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            r,lon,z,rectan_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rectan
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to cylindrical
#      % coordinates.
#      %
#      [r, lon, z] = cspice_reccyl(pos);
#
#      %
#      % Convert the cylindrical to rectangular.
#      %
#      [rectan] = cylrec(r, lon, z);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#      end
#
#   MATLAB outputs:
#
#      1.0e-13 *
#
#      0.00199609007208                  0  -0.25513381329527
#     -0.00218237675815                  0  -0.00153127196389
#                     0                  0                  0
#
#       The relative error between the original array of position vectors
#       and those resulting from the coordinate conversions
#       has magnitude on the order of 10^(-13).  A numerical
#       demonstration of equality.
#
#   Example (2):
#
#      %
#      % Define six sets of cylindrical coordinates, 'lon' expressed
#      % in degrees - converted to radians by use of cspice_rpd.
#      %
#      r     = [ 1.,  1.,   1.,   1.,   0.,  0. ];
#      lon  = [ 0., 90., 180., 180., 180., 33. ] * cspice_rpd;
#      z     = [ 0.,  0.,   1.,  -1.,   1.,  0. ];
#
#      %
#      % ...convert the cylindrical coordinates to rectangular coordinates
#      %
#      [rec] = cylrec(r, lon, z);
#
#      %
#      % ...convert angular measure to degrees.
#      %
#      lon = lon * cspice_dpr;
#
#      disp('     r         lon        z           x         y           z   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; lon; z; rec(1,:); rec(2,:); rec(3,:) ];
#
#      txt = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r         lon        z           x         y           z
#     --------   --------   --------   --------   --------   --------
#       1.0000     0.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     0.0000     1.0000     0.0000
#       1.0000   180.0000     1.0000    -1.0000     0.0000     1.0000
#       1.0000   180.0000    -1.0000    -1.0000     0.0000    -1.0000
#       0.0000   180.0000     1.0000    -0.0000     0.0000     1.0000
#       0.0000    33.0000     0.0000     0.0000     0.0000     0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    #   #  #        ####   #####   #    #
#    #    #    # #   #       #       #    #  #    #
#    #          #    #        ####   #    #  ######
#    #          #    #            #  #####   #    #
#    #    #     #    #       #    #  #       #    #
#     ####      #    ######   ####   #       #    #
#
#   cylindrical to spherical
#
################################################################################
#-Abstract
#
#   cylsph converts cylindrical coordinates to spherical
#   coordinates.
#
#-I/O
#
#   Given:
#
#      r      a double precision scalar or double precision 1xN array
#             describing the distance of the point of interest from z axis.
#
#      lonc   a double precision scalar or double precision 1xN array
#             describing the cylindrical angle of the point of interest
#             from the XZ plane measured in radians
#
#      z      a double precision scalar or double precision 1xN array
#             describing the height of the point above the XY plane
#
#   the call:
#
#      [radius, colat, lon] = cylsph( r, lonc, z)
#
#   returns:
#
#      radius   a double precision scalar or double precision 1XN
#               array describing the distance of the position from origin
#
#      colat    a double precision scalar or double precision 1XN
#               array describing the angle between the point and the
#               positive z-axis, measured in radians (also referred to
#               as the polar angle)
#
#      lon      a double precision scalar or double precision 1XN array
#               describing the angle of the projection of the point to the XY
#               plane from the positive X-axis, measured in radians,
#               with range:
#
#                   -pi < lon <= pi
#
#               The positive Y-axis is at longitude PI/2 radians.
#
#               The argument 'radius' returns in the same units associated
#               with 'r' and 'z'.
#
#               'radius', 'colat', and 'lon' return with the vectorization
#               measure (N) as 'r', 'lonc', and 'z'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine cylsph_c.
#
#   MICE.REQ
#
    function # cylsph
#       (radius::Float64,  # Ptr{SpiceDouble}
#        colat::Float64,  # Ptr{SpiceDouble}
#        lon::Float64) =   # Ptr{SpiceDouble}
        cylsph(
            r::Float64, # SpiceDouble
            lonc::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        radius = Array{Float64}(1);  # Ptr{SpiceDouble}
        radius_ptr = pointer(radius)
        colat = Array{Float64}(1);  # Ptr{SpiceDouble}
        colat_ptr = pointer(colat)
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:cylsph_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),r,lonc,z,radius,colat,lon)
        ccall((:cylsph_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            r,lonc,z,radius_ptr,colat_ptr,lon_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return radius[1], colat[1], lon[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#         %
#         % Load an SPK, leapseconds, and PCK kernel set.
#         %
#         cspice_furnsh( 'standard.tm' )
#
#         %
#         % Create a vector of scalar times.
#         %
#         et = [0:2]*2.*cspice_spd;
#
#         %
#         % Retrieve the position of the moon seen from earth at 'et'
#         % in the J2000 frame without aberration correction.
#         %
#         [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#         %
#         % Convert the array of position vectors 'pos' to cylindrical
#         % coordinates.
#         %
#         [r, lon, z] = cspice_reccyl(pos);
#
#         %
#         % Convert the cylindrical coords to spherical.
#         %
#         [radius, colat, lon] = cylsph(r, lon, z);
#
#         %
#         % Convert the spherical to rectangular.
#         %
#         [rectan] = cspice_sphrec(radius, colat, lon);
#
#         %
#         % Calculate the relative error against the original position
#         % vectors.
#         %
#         (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-13 *
#
#      0.00199609007208   0.00185077353361  -0.25349834013312
#     -0.00436475351630                  0  -0.00153127196389
#     -0.00382429455002  -0.00485521702846   0.00203951344664
#
#      The relative error between the original array of position vectors
#      and those resulting from the coordinate conversions
#      has magnitude on the order of 10^(-13).
#
#   Example (2):
#
#      %
#      % Define six sets of cylindrical coordinates, 'lonc' expressed
#      % in degrees - converted to radians by use of cspice_rpd.
#      %
#      r     = [ 1.,  1.,   1.,   1.,   0.,  0. ];
#      lonc  = [ 0., 90., 180., 180., 180., 33. ] * cspice_rpd;
#      z     = [ 0.,  0.,   1.,  -1.,   1.,  0. ];
#
#      %
#      % ...convert the cylindrical coordinates to spherical coordinates
#      %
#      [radius, colat, lon] = cylsph(r, lonc, z);
#
#      %
#      % ...convert angular measure to degrees.
#      %
#      colat = colat * cspice_dpr;
#      lon  = lon    * cspice_dpr;
#      lonc = lonc   * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r         lonc        z        radius      lon       colat  ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; lonc; z; radius; lon; colat ];
#
#      txt = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r         lonc        z        radius      lon       colat
#     --------   --------   --------   --------   --------   --------
#       1.0000     0.0000     0.0000     1.0000     0.0000    90.0000
#       1.0000    90.0000     0.0000     1.0000    90.0000    90.0000
#       1.0000   180.0000     1.0000     1.4142   180.0000    45.0000
#       1.0000   180.0000    -1.0000     1.4142   180.0000   135.0000
#       0.0000   180.0000     1.0000     1.0000   180.0000     0.0000
#       0.0000    33.0000     0.0000     0.0000    33.0000     0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 01-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######  #####   #####    ####
#    #    #   #  #   #       #    #  #    #  #
#    #    #  #    #  #####   #####   #####    ####
#    #    #  ######  #       #    #  #    #       #
#    #    #  #    #  #       #    #  #    #  #    #
#    #####   #    #  #       #####   #####    ####
#
#   begin DAF backward search
#
################################################################################
#-Abstract
#
#   dafbbs initiates a backwards search for arrays in a DAF.
#
#-I/O
#
#   Given:
#
#      handle   file handle referring to a DAF.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   the call:
#
#      dafbbs( handle )
#
#   starts a backwards search, i.e. end of file to start of file,
#   on a DAF.
#
#   returns:
#
#      None.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafbbs_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafbbs
#       (handle::Int32) =   # SpiceInt
        dafbbs()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafbbs_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:dafbbs_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Use a simple function to output the double precision and integer
#   values stored in an SPK's segments descriptors. This function opens
#   a DAF for read, performs a backwards search for the DAF arrays,
#   prints the segment description for each array found, then closes the DAF.
#
#   function dafb_t( kernel )
#
#      %
#      % Open a DAF for read. Return a 'handle' referring to the file.
#      %
#      handle = cspice_dafopr( kernel );
#
#      %
#      % Define the summary parameters appropriate
#      % for an SPK file.
#      %
#      ND = 2;
#      NI = 6;
#
#      %
#      % Begin a backwards search on the file.
#      %
#      dafbbs( handle );
#
#      %
#      % Search until a DAF array is found.
#      %
#      found = cspice_daffpa;
#
#      %
#      % Loop while the search finds previous DAF arrays.
#      %
#      while found
#
#         [dc, ic ] = cspice_dafgs( ND, NI );
#
#         fprintf( 'Doubles:  ' )
#         fprintf( '%f   ', dc )
#         fprintf( '\n' )
#
#         fprintf( 'Integers: ' )
#         fprintf( '%d   ', ic )
#         fprintf( '\n\n' )
#
#
#         %
#         % Check for another segment.
#         %
#         found = cspice_daffpa;
#
#      end
#
#      %
#      % Safely close the DAF.
#      %
#      cspice_dafcls( handle )
#
#   Matlab outputs:
#
#      >> dafb_t( 'de421.bsp' )
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 499   4   1   2   2098633   2098644
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 299   2   1   2   2098621   2098632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 199   1   1   2   2098609   2098620
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 399   3   1   2   1521325   2098608
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 301   3   1   2   944041   1521324
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 10   0   1   2   820837   944040
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 9   0   1   2   785633   820836
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 8   0   1   2   750429   785632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 7   0   1   2   715225   750428
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 6   0   1   2   674741   715224
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 5   0   1   2   628977   674740
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 4   0   1   2   567373   628976
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 3   0   1   2   423049   567372
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 2   0   1   2   310405   423048
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 1   0   1   2   641   310404
#
#   Note, the specific contents of 'ic' and 'dc' depend on the
#   type of DAF.
#
#   Note, the final entries in the integer array contain the segment
#   start/end indexes. The output indicates the search proceeded
#   from the end of the file (high value index) towards the beginning
#   (low value index).
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######  #####   ######   ####
#    #    #   #  #   #       #    #  #       #
#    #    #  #    #  #####   #####   #####    ####
#    #    #  ######  #       #    #  #            #
#    #    #  #    #  #       #    #  #       #    #
#    #####   #    #  #       #####   #        ####
#
#   begin DAF forward search
#
################################################################################
#-Abstract
#
#   dafbfs initiates a forward search for arrays in a DAF.
#
#-I/O
#
#   Given:
#
#      handle   file handle referring to a DAF.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   the call:
#
#      dafbfs( handle )
#
#   starts a forwards search, i.e. start of file to end of file,
#   on a DAF.
#
#   returns:
#
#      None.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafbfs_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafbfs
#       (handle::Int32) =   # SpiceInt
        dafbfs()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafbfs_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:dafbfs_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Use a simple function to output the double precision and integer
#   values stored in an SPK's segments descriptors. This function opens
#   a DAF for read, performs a forward search for the DAF arrays,
#   prints the segment description for each array found, then closes the DAF.
#
#   function daf_t( kernel)
#
#      %
#      % Open a DAF for read. Return a 'handle' referring to the file.
#      %
#      handle = cspice_dafopr( kernel );
#
#      %
#      % Define the summary parameters appropriate
#      % for an SPK file.
#      %
#      ND = 2;
#      NI = 6;
#
#      %
#      % Begin a forward search on the file.
#      %
#      dafbfs( handle );
#
#      %
#      % Search until a DAF array is found.
#      %
#      found = cspice_daffna;
#
#      %
#      % Loop while the search finds subsequent DAF arrays.
#      %
#      while found
#
#         [dc, ic ] = cspice_dafgs( ND, NI );
#
#         fprintf( 'Doubles:  ' )
#         fprintf( '%f   ', dc )
#         fprintf( '\n' )
#
#         fprintf( 'Integers: ' )
#         fprintf( '%d   ', ic )
#         fprintf( '\n\n' )
#
#
#         %
#         % Check for another segment.
#         %
#         found = cspice_daffna;
#
#      end
#
#      %
#      % Safely close the DAF.
#      %
#      cspice_dafcls( handle )
#
#   Matlab outputs:
#
#      >> daf_t( 'de421.bsp' )
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 1   0   1   2   641   310404
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 2   0   1   2   310405   423048
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 3   0   1   2   423049   567372
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 4   0   1   2   567373   628976
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 5   0   1   2   628977   674740
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 6   0   1   2   674741   715224
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 7   0   1   2   715225   750428
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 8   0   1   2   750429   785632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 9   0   1   2   785633   820836
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 10   0   1   2   820837   944040
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 301   3   1   2   944041   1521324
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 399   3   1   2   1521325   2098608
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 199   1   1   2   2098609   2098620
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 299   2   1   2   2098621   2098632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 499   4   1   2   2098633   2098644
#
#   Note, the specific contents of 'ic' and 'dc' depend on the
#   type of DAF.
#
#   Note, the final entries in the integer array contain the segment
#   start/end indexes. The output indicates the search proceeded
#   from the start of the file (low value index) towards the end
#   (high value index).
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######   ####   #        ####
#    #    #   #  #   #       #    #  #       #
#    #    #  #    #  #####   #       #        ####
#    #    #  ######  #       #       #            #
#    #    #  #    #  #       #    #  #       #    #
#    #####   #    #  #        ####   ######   ####
#
#   close DAF
#
################################################################################
#-Abstract
#
#   dafcls closes the DAF referred to by a handle.
#
#-I/O
#
#   Given:
#
#      handle   file handle referring to a DAF.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   the call:
#
#      dafcls( handle )
#
#   closes the DAF, i.e. removes the file from read or write
#   access by the SPICE DAF subsystem.
#
#   Use this routine to close files opened by cspice_dafopr and
#   cspice_dafopw.
#
#   returns:
#
#      None.
#
#-Particulars
#
#   Because the DAF subsystem must keep track of what files are open at
#   any given time, it is important that DAF files be closed only with
#   dafcls, to prevent the remaining DAF routines from failing,
#   sometimes mysteriously.
#
#   Note that when a file is opened more than once for read access,
#   cspice_dafopr returns the same handle each time it is re-opened.
#   Each time the file is closed, dafcls checks to see if any other
#   claims on the file are still active before physically closing
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafcls_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafcls
#       (handle::Int32) =   # SpiceInt
        dafcls()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafcls_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:dafcls_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Use a simple function to output the double precision and integer
#   values stored in an SPK's segments descriptors. This function opens
#   a DAF for read, performs a forwards search for the DAF arrays,
#   prints the segment description for each array found, then closes the DAF.
#
#   function daf_t( kernel)
#
#      %
#      % Open a DAF for read. Return a 'handle' referring to the file.
#      %
#      handle = cspice_dafopr( kernel );
#
#      %
#      % Define the summary parameters appropriate
#      % for an SPK file.
#      %
#      ND = 2;
#      NI = 6;
#
#      %
#      % Begin a forward search on the file.
#      %
#      cspice_dafbfs( handle );
#
#      %
#      % Search until a DAF array is found.
#      %
#      found = cspice_daffna;
#
#      %
#      % Loop while the search finds subsequent DAF arrays.
#      %
#      while found
#
#         [dc, ic ] = cspice_dafgs( ND, NI );
#
#         fprintf( 'Doubles:  ' )
#         fprintf( '%f   ', dc )
#         fprintf( '\n' )
#
#         fprintf( 'Integers: ' )
#         fprintf( '%d   ', ic )
#         fprintf( '\n\n' )
#
#
#         %
#         % Check for another segment.
#         %
#         found = cspice_daffna;
#
#      end
#
#      %
#      % Safely close the DAF.
#      %
#      dafcls( handle )
#
#   Matlab outputs:
#
#      >> daf_t( 'de421.bsp' )
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 1   0   1   2   641   310404
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 2   0   1   2   310405   423048
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 3   0   1   2   423049   567372
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 4   0   1   2   567373   628976
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 5   0   1   2   628977   674740
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 6   0   1   2   674741   715224
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 7   0   1   2   715225   750428
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 8   0   1   2   750429   785632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 9   0   1   2   785633   820836
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 10   0   1   2   820837   944040
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 301   3   1   2   944041   1521324
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 399   3   1   2   1521325   2098608
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 199   1   1   2   2098609   2098620
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 299   2   1   2   2098621   2098632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 499   4   1   2   2098633   2098644
#
#   Note, the specific contents of 'ic' and 'dc' depend on the
#   type of DAF.
#
#   Note, the final entries in the integer array contain the segment
#   start/end indexes. The output indicates the search proceeded
#   from the start of the file (low value index) towards the end
#   (high value index).
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######   ####    ####
#    #    #   #  #   #       #    #  #
#    #    #  #    #  #####   #        ####
#    #    #  ######  #       #            #
#    #    #  #    #  #       #    #  #    #
#    #####   #    #  #        ####    ####
#
#   select a DAF to continue searching
#
################################################################################
#-Abstract
#
#   dafcs sets the active DAF to search. A search must be
#   in progress for the DAF.
#
#-I/O
#
#   Given:
#
#      handle   the file handle referring to a DAF to
#               set as the "active" file for a search.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   the call:
#
#      dafcs( handle )
#
#   causes all DAF search activity apply to the file
#   referred to by 'handle'.
#
#   returns:
#
#      None.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafcs_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafcs
#       (handle::Int32) =   # SpiceInt
        dafcs()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafcs_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:dafcs_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example(1):
#
#      %
#      % Define two SPK test files.
#      %
#      SPK1 = 'test.bsp';
#      SPK2 = 'test8.bsp';
#
#      %
#      % Open the DAFs for read
#      %
#      han1 = cspice_dafopr( SPK1 );
#      han2 = cspice_dafopr( SPK2 );
#
#      %
#      % Begin a forward search on SPK1
#      %
#      cspice_dafbfs( han1 )
#      found = cspice_daffna;
#
#      %
#      % Begin a backwards search on SPK2
#      %
#      cspice_dafbbs( han2 )
#      found2 = cspice_daffpa;
#
#      %
#      % Reinstitute the search on han1, loop
#      % so long as segment data are found.
#      %
#      dafcs( han1 )
#
#      while ( found )
#
#         segid    = cspice_dafgn;
#         found    = cspice_daffna;
#
#         %
#         % Output each segment ID.
#         %
#         fprintf( '%s\n', segid )
#
#      end
#
#      %
#      % Close the files.
#      %
#      cspice_dafcls( han1 )
#      cspice_dafcls( han2 )
#
#   Matlab outputs:
#
#      PHOENIX SPACECRAFT
#      MERCURY BARYCENTER
#      VENUS BARYCENTER
#      EARTH BARYCENTER
#      MARS BARYCENTER
#      JUPITER BARYCENTER
#      SATURN BARYCENTER
#      URANUS BARYCENTER
#      NEPTUNE BARYCENTER
#      PLUTO BARYCENTER
#      MOON
#      PHOBOS
#      DEIMOS
#      IO
#      EUROPA
#      GANYMEDE
#      CALLISTO
#      TETHYS
#      DIONE
#      RHEA
#      TITAN
#      HYPERION
#      IAPETUS
#      ARIEL
#      UMBRIEL
#      TITANIA
#      OBERON
#      MIRANDA
#      TRITON
#      NERIED
#      CHARON
#      MERCURY
#      VENUS
#      EARTH
#      MARS
#      JUPITER
#      SATURN
#      URANUS
#      NEPTUNE
#      PLUTO
#      SUN
#      GOLDSTONE
#      CANBERRA
#      MADRID
#      PHOBOS BASECAMP
#      TRANQUILITY BASE
#
#   Example(2), switch the definitions for SPK1 and SPK2:
#
#      %
#      % Define two SPK test files.
#      %
#      SPK2 = 'test.bsp';
#      SPK1 = 'test8.bsp';
#
#         ... remainder of example unchanged ..
#
#   Matlab outputs:
#
#      SPK type 8 test segment
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######  #####    ####
#    #    #   #  #   #       #    #  #    #
#    #    #  #    #  #####   #    #  #
#    #    #  ######  #       #    #  #
#    #    #  #    #  #       #    #  #    #
#    #####   #    #  #       #####    ####
#
#    delete DAF comment area
#
################################################################################
#-Abstract
#
#   dafdc deletes the entire comment area of a specified DAF file.
#
#-I/O
#
#   Given:
#
#      handle   the file handle referring to a DAF file opened with
#               write access. This handle refers to the DAF file from which
#               to delete the comment section.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   the call:
#
#      dafdc( handle )
#
#   removes the comment area of the DAF file referred to by 'handle'.
#
#   returns:
#
#      None.
#
#-Particulars
#
#   A binary DAF contains an area which is reserved for storing
#   annotations or descriptive textual information about the data
#   contained in a file. This area is referred to as the ``comment
#   area'' of the file. The comment area of a DAF is a line oriented
#   medium for storing textual information. The comment area preserves
#   any leading or embedded white space in the line(s) of text which are
#   stored, so that the appearance of the of information will be
#   unchanged when it is retrieved (extracted) at some other time.
#   Trailing blanks, however, are NOT preserved, due to the way that
#   character strings are represented in standard Fortran 77.
#
#   This routine will delete the entire comment area from the binary DAF
#   attached to `handle'. The size of the binary DAF will remain
#   unchanged. The space that was used by the comment records is
#   reclaimed:  the data area of the DAF is shifted toward the beginning
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafdc_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafdc
#       (handle::Int32) =   # SpiceInt
        dafdc()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafdc_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:dafdc_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %    Given an SPK with a comment section:
#      %
#      %      Body list
#      %       1 MERCURY BARYCENTER
#      %       2 VENUS BARYCENTER
#      %       3 EARTH BARYCENTER
#      %       4 MARS BARYCENTER
#      %       5 JUPITER BARYCENTER
#      %       6 SATURN BARYCENTER
#      %       7 URANUS BARYCENTER
#      %       8 NEPTUNE BARYCENTER
#      %
#      %             ...
#
#      %
#      % Define the SPK file from which to remove the comments section.
#      %
#      SPK = 'test.spk';
#
#      %
#      % Open for writing the 'SPK', return the corresponding
#      % file handle to 'handle'.
#      %
#      handle = cspice_dafopw( SPK );
#
#      %
#      % Remove the comment section from the DAF referred to by 'handle'.
#      %
#      dafdc( handle )
#
#      %
#      % SAFELY close the file.
#      %
#      cspice_dafcls( handle )
#
#   Examine the 'SPK' comment after the dafdc call.
#
#      $ commnt -r test.spk
#
#      There were no comments in the file 'test.spk'.
#
#   Matlab outputs:
#
#      None.
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######  ######  #    #    ##
#    #    #   #  #   #       #       ##   #   #  #
#    #    #  #    #  #####   #####   # #  #  #    #
#    #    #  ######  #       #       #  # #  ######
#    #    #  #    #  #       #       #   ##  #    #
#    #####   #    #  #       #       #    #  #    #
#
#   find next DAF array
#
################################################################################
#-Abstract
#
#   daffna finds the next DAF array, during a forward search.
#
#-I/O
#
#   Given:
#
#      None.
#
#   the call:
#
#      found = daffna
#
#   returns:
#
#      found   flag signaling whether the search found a DAF array, true,
#              or not, false.
#
#              [1,1] = size(found); logical = class(found)
#
#   Note, a call to cspice_dafbfs is required before calling
#   daffna.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine daffna_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # daffna
#       (found::Int32) =   # Ptr{SpiceBoolean}
        daffna()
        
#       enforce input array sizes
#       allocate the output parameters
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:daffna_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{SpiceBoolean},),found)
        ccall((:daffna_c,libNasaSpice),Void,
            (Ptr{Int32},),
            found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Use a simple function to output the double precision and integer
#   values stored in an SPK's segments descriptors. This function opens
#   a DAF for read, performs a forward search for the DAF arrays,
#   prints the segment description for each array found, then closes the DAF.
#
#   function daf_t( kernel)
#
#      %
#      % Open a DAF for read. Return a 'handle' referring to the file.
#      %
#      handle = cspice_dafopr( kernel );
#
#      %
#      % Define the summary parameters appropriate
#      % for an SPK file.
#      %
#      ND = 2;
#      NI = 6;
#
#      %
#      % Begin a forward search on the file.
#      %
#      cspice_dafbfs( handle );
#
#      %
#      % Search until a DAF array is found.
#      %
#      found = daffna;
#
#      %
#      % Loop while the search finds subsequent DAF arrays.
#      %
#      while found
#
#         [dc, ic ] = cspice_dafgs( ND, NI );
#
#         fprintf( 'Doubles:  ' )
#         fprintf( '%f   ', dc )
#         fprintf( '\n' )
#
#         fprintf( 'Integers: ' )
#         fprintf( '%d   ', ic )
#         fprintf( '\n\n' )
#
#
#         %
#         % Check for another segment.
#         %
#         found = daffna;
#
#      end
#
#      %
#      % Safely close the DAF.
#      %
#      cspice_dafcls( handle )
#
#   Matlab outputs:
#
#      >> daf_t( 'de421.bsp' )
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 1   0   1   2   641   310404
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 2   0   1   2   310405   423048
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 3   0   1   2   423049   567372
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 4   0   1   2   567373   628976
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 5   0   1   2   628977   674740
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 6   0   1   2   674741   715224
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 7   0   1   2   715225   750428
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 8   0   1   2   750429   785632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 9   0   1   2   785633   820836
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 10   0   1   2   820837   944040
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 301   3   1   2   944041   1521324
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 399   3   1   2   1521325   2098608
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 199   1   1   2   2098609   2098620
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 299   2   1   2   2098621   2098632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 499   4   1   2   2098633   2098644
#
#   Note, the specific contents of 'ic' and 'dc' depend on the
#   type of DAF.
#
#   Note, the final entries in the integer array contain the segment
#   start/end indexes. The output indicates the search proceeded
#   from the start of the file (low value index) towards the end
#   (high value index).
#
#-Version
#
#   -Mice Version 1.0.0, 11-JUN-2013, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######  ######  #####     ##
#    #    #   #  #   #       #       #    #   #  #
#    #    #  #    #  #####   #####   #    #  #    #
#    #    #  ######  #       #       #####   ######
#    #    #  #    #  #       #       #       #    #
#    #####   #    #  #       #       #       #    #
#
#   find next DAF array
#
################################################################################
#-Abstract
#
#   daffpa finds the next DAF array, during a backwards search.
#
#-I/O
#
#   Given:
#
#      None.
#
#   the call:
#
#      found = daffpa
#
#   returns:
#
#      found   flag signaling whether the search found a DAF array, true,
#              or not, false.
#
#              [1,1] = size(found); logical = class(found)
#
#   Note, a call to cspice_dafbbs is required before calling
#   daffpa.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine daffpa_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # daffpa
#       (found::Int32) =   # Ptr{SpiceBoolean}
        daffpa()
        
#       enforce input array sizes
#       allocate the output parameters
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:daffpa_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{SpiceBoolean},),found)
        ccall((:daffpa_c,libNasaSpice),Void,
            (Ptr{Int32},),
            found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Use a simple function to output the double precision and integer
#   values stored in an SPK's segments descriptors. This function opens
#   a DAF for read, performs a backwards search for the DAF arrays,
#   prints segments description for each array found, then closes the DAF.
#
#   function dafb_t( kernel )
#
#      %
#      % Open a DAF for read. Return a 'handle' referring to the file.
#      %
#      handle = cspice_dafopr( kernel );
#
#      %
#      % Define the summary parameters appropriate
#      % for an SPK file.
#      %
#      ND = 2;
#      NI = 6;
#
#      %
#      % Begin a backwards search on the file.
#      %
#      cspice_dafbbs( handle );
#
#      %
#      % Search until a DAF array is found.
#      %
#      found = daffpa;
#
#      %
#      % Loop while the search finds previous DAF arrays.
#      %
#      while found
#
#         [dc, ic ] = cspice_dafgs( ND, NI );
#
#         fprintf( 'Doubles:  ' )
#         fprintf( '%f   ', dc )
#         fprintf( '\n' )
#
#         fprintf( 'Integers: ' )
#         fprintf( '%d   ', ic )
#         fprintf( '\n\n' )
#
#
#         %
#         % Check for another segment.
#         %
#         found = daffpa;
#
#      end
#
#      %
#      % Safely close the DAF.
#      %
#      cspice_dafcls( handle )
#
#   Matlab outputs:
#
#      >> dafb_t( 'de421.bsp' )
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 499   4   1   2   2098633   2098644
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 299   2   1   2   2098621   2098632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 199   1   1   2   2098609   2098620
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 399   3   1   2   1521325   2098608
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 301   3   1   2   944041   1521324
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 10   0   1   2   820837   944040
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 9   0   1   2   785633   820836
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 8   0   1   2   750429   785632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 7   0   1   2   715225   750428
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 6   0   1   2   674741   715224
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 5   0   1   2   628977   674740
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 4   0   1   2   567373   628976
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 3   0   1   2   423049   567372
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 2   0   1   2   310405   423048
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 1   0   1   2   641   310404
#
#   Note, the specific contents of 'ic' and 'dc' depend on the
#   type of DAF.
#
#   Note, the final entries in the integer array contain the segment
#   start/end indexes. The output indicates the search proceeded
#   from the end of the file (high value index) towards the beginning
#   (low value index).
#
#-Version
#
#   -Mice Version 1.0.0, 11-JUN-2013, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######   ####   #####     ##
#    #    #   #  #   #       #    #  #    #   #  #
#    #    #  #    #  #####   #       #    #  #    #
#    #    #  ######  #       #  ###  #    #  ######
#    #    #  #    #  #       #    #  #    #  #    #
#    #####   #    #  #        ####   #####   #    #
#
#   read data from DAF address
#
################################################################################
#-Abstract
#
#   dafgda reads the double precision data bounded by two addresses
#   within a DAF.
#
#-I/O
#
#   Given:
#
#      handle   file handle referring to a DAF.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#      baddr,
#      eaddr    initial and final addresses of a contiguous set of double
#               precision numbers within a DAF. Presumably, these make up
#               all or part of a particular array.
#
#               Note that DAF addresses begin at 1 as in the
#               FORTRAN version of the SPICE Toolkit.
#
#               [1,1] = size(baddr); int32 = class(baddr)
#               [1,1] = size(eaddr); int32 = class(eaddr)
#
#   the call:
#
#      data = dafgda( handle, baddr, eaddr )
#
#   returns:
#
#      data   are the double precision data contained between
#             the specified addresses within the specified file.
#
#             'data' has length = end - begin + 1.
#
#             [1,length] = size(data); double = class(data)
#
#-Particulars
#
#   The principal reason that DAFs are so easy to use is that
#   the data in each DAF are considered to be one long contiguous
#   set of double precision numbers. You can grab data from anywhere
#   within a DAF without knowing (or caring) about the physical
#   records in which they are stored.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafgda_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafgda
#       (data::Float64) =   # Ptr{SpiceDouble}
        dafgda(
            handle::Int32, # SpiceInt
            _begin::Int32, # SpiceInt
            _end::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        data = Array{Float64}(1);  # Ptr{SpiceDouble}
        data_ptr = pointer(data)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafgda_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceInt,SpiceInt,Ptr{SpiceDouble}),handle,_begin,_end,data)
        ccall((:dafgda_c,libNasaSpice),Void,
            (Int32,Int32,Int32,Ptr{Float64}),
            handle,_begin,_end,data_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return data[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Open the type 8 SPK "gda.bsp" for read access then read the
#      % data from the first segment. The segment contains 100
#      % 6 element records plus four additional elements.
#      %
#      handle = cspice_dafopr( 'gda.bsp');
#
#      %
#      % Begin a forward search; find the first segment; read the
#      % segment summary.
#      %
#      cspice_dafbfs( handle )
#      found    = cspice_daffna;
#      [dc, ic] = cspice_dafgs( 2, 6 );
#
#      %
#      % Retrieve the data begin and end addresses.
#      %
#      baddr = ic(5);
#      eaddr = ic(6);
#
#      fprintf( 'Beginning address       : %d\n', baddr )
#      fprintf( 'Ending address          : %d\n', eaddr )
#      fprintf( 'Number of data elements : %d\n', eaddr - baddr + 1 )
#
#      %
#      % Extract all data bounded by the begin and end addresses.
#      %
#      data = dafgda( handle, baddr, eaddr );
#
#      %
#      % Check 'data'. It should show an array of 604 doubles (4 + 6 * 100).
#      %
#      fprintf( 'Size of data array      : ' )
#      fprintf( '%d ', size(data) )
#      fprintf('\n\n')
#
#      %
#      % Check the data. Each set of 6 element records should possess the
#      % property:
#      %
#      %   record(6) = record(6)  + 1000.
#      %        i            i-1
#      %
#      fprintf( ' %7.2f ', data(1:6) )
#      fprintf('\n')
#
#      fprintf( ' %6.2f ', data(7:12) )
#      fprintf('\n')
#
#      %
#      % SAFELY close the file
#      %
#      cspice_dafcls(handle)
#
#   Matlab outputs:
#
#      Beginning address       : 385
#      Ending address          : 988
#      Number of data elements : 604
#      Size of data array      : 1 604
#
#          0.00     1.00     2.00     3.00     4.00     5.00
#       1000.00  1001.00  1002.00  1003.00  1004.00  1005.00
#
#   dafgda returned 604 double precision data values between DAF
#   addresses 385 and 988. The second 6-vector shows the property of 1000
#   more than the previous set, as expected.
#
#-Version
#
#   -Mice Version 1.0.0, 17-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######   ####   #####   #####
#    #    #   #  #   #       #    #  #    #  #    #
#    #    #  #    #  #####   #    #  #    #  #    #
#    #    #  ######  #       #    #  #####   #####
#    #    #  #    #  #       #    #  #       #   #
#    #####   #    #  #        ####   #       #    #
#
#   open DAF for read
#
################################################################################
#-Abstract
#
#   dafopr opens a DAF for subsequent read requests.
#
#-I/O
#
#   Given:
#
#      fname   the string name of a DAF to open for read (search) access.
#
#              [1,c1] = size(fname); char = class(fname)
#
#                 or
#
#              [1,1] = size(fname); cell = class(fname)
#
#   the call:
#
#      handle = dafopr( fname )
#
#   returns:
#
#      handle   the file handle used by other DAF routines
#               to refer to 'fname'.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   Use cspice_dafcls to close files opened by this routine.
#
#-Particulars
#
#   Most DAFs require only read access. If you do not need to
#   change the contents of a file, you should open it with dafopr.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafopr_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafopr
#       (handle::Int32) =   # Ptr{SpiceInt}
        dafopr(
            fname::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # Ptr{SpiceInt}
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafopr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceInt}),fname,handle)
        ccall((:dafopr_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32}),
            fname,handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Use a simple function to output the double precision and integer
#   values stored in an SPK's segments descriptors. This function opens
#   a DAF for read, performs a forwards search for the DAF arrays,
#   prints the segment description for each array found, then closes the DAF.
#
#   function daf_t( kernel)
#
#      %
#      % Open a DAF for read. Return a 'handle' referring to the file.
#      %
#      handle = dafopr( kernel );
#
#      %
#      % Define the summary parameters appropriate
#      % for an SPK file.
#      %
#      ND = 2;
#      NI = 6;
#
#      %
#      % Begin a forward search on the file.
#      %
#      cspice_dafbfs( handle );
#
#      %
#      % Search until a DAF array is found.
#      %
#      found = cspice_daffna;
#
#      %
#      % Loop while the search finds subsequent DAF arrays.
#      %
#      while found
#
#         [dc, ic ] = cspice_dafgs( ND, NI );
#
#         fprintf( 'Doubles:  ' )
#         fprintf( '%f   ', dc )
#         fprintf( '\n' )
#
#         fprintf( 'Integers: ' )
#         fprintf( '%d   ', ic )
#         fprintf( '\n\n' )
#
#
#         %
#         % Check for another segment.
#         %
#         found = cspice_daffna;
#
#      end
#
#      %
#      % Safely close the DAF.
#      %
#      cspice_dafcls( handle )
#
#   Matlab outputs:
#
#      >> daf_t( 'de421.bsp' )
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 1   0   1   2   641   310404
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 2   0   1   2   310405   423048
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 3   0   1   2   423049   567372
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 4   0   1   2   567373   628976
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 5   0   1   2   628977   674740
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 6   0   1   2   674741   715224
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 7   0   1   2   715225   750428
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 8   0   1   2   750429   785632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 9   0   1   2   785633   820836
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 10   0   1   2   820837   944040
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 301   3   1   2   944041   1521324
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 399   3   1   2   1521325   2098608
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 199   1   1   2   2098609   2098620
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 299   2   1   2   2098621   2098632
#
#      Doubles:  -3169195200.000000   1696852800.000000
#      Integers: 499   4   1   2   2098633   2098644
#
#   Note, the specific contents of 'ic' and 'dc' depend on the
#   type of DAF.
#
#   Note, the final entries in the integer array contain the segment
#   start/end indexes. The output indicates the search proceeded
#   from the start of the file (low value index) towards the end
#   (high value index).
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    ######   ####   #####   #    #
#    #    #   #  #   #       #    #  #    #  #    #
#    #    #  #    #  #####   #    #  #    #  #    #
#    #    #  ######  #       #    #  #####   # ## #
#    #    #  #    #  #       #    #  #       ##  ##
#    #####   #    #  #        ####   #       #    #
#
#   open DAF for write
#
################################################################################
#-Abstract
#
#   dafopw opens a DAF for subsequent write requests.
#
#-I/O
#
#   Given:
#
#      fname   the string name of a DAF to open for write access.
#
#              [1,c1] = size(fname); char = class(fname)
#
#                 or
#
#              [1,1] = size(fname); cell = class(fname)
#
#   the call:
#
#      handle = dafopw( fname )
#
#   returns:
#
#      handle   the file handle used other DAF routines
#               to refer to 'fname'.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   Use cspice_dafcls to close files opened by this routine.
#
#-Particulars
#
#   Most DAFs require only read access. If you do not need to
#   change the contents of a file, you should open it with cspice_dafopr.
#   Use dafopw when you need to
#
#      -- change (update) one or more summaries, names, or
#         arrays within a file; or
#
#      -- add new arrays to a file.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dafopw_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # dafopw
#       (handle::Int32) =   # Ptr{SpiceInt}
        dafopw(
            fname::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # Ptr{SpiceInt}
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dafopw_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceInt}),fname,handle)
        ccall((:dafopw_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32}),
            fname,handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %    Given an SPK with a comment section:
#      %
#      %      Body list
#      %       1 MERCURY BARYCENTER
#      %       2 VENUS BARYCENTER
#      %       3 EARTH BARYCENTER
#      %       4 MARS BARYCENTER
#      %       5 JUPITER BARYCENTER
#      %       6 SATURN BARYCENTER
#      %       7 URANUS BARYCENTER
#      %       8 NEPTUNE BARYCENTER
#      %
#      %             ...
#
#      %
#      % Define the SPK file from which to remove the comments section.
#      %
#      SPK = 'test.spk';
#
#      %
#      % Open for writing the 'SPK', return the corresponding
#      % file handle to 'handle'.
#      %
#      handle = dafopw( SPK );
#
#      %
#      % Remove the comments section from the DAF referred to by 'handle'.
#      %
#      cspice_dafdc( handle )
#
#      %
#      % SAFELY close the file.
#      %
#      cspice_dafcls( handle )
#
#   Examine the 'SPK' comment after the cspice_dafdc call.
#
#      $ commnt -r test.spk
#
#      There were no comments in the file 'test.spk'.
#
#   Matlab outputs:
#
#      None.
#
#-Version
#
#   -Mice Version 1.0.0, 10-JUL-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####    #   #  #       #####   #####
#    #    #  #    #    # #   #       #    #  #    #
#    #    #  #          #    #       #    #  #    #
#    #    #  #          #    #       #    #  #####
#    #    #  #    #     #    #       #    #  #   #
#    #####    ####      #    ######  #####   #    #
#
#   Jacobian of cylindrical w.r.t. rectangular coordinates
#
################################################################################
#-Abstract
#
#   dcyldr computes the Jacobian of the transformation from
#   rectangular to cylindrical coordinates.
#
#-I/O
#
#   Given:
#
#      x   [1,n] = size(x); double = class(x)
#
#      y   [1,n] = size(y); double = class(y)
#
#      z   [1,n] = size(z); double = class(z)
#
#          the rectangular coordinates of the point at which the Jacobian of
#          the map from rectangular to cylindrical coordinates is desired.
#
#   the call:
#
#      jacobi = dcyldr( x, y, z)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               rectangular and cylindrical coordinates. It has the form
#
#               If [1,1] = size(x) then [3,3]   = size(jacobi)
#               If [1,n] = size(x) then [3,3,n] = size(jacobi)
#                                        double = class(jacobi)
#
#                   -                            -
#                  |  dr/dx     dr/dy    dr/dz    |
#                  |                              |
#                  |  dlon/dx   dlon/dy  dlon/dz  |
#                  |                              |
#                  |  dz/dx     dz/dy    dz/dz    |
#                   -                            -
#
#               evaluated at the input values of x, y, and z.
#
#-Particulars
#
#   When performing vector calculations with velocities it is
#   usually most convenient to work in rectangular coordinates.
#   However, once the vector manipulations have been performed,
#   it is often desirable to convert the rectangular representations
#   into cylindrical coordinates to gain insights about phenomena
#   in this coordinate frame.
#
#   To transform rectangular velocities to derivatives of
#   coordinates in a cylindrical system, one uses the Jacobian
#   of the transformation between the two systems.
#
#   Given a state in rectangular coordinates
#
#      ( x, y, z, dx, dy, dz )
#
#   the velocity in cylindrical coordinates is given by the matrix
#   equation:
#
#                    t          |                     t
#      (dr, dlon, dz)   = jacobi|       * (dx, dy, dz)
#                               |(x,y,z)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(x,y,z)
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dcyldr_c.
#
#   MICE.REQ
#
    function # dcyldr
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        dcyldr(
            x::Float64, # SpiceDouble
            y::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dcyldr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),x,y,z,jacobi)
        ccall((:dcyldr_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            x,y,z,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 11-NOV-2013, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######  #        #####  ######   #####
#    #    #  #       #          #    #          #
#    #    #  #####   #          #    #####      #
#    #    #  #       #          #    #          #
#    #    #  #       #          #    #          #
#    #####   ######  ######     #    ######     #
#
#   difference between ephemeris time and utc
#
################################################################################
#-Abstract
#
#   deltet returns value of Delta ET (ET-UTC)
#   for an input epoch.
#
#-I/O
#
#   Given:
#
#      epoch    the double precision scalar or N-vector of
#               epochs at which "delta ET" is to be computed.
#               'epoch' may be either UTC or ephemeris seconds
#               past J2000, as specified by 'eptype'.
#
#      eptype   the scalar string indicating the type of input
#               epoch. It may be either of the following:
#
#                  'UTC'   UTC seconds past J2000 UTC.
#
#                  'ET'    Ephemeris seconds past J2000 TDB,
#                          also known as barycentric
#                          dynamical time (TDB).
#
#   the call:
#
#      delta = deltet( epoch, eptype )
#
#   returns:
#
#      delta   the double precision scalar or N-vector
#              values of
#
#                 "delta ET" = ET - UTC
#
#              at the input 'epoch'. This is added to UTC to
#              give ET, or subtracted from ET to give UTC.
#
#              'delta' return with the same vectorization measure
#              (N) as 'epoch'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine deltet_c.
#
#   MICE.REQ
#   TIME.REQ
#   KERNEL.REQ
#
    function # deltet
#       (delta::Float64) =   # Ptr{SpiceDouble}
        deltet(
            epoch::Float64, # SpiceDouble
            eptype::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        delta = Array{Float64}(1);  # Ptr{SpiceDouble}
        delta_ptr = pointer(delta)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:deltet_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,Ptr{ConstSpiceChar},Ptr{SpiceDouble}),epoch,eptype,delta)
        ccall((:deltet_c,libNasaSpice),Void,
            (Float64,Ptr{UInt8},Ptr{Float64}),
            epoch,eptype,delta_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return delta[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load a leapsecond file.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define times of interest and the array size
#      % parameter.
#      %
#      SIZE     = 2004 - 1997 +1;
#      UTC_1997 = 'Jan 1 1997';
#      UTC_2004 = 'Jan 1 2004';
#
#      %
#      % Convert the UTC time strings to ET.
#      %
#      et_1997 = cspice_str2et( UTC_1997 );
#      et_2004 = cspice_str2et( UTC_2004 );
#
#      %
#      % Calculate the ET-UTC delta at Jan 1 1997
#      % and Jan 1 2004.
#      %
#      delt_1997 = deltet( et_1997, 'ET' );
#      delt_2004 = deltet( et_2004, 'ET' );
#
#      disp( 'Scalar:' )
#      disp( sprintf( 'Delta 1997: %f'  , delt_1997 ) )
#      disp( sprintf( 'Delta 2004: %f\n', delt_2004 ) )
#
#      %
#      % Given an array of 'SIZE' ephemeris times
#      % starting from value 'et_1997' with steps being
#      % of the number of seconds per Julian year, return
#      % the ET-UTC delta value for each time.
#      %
#      et   = [0:SIZE-1]*cspice_jyear + et_1997;
#      delt = deltet( et, 'ET' );
#
#      %
#      % Convert 'et' to 'utc'.
#      %
#      utc = cspice_et2utc( et, 'C', 3 );
#
#      disp( 'Vector:' )
#      for n=1:SIZE
#         txt = sprintf( '%s delta %f', utc(n,:), delt(n) );
#         disp( txt )
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#      Delta 1997: 62.183935
#      Delta 2004: 64.183912
#
#      Vector:
#      1997 JAN 01 00:00:00.000 delta 62.183935
#      1998 JAN 01 05:59:59.000 delta 63.183935
#      1999 JAN 01 11:59:58.000 delta 64.183935
#      2000 JAN 01 17:59:58.000 delta 64.183935
#      2000 DEC 31 23:59:58.000 delta 64.183934
#      2002 JAN 01 05:59:58.000 delta 64.183934
#      2003 JAN 01 11:59:58.000 delta 64.183934
#      2004 JAN 01 17:59:58.000 delta 64.183933
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####   ######   ####   #####   #####
#    #    #  #    #  #       #    #  #    #  #    #
#    #    #  #       #####   #    #  #    #  #    #
#    #    #  #  ###  #       #    #  #    #  #####
#    #    #  #    #  #       #    #  #    #  #   #
#    #####    ####   ######   ####   #####   #    #
#
#   Jacobian of geodetic  w.r.t. rectangular coordinates
#
################################################################################
#-Abstract
#
#   dgeodr computes the Jacobian of the transformation from
#   rectangular to geodetic coordinates.
#
#-I/O
#
#   Given:
#
#      x,
#      y,
#      z    the rectangular coordinates of the point at which the Jacobian of
#           the map from rectangular to geodetic coordinates is desired.
#
#           [1,n] = size(z); double = class(z)
#
#      re   equatorial radius of a reference spheroid. This spheroid is a
#           volume of revolution: its horizontal cross sections are circular. 
#           The shape of the spheroid is defined by an equatorial radius `re'
#           and a polar radius `rp'.
#
#           [1,1] = size(re); double = class(re)
#
#      f    the flattening coefficient
#
#           [1,1] = size(f); double = class(f)
#
#               f = (re-rp) / re
#
#             where rp is the polar radius of the spheroid. (More importantly
#             rp = re*(1-f).) The units of `rp' match those of `re'.
#
#   the call:
#
#      jacobi = dgeodr( x, y, z, re, f)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               rectangular and geodetic coordinates, evaluated at the input
#               coordinates. This matrix has the form
#
#               [3,3] = size(jacobi); double = class(jacobi)
#
#                   -                            -
#                  |  dlon/dx   dlon/dy  dlon/dz  |
#                  |                              |
#                  |  dlat/dx   dlat/dy  dlat/dz  |
#                  |                              |
#                  |  dalt/dx   dalt/dy  dalt/dz  |
#                   -                            -
#
#               evaluated at the input values of x, y, and z.
#
#-Particulars
#
#   When performing vector calculations with velocities it is
#   usually most convenient to work in rectangular coordinates.
#   However, once the vector manipulations have been performed,
#   it is often desirable to convert the rectangular representations
#   into geodetic coordinates to gain insights about phenomena
#   in this coordinate frame.
#
#   To transform rectangular velocities to derivatives of coordinates
#   in a geodetic system, one uses the Jacobian of the transformation
#   between the two systems.
#
#   Given a state in rectangular coordinates
#
#      ( x, y, z, dx, dy, dz )
#
#   the velocity in geodetic coordinates is given by the matrix
#   equation:
#                        t          |                     t
#      (dlon, dlat, dalt)   = jacobi|       * (dx, dy, dz)
#                                   |(x,y,z)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(x, y, z)
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dgeodr_c.
#
#   MICE.REQ
#
    function # dgeodr
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        dgeodr(
            x::Float64, # SpiceDouble
            y::Float64, # SpiceDouble
            z::Float64, # SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dgeodr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),x,y,z,re,f,jacobi)
        ccall((:dgeodr_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Float64,Float64,Ptr{Float64}),
            x,y,z,re,f,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #         ##     #####  #####   #####
#    #    #  #        #  #      #    #    #  #    #
#    #    #  #       #    #     #    #    #  #    #
#    #    #  #       ######     #    #    #  #####
#    #    #  #       #    #     #    #    #  #   #
#    #####   ######  #    #     #    #####   #    #
#
#   Jacobian of rectangular w.r.t. latitudinal coordinates
#
################################################################################
#-Abstract
#
#   dlatdr computes the Jacobian of the transformation from
#   rectangular to latitudinal coordinates.
#
#-I/O
#
#   Given:
#
#      x,
#      y,
#      z    the rectangular coordinates of the point at which the Jacobian of
#           the map from rectangular to latitudinal coordinates is desired.
#
#           [1,n] = size(z); double = class(z)
#
#   the call:
#
#      jacobi = dlatdr( x, y, z)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               rectangular and latitudinal coordinates. It has the form
#
#               If [1,1] = size(x) then [3,3]   = size(jacobi).
#               If [1,n] = size(x) then [3,3,n] = size(jacobi).
#               double = class(jacobi)
#
#                   -                             -
#                  |  dr/dx     dr/dy     dr/dz    |
#                  |                               |
#                  |  dlon/dx   dlon/dy   dlon/dz  |
#                  |                               |
#                  |  dlat/dx   dlat/dy   dlat/dz  |
#                   -                             -
#
#               evaluated at the input values of x, y, and z.
#
#-Particulars
#
#
#   When performing vector calculations with velocities it is
#   usually most convenient to work in rectangular coordinates.
#   However, once the vector manipulations have been performed
#   it is often desirable to convert the rectangular representations
#   into latitudinal coordinates to gain insights about phenomena
#   in this coordinate frame.
#
#   To transform rectangular velocities to derivatives of coordinates
#   in a latitudinal system, one uses the Jacobian of the
#   transformation between the two systems.
#
#   Given a state in rectangular coordinates
#
#      ( x, y, z, dx, dy, dz )
#
#   the corresponding latitudinal coordinate derivatives are given by
#   the matrix equation:
#
#                       t          |                     t
#      (dr, dlon, dlat)   = jacobi |        * (dx, dy, dz)
#                                  |(x,y,z)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(x, y, z)
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dlatdr_c.
#
#   MICE.REQ
#
    function # dlatdr
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        dlatdr(
            x::Float64, # SpiceDouble
            y::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dlatdr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),x,y,z,jacobi)
        ccall((:dlatdr_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            x,y,z,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####    ####   #####   #####   #####
#    #    #  #    #  #    #  #    #  #    #  #    #
#    #    #  #    #  #       #    #  #    #  #    #
#    #    #  #####   #  ###  #####   #    #  #####
#    #    #  #       #    #  #   #   #    #  #   #
#    #####   #        ####   #    #  #####   #    #
#
#   Jacobian of planetographic  w.r.t. rectangular coordinates
#
################################################################################
#-Abstract
#
#   dpgrdr computes the Jacobian matrix of the transformation
#   from rectangular to planetographic coordinates.
#
#-I/O
#
#   Given:
#
#      body   name of the body with which the planetographic coordinate system
#             is associated.
#
#             [1,m] = size(body); char = class(body)
#
#             `body' is used by this routine to look up from the
#             kernel pool the prime meridian rate coefficient giving
#             the body's spin sense.
#
#      x      [1,n] = size(x); double = class(x)
#
#      y      [1,n] = size(y); double = class(y)
#
#      z      [1,n] = size(z); double = class(z)
#
#             the rectangular coordinates of the point at which the Jacobian of
#             the map from rectangular to planetographic coordinates is
#             desired.
#
#      re     equatorial radius of a reference spheroid. This spheroid is a
#             volume of revolution: its horizontal cross sections are circular.
#             The shape of the spheroid is defined by an equatorial radius `re'
#             and a polar radius `rp'.
#
#             [1,1] = size(re); double = class(re)
#
#      f      the flattening coefficient
#
#             [1,1] = size(f); double = class(f)
#
#                f = (re-rp) / re
#
#             where rp is the polar radius of the spheroid. (More importantly
#             rp = re*(1-f).)
#
#   the call:
#
#      jacobi = dpgrdr( body, x, y, z, re, f)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion from
#               rectangular to planetographic coordinates. It has the form
#
#               If [1,1] = size(x) then [3,3]   = size(jacobi).
#               If [1,n] = size(x) then [3,3,n] = size(jacobi).
#               double = class(jacobi)
#
#                   -                               -
#                  |  dlon/dx    dlon/dy   dlon/dz   |
#                  |                                 |
#                  |  dlat/dx    dlat/dy   dlat/dz   |
#                  |                                 |
#                  |  dalt/dx    dalt/dy   dalt/dz   |
#                   -                               -
#
#               evaluated at the input values of 'x', 'y', and 'z'.
#
#-Particulars
#
#   When performing vector calculations with velocities it is usually
#   most convenient to work in rectangular coordinates. However, once
#   the vector manipulations have been performed, it is often
#   desirable to convert the rectangular representations into
#   planetographic coordinates to gain insights about phenomena in
#   this coordinate frame.
#
#   To transform rectangular velocities to derivatives of coordinates
#   in a planetographic system, one uses the Jacobian of the
#   transformation between the two systems.
#
#   Given a state in rectangular coordinates
#
#      ( x, y, z, dx, dy, dz )
#
#   the velocity in planetographic coordinates is given by the matrix
#   equation:
#                        t          |                     t
#      (dlon, dlat, dalt)   = jacobi|       * (dx, dy, dz)
#                                   |(x,y,z)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(x, y, z)
#
#
#   The planetographic definition of latitude is identical to the
#   planetodetic (also called "geodetic" in SPICE documentation)
#   definition. In the planetographic coordinate system, latitude is
#   defined using a reference spheroid.  The spheroid is
#   characterized by an equatorial radius and a polar radius. For a
#   point P on the spheroid, latitude is defined as the angle between
#   the X-Y plane and the outward surface normal at P.  For a point P
#   off the spheroid, latitude is defined as the latitude of the
#   nearest point to P on the spheroid.  Note if P is an interior
#   point, for example, if P is at the center of the spheroid, there
#   may not be a unique nearest point to P.
#
#   In the planetographic coordinate system, longitude is defined
#   using the spin sense of the body.  Longitude is positive to the
#   west if the spin is prograde and positive to the east if the spin
#   is retrograde.  The spin sense is given by the sign of the first
#   degree term of the time-dependent polynomial for the body's prime
#   meridian Euler angle "W":  the spin is retrograde if this term is
#   negative and prograde otherwise.  For the sun, planets, most
#   natural satellites, and selected asteroids, the polynomial
#   expression for W may be found in a SPICE PCK kernel.
#
#   The earth, moon, and sun are exceptions: planetographic longitude
#   is measured positive east for these bodies.
#
#   If you wish to override the default sense of positive longitude
#   for a particular body, you can do so by defining the kernel
#   variable
#
#      BODY<body ID>_PGR_POSITIVE_LON
#
#   where <body ID> represents the NAIF ID code of the body. This
#   variable may be assigned either of the values
#
#      'WEST'
#      'EAST'
#
#   For example, you can have this routine treat the longitude
#   of the earth as increasing to the west using the kernel
#   variable assignment
#
#      BODY399_PGR_POSITIVE_LON = 'WEST'
#
#   Normally such assignments are made by placing them in a text
#   kernel and loading that kernel via furnsh_c.
#
#   The definition of this kernel variable controls the behavior of
#   the CSPICE planetographic routines
#
#      cspice_pgrrec
#      cspice_recpgr
#      dpgrdr
#      cspice_drdpgr
#
#   It does not affect the other CSPICE coordinate conversion
#   routines.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dpgrdr_c.
#
#   MICE.REQ
#
    function # dpgrdr
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        dpgrdr(
            body::AbstractString, # Ptr{ConstSpiceChar}
            x::Float64, # SpiceDouble
            y::Float64, # SpiceDouble
            z::Float64, # SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dpgrdr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),body,x,y,z,re,f,jacobi)
        ccall((:dpgrdr_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Float64,Float64,Float64,Float64,Ptr{Float64}),
            body,x,y,z,re,f,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 11-NOV-2013, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####
#    #    #  #    #  #    #
#    #    #  #    #  #    #
#    #    #  #####   #####
#    #    #  #       #   #
#    #####   #       #    #
#
#   degrees per radian
#
################################################################################
#-Abstract
#
#   dpr returns the value of the constant 180/pi which represents 
#   the number of degrees of arc per radian.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      dpr = dpr
#
#   returns:
#
#      dpr   the number of degrees per radian: 180/pi.
#
#            [1,1] = size(dpr); double = class(dpr)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dpr_c.
#
#   MICE.REQ
#
    function # dpr
        dpr()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dpr_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:dpr_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> degrees_per_radians = dpr
#
#      degrees_per_radians =
#
#         57.2958
#
#      >> sprintf( 'Degrees per Radian: %10.7f', dpr )
#
#      ans =
#
#      Degrees per Radian: 57.2957795
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####    ####    #   #  #
#    #    #  #    #  #    #  #    #    # #   #
#    #    #  #    #  #    #  #          #    #
#    #    #  #####   #    #  #          #    #
#    #    #  #   #   #    #  #    #     #    #
#    #####   #    #  #####    ####      #    ######
#
#   Jacobian of rectangular w.r.t. cylindrical coordinates
#
################################################################################
#-Abstract
#
#   drdcyl computes the Jacobian of the transformation from
#   cylindrical to rectangular coordinates.
#
#-I/O
#
#   Given:
#
#      r     distance of the point of interest from z axis.
#
#            [1,n] = size(r); double = class(r)
#
#      lon   cylindrical angle (in radians) of the point of interest from the xz
#            plane. The angle increases in the counterclockwise sense about the
#            +z axis.
#
#            [1,n] = size(lon); double = class(lon)
#
#      z     height of the point above xy plane.
#
#            [1,n] = size(z); double = class(z)
#
#   the call:
#
#      jacobi = drdcyl( r, lon, z)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               cylindrical and rectangular coordinates. It has the form
#
#               If [1,1] = size(r) then [3,3]   = size(jacobi)
#               If [1,n] = size(r) then [3,3,n] = size(jacobi)
#                                        double = class(jacobi)
#
#                   -                               -
#                  |  dx/dr     dx/dlon     dx/dz    |
#                  |                                 |
#                  |  dy/dr     dy/dlon     dy/dz    |
#                  |                                 |
#                  |  dz/dr     dz/dlon     dz/dz    |
#                   -                               -
#
#               evaluated at the input values of r, lon and z.  Here x,y, and
#               z are given by the familiar formulae
#
#                  x = r*cos(lon)
#                  y = r*sin(lon)
#                  z = z
#
#-Particulars
#
#   It is often convenient to describe the motion of an object in
#   the cylindrical coordinate system.  However, when performing
#   vector computations its hard to beat rectangular coordinates.
#
#   To transform states given with respect to cylindrical coordinates
#   to states with respect to rectangular coordinates, one uses
#   the Jacobian of the transformation between the two systems.
#
#   Given a state in cylindrical coordinates
#
#      ( r, lon, z, dr, dlon, dz )
#
#   the velocity in rectangular coordinates is given by the matrix
#   equation:
#                  t          |                          t
#      (dx, dy, dz)   = jacobi|          * (dr, dlon, dz)
#                             |(r,lon,z)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(r,lon,z)
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine drdcyl_c.
#
#   MICE.REQ
#
    function # drdcyl
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        drdcyl(
            r::Float64, # SpiceDouble
            lon::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:drdcyl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),r,lon,z,jacobi)
        ccall((:drdcyl_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            r,lon,z,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 09-NOV-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####    ####   ######   ####
#    #    #  #    #  #    #  #    #  #       #    #
#    #    #  #    #  #    #  #       #####   #    #
#    #    #  #####   #    #  #  ###  #       #    #
#    #    #  #   #   #    #  #    #  #       #    #
#    #####   #    #  #####    ####   ######   ####
#
#   Jacobian of rectangular w.r.t. geodetic coordinates
#
################################################################################
#-Abstract
#
#   drdgeo computes the Jacobian of the transformation from
#   geodetic to rectangular coordinates.
#
#-I/O
#
#   Given:
#
#      lon   geodetic longitude of point (radians).
#
#            [1,n] = size(lon); double = class(lon)
#
#      lat   geodetic latitude of point (radians).
#
#            [1,n] = size(lat); double = class(lat)
#
#      alt   Altitude of point above the reference spheroid. Units of `alt'
#            must match those of `re'.
#
#            [1,n] = size(alt); double = class(alt)
#
#      re    equatorial radius of a reference spheroid. This spheroid is a
#            volume of revolution:  its horizontal cross sections are circular.
#             The shape of the spheroid is defined by an equatorial radius `re'
#            and a polar radius `rp'.  Units of 're' must match those of 'alt'.
#
#            [1,1] = size(re); double = class(re)
#
#      f     the flattening coefficient
#
#            [1,1] = size(f); double = class(f)
#
#               f = (re-rp) / re
#
#             where rp is the polar radius of the spheroid. (More importantly
#             rp = re*(1-f).) The units of `rp' match those of `re'.
#
#   the call:
#
#      jacobi = drdgeo( lon, lat, alt, re, f)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               geodetic and rectangular coordinates. It has the form
#
#               If [1,1] = size(lon) then [3,3]   = size(jacobi)
#               If [1,n] = size(lon) then [3,3,n] = size(jacobi)
#                                          double = class(jacobi)
#
#                  -                             -
#                 |  dx/dlon   dx/dlat  dx/dalt   |
#                 |                               |
#                 |  dy/dlon   dy/dlat  dy/dalt   |
#                 |                               |
#                 |  dz/dlon   dz/dlat  dz/dalt   |
#                  -                             -
#
#               evaluated at the input values of lon, lat and alt.
#
#               The formulae for computing x, y, and z from
#               geodetic coordinates are given below.
#
#                  x = [alt +        re/g(lat,f)]*cos(lon)*cos(lat)
#
#
#                  y = [alt +        re/g(lat,f)]*sin(lon)*cos(lat)
#
#                                    2
#                  z = [alt + re*(1-f) /g(lat,f)]*         sin(lat)
#
#               where
#
#                   re is the polar radius of the reference spheroid.
#
#                   f  is the flattening factor (the polar radius is
#                       obtained by multiplying the equatorial radius by 1-f).
#
#                   g( lat, f ) is given by
#
#                                2             2     2
#                      sqrt ( cos (lat) + (1-f) * sin (lat) )
#
#-Particulars
#
#   It is often convenient to describe the motion of an object in
#   the geodetic coordinate system.  However, when performing
#   vector computations its hard to beat rectangular coordinates.
#
#   To transform states given with respect to geodetic coordinates
#   to states with respect to rectangular coordinates, one makes use
#   of the Jacobian of the transformation between the two systems.
#
#   Given a state in geodetic coordinates
#
#        ( lon, lat, alt, dlon, dlat, dalt )
#
#   the velocity in rectangular coordinates is given by the matrix
#   equation:
#
#                  t          |                                 t
#      (dx, dy, dz)   = jacobi|             * (dlon, dlat, dalt)
#                             |(lon,lat,alt)
#
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(lon,lat,alt)
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine drdgeo_c.
#
#   MICE.REQ
#
    function # drdgeo
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        drdgeo(
            lon::Float64, # SpiceDouble
            lat::Float64, # SpiceDouble
            alt::Float64, # SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:drdgeo_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),lon,lat,alt,re,f,jacobi)
        ccall((:drdgeo_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Float64,Float64,Ptr{Float64}),
            lon,lat,alt,re,f,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####   #         ##     #####
#    #    #  #    #  #    #  #        #  #      #
#    #    #  #    #  #    #  #       #    #     #
#    #    #  #####   #    #  #       ######     #
#    #    #  #   #   #    #  #       #    #     #
#    #####   #    #  #####   ######  #    #     #
#
#   Jacobian of rectangular w.r.t. latitudinal coordinates
#
################################################################################
#-Abstract
#
#   drdlat computes the Jacobian of the transformation from latitudinal
#   to rectangular coordinates.
#
#-I/O
#
#   Given:
#
#      radius   the distance of a point from the origin.
#
#               [1,n] = size(radius); double = class(radius)
#
#      lon      the angle of the point measured from the XZ plane in radians.
#               The angle increases in the counterclockwise sense about the 
#               +Z axis.
#
#               [1,n] = size(lon); double = class(lon)
#
#      lat      the angle of the point measured from the XY plane in radians.
#               The angle increases in the direction of the +Z axis.
#
#               [1,n] = size(lat); double = class(lat)
#
#   the call:
#
#      jacobi = drdlat( r, lon, lat)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               latitudinal and rectangular coordinates, evaluated at the input
#               coordinates. This matrix has the form
#
#               If [1,1] = size(radius) then [3,3]   = size(jacobi)
#               If [1,n] = size(radius) then [3,3,n] = size(jacobi)
#                                             double = class(jacobi)
#
#                   -                                -
#                  |  dx/dr     dx/dlon     dx/dlat   |
#                  |                                  |
#                  |  dy/dr     dy/dlon     dy/dlat   |
#                  |                                  |
#                  |  dz/dr     dz/dlon     dz/dlat   |
#                   -                                -
#
#               evaluated at the input values of r, lon and lat.
#               Here x, y, and z are given by the familiar formulae
#
#                  x = r * cos(lon) * cos(lat)
#                  y = r * sin(lon) * cos(lat)
#                  z = r *            sin(lat).
#
#-Particulars
#
#   It is often convenient to describe the motion of an object
#   in latitudinal coordinates. It is also convenient to manipulate
#   vectors associated with the object in rectangular coordinates.
#
#   The transformation of a latitudinal state into an equivalent
#   rectangular state makes use of the Jacobian of the
#   transformation between the two systems.
#
#   Given a state in latitudinal coordinates,
#
#        ( r, lon, lat, dr, dlon, dlat )
#
#   the velocity in rectangular coordinates is given by the matrix
#   equation
#                  t          |                               t
#      (dx, dy, dz)   = jacobi|             * (dr, dlon, dlat)
#                             |(r,lon,lat)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(r,lon,lat)
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine drdlat_c.
#
#   MICE.REQ
#
    function # drdlat
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        drdlat(
            r::Float64, # SpiceDouble
            lon::Float64, # SpiceDouble
            lat::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:drdlat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),r,lon,lat,jacobi)
        ccall((:drdlat_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            r,lon,lat,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####   #####    ####   #####
#    #    #  #    #  #    #  #    #  #    #  #    #
#    #    #  #    #  #    #  #    #  #       #    #
#    #    #  #####   #    #  #####   #  ###  #####
#    #    #  #   #   #    #  #       #    #  #   #
#    #####   #    #  #####   #        ####   #    #
#
#   Jacobian of rectangular w.r.t. planetographic coordinates
#
################################################################################
#-Abstract
#
#   drdpgr computes the Jacobian matrix of the transformation
#   from planetographic to rectangular coordinates.
#
#-I/O
#
#   Given:
#
#      body   name of the body with which the planetographic coordinate system
#             is associated.
#
#             [1,m] = size(body); char = class(body)
#
#             `body' is used by this routine to look up from the
#             kernel pool the prime meridian rate coefficient giving
#             the body's spin sense.
#
#      lon    planetographic longitude of the input point. This is the angle
#             between the prime meridian and the meridian containing the input
#             point. For bodies having prograde (aka direct) rotation, the
#             direction of increasing longitude is positive west:  from the +X
#             axis of the rectangular coordinate system toward the -Y axis. For
#             bodies having retrograde rotation, the direction of increasing
#             longitude is positive east: from the +X axis toward the +Y axis.
#
#             [1,n] = size(lon); double = class(lon)
#
#             The earth, moon, and sun are exceptions:
#             planetographic longitude is measured positive east for
#             these bodies.
#
#             The default interpretation of longitude by this
#             and the other planetographic coordinate conversion
#             routines can be overridden; see the discussion in
#             Particulars below for details.
#
#             Longitude is measured in radians. On input, the range
#             of longitude is unrestricted.
#
#      lat    planetographic latitude of the input point.  For a point P on the
#             reference spheroid, this is the angle  between the XY plane and
#             the outward normal vector at P. For a point P not on the
#             reference spheroid, the planetographic latitude is that of the
#             closest point to P on the spheroid.
#
#             [1,n] = size(lat); double = class(lat)
#
#             Latitude is measured in radians.  On input, the range of
#             latitude is unrestricted.
#
#      alt    Altitude of point above the reference spheroid. Units of `alt'
#             must match those of `re'.
#
#             [1,n] = size(alt); double = class(alt)
#
#      re     equatorial radius of a reference spheroid. This spheroid is a
#             volume of revolution: its horizontal cross sections are circular.
#              The shape of the spheroid is defined by an equatorial radius
#             `re' and a polar radius `rp'. Units of `re' must match those of
#             `alt'.
#
#             [1,1] = size(re); double = class(re)
#
#      f      the flattening coefficient
#
#             [1,1] = size(f); double = class(f)
#
#                f = (re-rp) / re
#
#             where rp is the polar radius of the spheroid. (More importantly
#             rp = re*(1-f).) The units of `rp' match those of `re'.
#
#   the call:
#
#      jacobi = drdpgr( body, lon, lat, alt, re, f)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion from
#               planetographic to rectangular coordinates evaluated at the
#               input coordinates. This matrix has the form
#
#               If [1,1] = size(lon) then [3,3]   = size(jacobi)
#               If [1,n] = size(lon) then [3,3,n] = size(jacobi)
#                                          double = class(jacobi)
#
#                   -                              -
#                  |  dx/dlon   dx/dlat   dx/dalt   |
#                  |                                |
#                  |  dy/dlon   dy/dlat   dy/dalt   |
#                  |                                |
#                  |  dz/dlon   dz/dlat   dz/dalt   |
#                   -                              -
#
#               evaluated at the input values of 'lon', 'lat' and 'alt'.
#
#-Particulars
#
#   It is often convenient to describe the motion of an object in the
#   planetographic coordinate system.  However, when performing
#   vector computations it's hard to beat rectangular coordinates.
#
#   To transform states given with respect to planetographic
#   coordinates to states with respect to rectangular coordinates,
#   one makes use of the Jacobian of the transformation between the
#   two systems.
#
#   Given a state in planetographic coordinates
#
#      ( lon, lat, alt, dlon, dlat, dalt )
#
#   the velocity in rectangular coordinates is given by the matrix
#   equation:
#
#                  t          |                                  t
#      (dx, dy, dz)   = jacobi|              * (dlon, dlat, dalt)
#                             |(lon,lat,alt)
#
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(lon,lat,alt)
#
#
#   In the planetographic coordinate system, longitude is defined
#   using the spin sense of the body.  Longitude is positive to the
#   west if the spin is prograde and positive to the east if the spin
#   is retrograde.  The spin sense is given by the sign of the first
#   degree term of the time-dependent polynomial for the body's prime
#   meridian Euler angle "W":  the spin is retrograde if this term is
#   negative and prograde otherwise.  For the sun, planets, most
#   natural satellites, and selected asteroids, the polynomial
#   expression for W may be found in a SPICE PCK kernel.
#
#   The earth, moon, and sun are exceptions: planetographic longitude
#   is measured positive east for these bodies.
#
#   If you wish to override the default sense of positive longitude
#   for a particular body, you can do so by defining the kernel
#   variable
#
#      BODY<body ID>_PGR_POSITIVE_LON
#
#   where <body ID> represents the NAIF ID code of the body. This
#   variable may be assigned either of the values
#
#      'WEST'
#      'EAST'
#
#   For example, you can have this routine treat the longitude
#   of the earth as increasing to the west using the kernel
#   variable assignment
#
#      BODY399_PGR_POSITIVE_LON = 'WEST'
#
#   Normally such assignments are made by placing them in a text
#   kernel and loading that kernel via furnsh_c.
#
#   The definition of this kernel variable controls the behavior of
#   the CSPICE planetographic routines
#
#      cspice_pgrrec
#      cspice_recpgr
#      cspice_dpgrdr
#      drdpgr
#
#   It does not affect the other SPICE coordinate conversion
#   routines.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine drdpgr_c.
#
#   MICE.REQ
#
    function # drdpgr
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        drdpgr(
            body::AbstractString, # Ptr{ConstSpiceChar}
            lon::Float64, # SpiceDouble
            lat::Float64, # SpiceDouble
            alt::Float64, # SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:drdpgr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),body,lon,lat,alt,re,f,jacobi)
        ccall((:drdpgr_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Float64,Float64,Float64,Float64,Ptr{Float64}),
            body,lon,lat,alt,re,f,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 09-NOV-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####    ####   #####   #    #
#    #    #  #    #  #    #  #       #    #  #    #
#    #    #  #    #  #    #   ####   #    #  ######
#    #    #  #####   #    #       #  #####   #    #
#    #    #  #   #   #    #  #    #  #       #    #
#    #####   #    #  #####    ####   #       #    #
#
#   Jacobian of rectangular w.r.t. spherical coordinates
#
################################################################################
#-Abstract
#
#   drdsph computes the Jacobian of the transformation from
#   spherical to rectangular coordinates.
#
#-I/O
#
#   Given:
#
#      r       the distance of a point from the origin.
#
#              [1,n] = size(r); double = class(r)
#
#      colat   the angle between the point and the positive z-axis, in radians.
#
#              [1,n] = size(colat); double = class(colat)
#
#      lon     the angle of the point measured from the xz plane in radians.
#              The angle increases in the counterclockwise sense about
#              the +z axis.
#
#              [1,n] = size(lon); double = class(lon)
#
#   the call:
#
#      jacobi = drdsph( r, colat, lon)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion between
#               spherical and rectangular coordinates, evaluated at the input
#               coordinates. This matrix has the form
#
#               If [1,1] = size(r) then [3,3]   = size(jacobi)
#               If [1,n] = size(r) then [3,3,n] = size(jacobi)
#                                        double = class(jacobi)
#
#                   -                                 -
#                  |  dx/dr     dx/dcolat     dx/dlon  |
#                  |                                   |
#                  |  dy/dr     dy/dcolat     dy/dlon  |
#                  |                                   |
#                  |  dz/dr     dz/dcolat     dz/dlon  |
#                   -                                 -
#
#               evaluated at the input values of r, lon and lat.
#               Here x, y, and z are given by the familiar formulae
#
#                  x = r*cos(lon)*sin(colat)
#                  y = r*sin(lon)*sin(colat)
#                  z = r*cos(colat)
#
#-Particulars
#
#   It is often convenient to describe the motion of an object in
#   the spherical coordinate system.  However, when performing
#   vector computations its hard to beat rectangular coordinates.
#
#   To transform states given with respect to spherical coordinates
#   to states with respect to rectangular coordinates, one uses
#   the Jacobian of the transformation between the two systems.
#
#   Given a state in spherical coordinates
#
#      ( r, colat, lon, dr, dcolat, dlon )
#
#   the velocity in rectangular coordinates is given by the matrix
#   equation:
#                  t          |                                   t
#      (dx, dy, dz)   = jacobi|              * (dr, dcolat, dlon )
#                             |(r,colat,lon)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(r,colat,lon)
#
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine drdsph_c.
#
#   MICE.REQ
#
    function # drdsph
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        drdsph(
            r::Float64, # SpiceDouble
            colat::Float64, # SpiceDouble
            lon::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:drdsph_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),r,colat,lon,jacobi)
        ccall((:drdsph_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            r,colat,lon,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 09-NOV-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####   #####   #    #  #####   #####
#    #    #  #       #    #  #    #  #    #  #    #
#    #    #   ####   #    #  ######  #    #  #    #
#    #    #       #  #####   #    #  #    #  #####
#    #    #  #    #  #       #    #  #    #  #   #
#    #####    ####   #       #    #  #####   #    #
#
#   Jacobian of spherical w.r.t. rectangular coordinates
#
################################################################################
#-Abstract
#
#   dsphdr computes the Jacobian of the transformation from
#   rectangular to spherical coordinates.
#
#-I/O
#
#   Given:
#
#      x   [1,n] = size(x); double = class(x)
#
#      y   [1,n] = size(y); double = class(y)
#
#      z   [1,n] = size(z); double = class(z)
#
#          the rectangular coordinates of the point at which the Jacobian of
#          the map from rectangular to spherical coordinates is desired.
#
#   the call:
#
#      jacobi = dsphdr( x, y, z)
#
#   returns:
#
#      jacobi   the matrix of partial derivatives of the conversion
#               between rectangular and spherical coordinates.  It
#               has the form
#
#               If [1,1] = size(x) then [3,3]   = size(jacobi)
#               If [1,n] = size(x) then [3,3,n] = size(jacobi)
#                                        double = class(jacobi)
#
#                  .-                                  -.
#                  |  dr/dx       dr/dy      dr/dz      |
#                  |  dcolat/dx   dcolat/dy  dcolat/dz  |
#                  |  dlon/dx     dlon/dy    dlon/dz    |
#                  `-                                  -'
#
#               evaluated at the input values of x, y, and z.
#
#-Particulars
#
#   When performing vector calculations with velocities it is
#   usually most convenient to work in rectangular coordinates.
#   However, once the vector manipulations have been performed
#   it is often desirable to convert the rectangular representations
#   into spherical coordinates to gain insights about phenomena
#   in this coordinate frame.
#
#   To transform rectangular velocities to derivatives of coordinates
#   in a spherical system, one uses the Jacobian of the transformation
#   between the two systems.
#
#   Given a state in rectangular coordinates
#
#        ( x, y, z, dx, dy, dz )
#
#   the corresponding spherical coordinate derivatives are given by
#   the matrix equation:
#
#                        t          |                    t
#      (dr, dcolat, dlon)   = jacobi|      * (dx, dy, dz)
#                                   |(x,y,z)
#
#   This routine computes the matrix
#
#            |
#      jacobi|
#            |(x, y, z)
#
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dsphdr_c.
#
#   MICE.REQ
#
    function # dsphdr
#       (jacobi::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        dsphdr(
            x::Float64, # SpiceDouble
            y::Float64, # SpiceDouble
            z::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        jacobi = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        jacobi_ptr = pointer(jacobi)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dsphdr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),x,y,z,jacobi)
        ccall((:dsphdr_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            x,y,z,jacobi_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return jacobi'
    end
#-Examples
#
#   None.
#
#-Version
#
#   -Mice Version 1.0.0, 12-NOV-2013, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    #####  #####    ####    ####   #
#    #    #     #    #    #  #    #  #    #  #
#    #    #     #    #    #  #    #  #    #  #
#    #    #     #    #####   #    #  #    #  #
#    #    #     #    #       #    #  #    #  #
#    #####      #    #        ####    ####   ######
#
#   return summary information about a kernel pool variable
#
################################################################################
#-Abstract
#
#   dtpool returns descriptive data about a kernel pool variable
#
#-I/O
#
#   Given:
#
#     name   name(s) of variables whose values are to be returned
#
#            [n,m] = size(name); char = class(name)
#
#   the call:
#
#      [found, n, type] = dtpool(name)
#
#   returns:
#
#      found   flag(s) returning as true if the variable 'name' exists in the
#              pool; false if not
#
#              [1,n] = size(found); logical = class(found)
#
#      n       the number of values associated with 'name'. If 'name' does not 
#              exist in the pool, 'n' returns with the value 0.
#
#              [1,n] = size(n); int32 = class(n)
#
#      type    indicating the variable type associated with 'name'
#
#              [n,m] = size(type); char = class(type)
#
#                  C if the data is character data
#                  N if the data is numeric
#                  X if there is no variable name in the pool
#
#              'found', 'n', and 'type' return with the same vectorization
#               measure (N) as 'name'.
#
#-Particulars
#
#   A sister version of this routine exists named mice_dtpool that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dtpool_c.
#
#   MICE.REQ
#
    function # dtpool
#       (found::Int32,  # Ptr{SpiceBoolean}
#        n::Int32,  # Ptr{SpiceInt}
#        _type::Array{UInt8,1}(1)) =   # Array_1_SpiceChar
        dtpool(
            name::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        n = Array{Int32}(1);  # Ptr{SpiceInt}
        n_ptr = pointer(n)
        _type = Array{UInt8,1}(1);  # Array_1_SpiceChar
        _type_ptr = pointer(_type)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dtpool_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceBoolean},Ptr{SpiceInt},Array_1_SpiceChar),name,found,n,_type)
        ccall((:dtpool_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32},Ptr{Int32},Ptr{Float64}),
            name,found_ptr,n_ptr,_type_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return convert( Bool, found[1] ), n[1], _type
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'de421.bsp',
#                                'pck00009.tpc',
#                                'naif0009.tls'  )
#
#         \begintext
#
#   Example:
#
#      %
#      % Load a leapsecond kernel.
#      %
#      cspice_furnsh('standard.tm' )
#
#      %
#      % Check for the variables defined in the leapseconds kernel
#      % and a name probably (hopefully) not in the kernel pool.
#      %
#      lmpoolNames  = strvcat(              ...
#                    'DELTET/DELTA_T_A',    ...
#                    'DELTET/K',            ...
#                    'DELTET/EB',           ...
#                    'DELTET/M',            ...
#                    'ECHO419',             ...
#                    'DELTET/DELTA_AT',     ...
#                    'EVERLASTING_GOBSTOPPER' );
#
#      [found, n, dtype] = dtpool( lmpoolNames );
#
#      for i = 1:size(lmpoolNames,1)
#
#         name = lmpoolNames(i,:);
#
#         if (found(i))
#            fprintf( 'Variable name : %s\n', name       )
#            fprintf( 'Variable size : %d\n', n(i)       )
#            fprintf( 'Variable type : %s\n\n', dtype(i) )
#         else
#            fprintf( 'Unable to find variable name : %s\n\n', name )
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Variable name : DELTET/DELTA_T_A
#      Variable size : 1
#      Variable type : N
#
#      Variable name : DELTET/K
#      Variable size : 1
#      variable type : N
#
#      Variable name : DELTET/EB
#      Variable size : 1
#      Variable type : N
#
#      Variable name : DELTET/M
#      Variable size : 2
#      Variable type : N
#
#      Unable to find variable name : ECHO419
#
#      Variable name : DELTET/DELTA_AT
#      Variable size : 48
#      Variable type : N
#
#      Unable to find variable name : EVERLASTING_GOBSTOPPER
#
#-Version
#
#   -Mice Version 1.0.2, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#      Edits to Example section, proper description of "standard.tm"
#      meta kernel.
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 07-MAR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #   ####   #####    ####    ####
#    #    #  #    #  #    #  #    #  #       #
#    #    #  #    #  #       #    #   ####    ####
#    #    #  #    #  #       #####        #       #
#    #    #  #    #  #    #  #   #   #    #  #    #
#    #####    ####    ####   #    #   ####    ####
#
#   compute a unit cross product and its derivative
#
################################################################################
#-Abstract
#
#   ducrss calculates the unit vector parallel to the cross product
#   of the position components of two state vectors and the time derivative
#   of this unit vector.
#
#-I/O
#
#   Given:
#
#      s1   a SPICE state(s);
#
#              s1 = (r1, dr1 ).
#                         --
#                         dt
#
#           [6,n] = size(s1); double = class(s1)
#
#      s2   a second SPICE state(s);
#
#              s2 = (r2, dr2 ).
#                        --
#                        dt
#
#           [6,n] = size(s2); double = class(s2)
#
#      An implicit assumption exists that 's1' and 's2' are specified
#      in the same reference frame. If this is not the case, the numerical
#      result has no meaning.
#
#   the call:
#
#      sout = ducrss ( s1, s2 )
#
#   returns:
#
#      sout   the unit vector(s) parallel to the cross product(s) of the
#               position components of 's1' and 's2' and the derivative
#               of the unit vector(s).
#
#               If the cross product of the position components is the zero
#               vector, then the position component of the output will be the
#               zero vector. The velocity component of the output will simply
#               be the derivative of the cross product of the position
#               components of 's1' and 's2'.
#
#               'sout' returns with the same measure of vectorization (N)
#               as 's1' and 's2'
#
#               Programmatically:
#
#                  crss   = cspice_dvcrss( s1, s2 )
#                  sout = cspice_dvhat( crss )
#
#               [6,n] = size(sout); double = class(sout)
#
#-Particulars
#
#   The frame transformation described in the Example may also be implemented
#   using a dynamic frames kernel.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ducrss_c.
#
#   FRAMES.REQ
#   MICE.REQ
#
    function # ducrss
#       (sout::Array{Float64,1}(6)) =   # Array_6_SpiceDouble
        ducrss(
            s1::Array{Float64,1}, # Array_6_ConstSpiceDouble
            s2::Array{Float64,1}) # Array_6_ConstSpiceDouble
        
#       enforce input array sizes
        if length(s1) != 6
            error("Incorrect size for parameter 1")
        end
        if length(s2) != 6
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        sout = Array{Float64,1}(6);  # Array_6_SpiceDouble
        sout_ptr = pointer(sout)
        
#       make transposed copies of all input arrays and their pointers
        s1_t = s1'
        s1_ptr = pointer(s1_t)
        s2_t = s2'
        s2_ptr = pointer(s2_t)
        
#       ccall((:ducrss_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,Array_6_ConstSpiceDouble,Array_6_SpiceDouble),s1,s2,sout)
        ccall((:ducrss_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            s1_ptr,s2_ptr,sout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return sout
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      One can construct non-inertial coordinate frames from apparent
#      positions of objects or defined directions.  However, if one wants
#      to convert states in this non-inertial frame to states in an inertial
#      reference frame, the derivatives of the axes of the non-inertial
#      frame are required.
#
#      Define a reference frame with the apparent direction of the sun
#      as seen from earth as the primary axis (x). Use the earth pole vector
#      to define with the primary axis a primary plane of the frame.
#
#
#      %
#      % Load SPK, PCK, and LSK kernels, use a meta kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define the earth body-fixed pole vector (z). The pole
#      % has no velocity in the earth fixed frame "IAU_EARTH."
#      %
#      z_earth = [ 0, 0, 1, 0, 0, 0 ]';
#
#      %
#      % Calculate the state transformation between IAU_EARTH and J2000
#      % at an arbitrary epoch.
#      %
#      utc     = 'Jan 1, 2009';
#      et      = cspice_str2et( utc );
#      trans   = cspice_sxform( 'IAU_EARTH', 'J2000', et );
#
#      %
#      % Transform the earth pole vector from the IAU_EARTH frame to J2000.
#      %
#      z_j2000 = trans * z_earth;
#
#      %
#      % Calculate the apparent state of the sun from earth at the epoch
#      % 'et' in the J2000 frame.
#      %
#      target   = 'Sun';
#      observer = 'Earth';
#
#      [state, ltime] = cspice_spkezr( target, et, 'J2000', 'LT+S', observer);
#
#      %
#      % Define the z axis of the new frame as the cross product between
#      % the apparent direction of the sun and the earth pole. 'z_new' cross
#      % 'x_new' defines the y axis of the derived frame.
#      %
#      x_new = cspice_dvhat( state )
#      z_new = ducrss( state, z_j2000 )
#      y_new = ducrss( z_new, state   )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      x_new =
#
#           1.834466375917397e-01
#          -9.019196633169827e-01
#          -3.910092736476536e-01
#           2.024497675152527e-07
#           3.466010606102513e-08
#           1.503314202237741e-08
#
#
#      y_new =
#
#           7.884654015638601e-02
#          -3.829780802895584e-01
#           9.203863390571874e-01
#           8.238367850215384e-08
#           3.230941292533659e-08
#           6.386588623423665e-09
#
#
#      z_new =
#
#          -9.798625180410016e-01
#          -1.996715075815909e-01
#           8.572038510978363e-04
#           4.453114222022677e-08
#          -2.185310696303958e-07
#          -3.614002123088436e-11
#
#      These vectors define the transformation between the new frame and J2000.
#
#              -            -
#             |       :      |
#             |   R   :  0   |
#         M = | ......:......|
#             |       :      |
#             | dRdt  :  R   |
#             |       :      |
#              -            -
#
#      with
#
#         R    = [ x_new(1:3): y_new(1:3); z_new(1:3) ]
#
#         dRdt = [ x_new(4:6): y_new(4:6); z_new(4:6) ]
#
#-Version
#
#   -Mice Version 1.0.0, 09-NOV-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #   ####   #####    ####    ####
#    #    #  #    #  #    #  #    #  #       #
#    #    #  #    #  #       #    #   ####    ####
#    #    #  #    #  #       #####        #       #
#    #    #   #  #   #    #  #   #   #    #  #    #
#    #####     ##     ####   #    #   ####    ####
#
#   compute the derivative of a cross product
#
################################################################################
#-Abstract
#
#   dvcrss calculates the cross product of the position components of
#   two state vectors and the time derivative of this cross product.
#
#-I/O
#
#   Given:
#
#      s1   a SPICE state(s);
#
#              s1 = (r1, dr1 ).
#                         --
#                         dt
#
#           [6,n] = size(s1); double = class(s1)
#
#      s2   a second SPICE state(s);
#
#              s2 = (r2, dr2 ).
#                        --
#                        dt
#
#           [6,n] = size(s2); double = class(s2)
#
#      An implicit assumption exists that 's1' and 's2' are specified
#      in the same reference frame. If this is not the case, the numerical
#      result has no meaning.
#
#   the call:
#
#      sout = dvcrss ( s1, s2 )
#
#   returns:
#
#      sout   the cross product(s) associated with the position components
#               of 's1' and 's2' and the derivative of the cross product(s)
#               with respect to time.
#
#               'sout' returns with the same measure of vectorization (N)
#               as 's1' and 's2'
#
#               [6,n] = size(sout); double = class(sout)
#
#-Particulars
#
#   In this discussion, the notation
#
#      V1 x V2
#
#   indicates the cross product of vectors V1 and V2.
#
#   With s1 = (r1,v1) and s2 = (r2,v2) then
#
#                           d
#      sout = [ r1 x r2 , -- (r1 x r2) ]
#                           dt
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dvcrss_c.
#
#   MICE.REQ
#
    function # dvcrss
#       (sout::Array{Float64,1}(6)) =   # Array_6_SpiceDouble
        dvcrss(
            s1::Array{Float64,1}, # Array_6_ConstSpiceDouble
            s2::Array{Float64,1}) # Array_6_ConstSpiceDouble
        
#       enforce input array sizes
        if length(s1) != 6
            error("Incorrect size for parameter 1")
        end
        if length(s2) != 6
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        sout = Array{Float64,1}(6);  # Array_6_SpiceDouble
        sout_ptr = pointer(sout)
        
#       make transposed copies of all input arrays and their pointers
        s1_t = s1'
        s1_ptr = pointer(s1_t)
        s2_t = s2'
        s2_ptr = pointer(s2_t)
        
#       ccall((:dvcrss_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,Array_6_ConstSpiceDouble,Array_6_SpiceDouble),s1,s2,sout)
        ccall((:dvcrss_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            s1_ptr,s2_ptr,sout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return sout
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      One can construct non-inertial coordinate frames from apparent
#      positions of objects or defined directions.  However, if one wants
#      to convert states in this non-inertial frame to states in an inertial
#      reference frame, the derivatives of the axes of the non-inertial
#      frame are required.
#
#      Define a reference frame with the apparent direction of the sun
#      as seen from earth as the primary axis (x). Use the earth pole vector
#      to define with the primary axis a primary plane of the frame.
#
#      %
#      % Load SPK, PCK, and LSK kernels, use a meta kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define the earth body-fixed pole vector (z). The pole
#      % has no velocity in the earth fixed frame "IAU_EARTH."
#      %
#      z_earth = [ 0, 0, 1, 0, 0, 0 ]';
#
#      %
#      % Calculate the state transformation between IAU_EARTH and J2000
#      % at an arbitrary epoch.
#      %
#      utc     = 'Jan 1, 2009';
#      et      = cspice_str2et( utc );
#      trans   = cspice_sxform( 'IAU_EARTH', 'J2000', et );
#
#      %
#      % Transform the earth pole vector from the IAU_EARTH frame to J2000.
#      %
#      z_j2000 = trans * z_earth;
#
#      %
#      % Calculate the apparent state of the sun from earth at the epoch
#      % 'et' in the J2000 frame.
#      %
#      target   = 'Sun';
#      observer = 'Earth';
#
#      [state, ltime] = cspice_spkezr( target, et, 'J2000', 'LT+S', observer );
#
#      %
#      % Define the z axis of the new frame as the cross product between
#      % the apparent direction of the sun and the earth pole. 'z_new' cross
#      % 'x_new' defines the y axis of the derived frame.
#      %
#      x_new = cspice_dvhat( state )
#
#      %
#      % Calculate the z direction in the new reference frame then
#      % calculate the normal of the vector and derivative of
#      % the normal to determine the z unit vector.
#      %
#      z_new = dvcrss( state, z_j2000 );
#      z_new = cspice_dvhat( z_new )
#
#      %
#      % As for z_new, calculate the y direction in the new reference
#      % frame then calculate the normal of the vector and derivative
#      % of the normal to determine they unit vector.
#      %
#      y_new = dvcrss( z_new, state );
#      y_new = cspice_dvhat( y_new )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      x_new =
#
#           1.834466375917397e-01
#          -9.019196633169827e-01
#          -3.910092736476536e-01
#           2.024497675152527e-07
#           3.466010606102513e-08
#           1.503314202237741e-08
#
#
#      z_new =
#
#          -9.798625180410016e-01
#          -1.996715075815909e-01
#           8.572038510978363e-04
#           4.453114222022677e-08
#          -2.185310696303958e-07
#          -3.614002123088436e-11
#
#
#      y_new =
#
#           7.884654015638601e-02
#          -3.829780802895584e-01
#           9.203863390571874e-01
#           8.238367850215384e-08
#           3.230941292533659e-08
#           6.386588623423665e-09
#
#      These vectors define the transformation between the new frame and J2000.
#
#              -            -
#             |       :      |
#             |   R   :  0   |
#         M = | ......:......|
#             |       :      |
#             | dRdt  :  R   |
#             |       :      |
#              -            -
#
#      with
#
#         R    = [ x_new(1:3): y_new(1:3); z_new(1:3) ]
#
#         dRdt = [ x_new(4:6): y_new(4:6); z_new(4:6) ]
#
#-Version
#
#   -Mice Version 1.0.0, 09-NOV-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #  #####    ####    #####
#    #    #  #    #  #    #  #    #     #
#    #    #  #    #  #    #  #    #     #
#    #    #  #    #  #    #  #    #     #
#    #    #   #  #   #    #  #    #     #
#    #####     ##    #####    ####      #
#
#   time derivative of a dot product
#
################################################################################
#-Abstract
#
#   dvdot returns the time derivative of the dot product of
#   two position vectors.
#
#-I/O
#
#   Given:
#
#      s1   a SPICE state(s);
#
#              s1 = (r1, dr1 ).
#                         --
#                         dt
#
#           [6,n] = size(s1); double = class(s1)
#
#      s2   a second SPICE state(s);
#
#              s2 = (r2, dr2 ).
#                        --
#                        dt
#
#           [6,n] = size(s2); double = class(s2)
#
#      An implicit assumption exists that 's1' and 's2' are specified
#      in the same reference frame. If this is not the case, the numerical
#      result has no meaning.
#
#   the call:
#
#      dvdot = dvdot( s1, s2 )
#
#   returns:
#
#      dvdot   the time derivative(s) of the dot product between the position
#              components of 's1' and 's2'.
#
#              'dvdot' returns with the same measure of vectorization (N)
#              as 's1' and 's2'.
#
#              [1,n] = size(dvdot); double = class(dvdot)
#
#-Particulars
#
#   In this discussion, the notation
#
#      < V1, V2 >
#
#   indicates the dot product of vectors V1 and V2.
#
#   Given two state vectors s1 and s2 made up of position and velocity
#   components (r1,v1) and (r2,v2) respectively, dvdot calculates
#   the derivative of the dot product of p1 and p2, i.e. the time
#   derivative
#
#         d
#         -- < r1, r2 > = < v1, r2 > + < r1, v2 >
#         dt
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dvdot_c.
#
#   MICE.REQ
#
    function # dvdot
#       (dvdot::Float64) =   # SpiceDouble
        dvdot(
            s1::Array{Float64,1}, # Array_6_ConstSpiceDouble
            s2::Array{Float64,1}) # Array_6_ConstSpiceDouble
        
#       enforce input array sizes
        if length(s1) != 6
            error("Incorrect size for parameter 1")
        end
        if length(s2) != 6
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        dvdot = Array{Float64}(1);  # SpiceDouble
        dvdot_ptr = pointer(dvdot)
        
#       make transposed copies of all input arrays and their pointers
        s1_t = s1'
        s1_ptr = pointer(s1_t)
        s2_t = s2'
        s2_ptr = pointer(s2_t)
        
#       ccall((:dvdot_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(Array_6_ConstSpiceDouble,Array_6_ConstSpiceDouble),s1,s2)
        return ccall((:dvdot_c,libNasaSpice),Float64,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            s1_ptr,s2_ptr,dvdot_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#     Suppose that given two state vectors (s1 and s2) whose position
#     components are unit vectors, and that we need to compute the
#     rate of change of the angle between the two vectors.
#
#     We know that the Cosine of the angle THETA between them is given
#     by
#
#        cos(theta) = dot(s1,s2)
#
#     Thus by the chain rule, the derivative of the angle is given
#     by:
#
#        sine(theta) dtheta/dt = dvdot(s1,s2)
#
#     Thus for values of theta away from zero we can compute
#
#     dtheta/dt as
#
#     dtheta = dvdot(s1,s2) / sqrt( 1 - dot(s1,s2)**2 )
#
#     Note that position components of s1 and s2 are parallel, the
#     derivative of the  angle between the positions does not
#     exist.  Any code that computes the derivative of the angle
#     between two position vectors should account for the case
#     when the position components are parallel.
#
#-Version
#
#   -Mice Version 1.0.0, 20-APR-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #  #    #    ##     #####
#    #    #  #    #  #    #   #  #      #
#    #    #  #    #  ######  #    #     #
#    #    #  #    #  #    #  ######     #
#    #    #   #  #   #    #  #    #     #
#    #####     ##    #    #  #    #     #
#
#   state of a unit vector parallel to a state vector
#
################################################################################
#-Abstract
#
#   dvhat calculates the unit vector corresponding to a state or states
#   and the derivative of the unit vector.
#
#-I/O
#
#   Given:
#
#      s1   a double precision 6x1-array or 6xN array defining a
#           state or states;
#
#              s1 = (r1, dr1 ).
#                         --
#                         dt
#
#   the call:
#
#      dvhat = dvhat(s1)
#
#   returns:
#
#      dvhat   a double precision 6x1 array or 6xN array containing the unit
#              vector(s) pointing in the direction of the position component(s)
#              of 's1' and the derivative of the unit vector with respect
#              to time;
#
#              dvhat = [u, du ] where u =   r1
#                          --             -----
#                          dt             ||r1||
#
#              'dvhat' returns with the same measure of vectorization (N)
#              as 's1'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dvhat_c.
#
#   MICE.REQ
#
    function # dvhat
#       (sout::Array{Float64,1}(6)) =   # Array_6_SpiceDouble
        dvhat(
            s1::Array{Float64,1}) # Array_6_ConstSpiceDouble
        
#       enforce input array sizes
        if length(s1) != 6
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        sout = Array{Float64,1}(6);  # Array_6_SpiceDouble
        sout_ptr = pointer(sout)
        
#       make transposed copies of all input arrays and their pointers
        s1_t = s1'
        s1_ptr = pointer(s1_t)
        
#       ccall((:dvhat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,Array_6_SpiceDouble),s1,sout)
        ccall((:dvhat_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64}),
            s1_ptr,sout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return sout
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Suppose that 'state' gives the apparent state of a body with
#   respect to an observer.  This routine can be used to compute the
#   instantaneous angular rate of the object across the sky as seen
#   from the observers vantage.
#
#      %
#      % Load SPK, PCK, and LSK kernels, use a meta kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define an arbitrary epoch, convert the epoch to ephemeris time.
#      %
#      EPOCH = 'Jan 1 2009';
#      et    = cspice_str2et( EPOCH );
#
#      %
#      % Calculate the state of the moon with respect to the earth-moon
#      % barycenter in J2000, corrected for light time and stellar aberration
#      % at 'et'.
#      %
#      target   = 'MOON';
#      frame    = 'J2000';
#      abcorr   = 'LT+S';
#      observer = 'EARTH BARYCENTER';
#
#      [ state, ltime ] = cspice_spkezr( target, et, frame, abcorr, observer );
#
#      %
#      % Calculate the unit vector of 'state' and the derivative of the
#      % unit vector.
#      %
#      ustate = dvhat( state )
#
#      %
#      % Calculate the instantaneous angular velocity from the magnitude of the
#      % derivative of the unit vector.
#      %
#      %   v = r x omega
#      %
#      %   ||omega|| = ||v||  for  r . v = 0
#      %               -----
#      %               ||r||
#      %
#      %   ||omega|| = ||v||  for  ||r|| = 1
#      %
#      omega = cspice_vnorm( ustate(4:6) );
#
#      fprintf( 'Instantaneous angular velocity %2.10e rad/sec.\n', omega )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Instantaneous angular velocity 2.4810665797e-06  rad/sec.
#
#-Version
#
#   -Mice Version 1.0.0, 04-MAY-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #  #    #   ####   #####   #    #
#    #    #  #    #  ##   #  #    #  #    #  ##  ##
#    #    #  #    #  # #  #  #    #  #    #  # ## #
#    #    #  #    #  #  # #  #    #  #####   #    #
#    #    #   #  #   #   ##  #    #  #   #   #    #
#    #####     ##    #    #   ####   #    #  #    #
#
#   derivative of 3-vector norm
#
################################################################################
#-Abstract
#
#   dvnorm returns the derivative of the vector norm of a 3-vector.
#
#-I/O
#
#   Given:
#
#      state   6-vector(s), the second three components of the vector(s)
#              being the derivatives of the first three with respect to
#              some scalar.
#
#                 state =  ( x, dx )
#                               --
#                               ds
#
#              A common form for 'state' would contain position and
#              velocity.
#
#              [6,n] = size(state); double = class(state)
#
#   the call:
#
#      dvnorm = dvnorm(state)
#
#   returns:
#
#      dvnorm   the value(s) of d||x|| corresponding to 'state'.
#                               ------
#                               ds
#
#                                    1/2         2    2    2  1/2
#               Where ||x|| = < x, x >    =  ( x1 + x2 + x3 )
#
#
#                         v = ( dx1, dx2, dx3 )
#                               ---  ---  ---
#                               ds   ds   ds
#
#                     d||x||   < x, v >
#                    ------ =   ------    =  < xhat, v >
#                      ds             1/2
#                              < x, x >
#
#             'dvnorm' returns with the same measure of vectorization (N)
#             as 'state'.
#
#              [1,n] = size(dvnorm); double = class(dvnorm)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dvnorm_c.
#
#   MICE.REQ
#
    function # dvnorm
#       (dvnorm::Float64) =   # SpiceDouble
        dvnorm(
            state::Array{Float64,1}) # Array_6_ConstSpiceDouble
        
#       enforce input array sizes
        if length(state) != 6
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        dvnorm = Array{Float64}(1);  # SpiceDouble
        dvnorm_ptr = pointer(dvnorm)
        
#       make transposed copies of all input arrays and their pointers
        state_t = state'
        state_ptr = pointer(state_t)
        
#       ccall((:dvnorm_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(Array_6_ConstSpiceDouble,),state)
        return ccall((:dvnorm_c,libNasaSpice),Float64,
            (Ptr{Float64},Ptr{Float64}),
            state_ptr,dvnorm_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Create several 6-vectors (6x1 arrays) with the structure
#      %
#      %   y = |  x  |
#      %       |     |
#      %       |  dx |
#      %       |  -- |
#      %       |  ds |
#      %
#      % where 'x' is a 3-vector (3x1 array).
#      %
#
#      %
#      % Create 'y' with 'x' of varying magnitudes. Use 'x'
#      % and '-x' to define the derivative as parallel and
#      % anti-parallel.
#      %
#      mag = [ -4, 4, 12 ];
#
#      x   = [ 1, sqrt(2), sqrt(3 ) ]';
#
#      y   = [ [x * 10^mag(1);  x], ...
#              [x * 10^mag(2); -x], ...
#              [  zeros(3,1);  x * 10^mag(3) ] ];
#
#      %
#      % Calculate the derivative of the vector norms with respect
#      % to 's'.
#      %
#      dvnorm = dvnorm( y );
#
#      fprintf( 'Parallel x, dx/ds         : %f\n', dvnorm(1) )
#      fprintf( 'Anti-parallel x, dx/ds    : %f\n', dvnorm(2) )
#      fprintf( 'Zero vector x, large dx/ds: %f\n', dvnorm(3) )
#
#   Matlab outputs:
#
#      Parallel x, dx/ds         : 2.449490
#      Anti-parallel x, dx/ds    : -2.449490
#      Zero vector x, large dx/ds: 0.000000
#
#-Version
#
#   -Mice Version 1.0.1, 09-NOV-2012 (EDW)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 10-MAY-2010 (EDW)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #  #####    ####    ####   #
#    #    #  #    #  #    #  #    #  #    #  #
#    #    #  #    #  #    #  #    #  #    #  #
#    #    #  #    #  #####   #    #  #    #  #
#    #    #   #  #   #       #    #  #    #  #
#    #####     ##    #        ####    ####   ######
#
#   delete a kernel pool variable
#
################################################################################
#-Abstract
#
#   dvpool deletes a variable from the kernel pool.
#
#-I/O
#
#   Given:
#
#      name   name(s) of a pool variable(s) to delete from the kernel pool. The
#             name and associated values are removed from the kernel pool,
#             freeing the occupied space.
#
#             [n,m] = size(name); char = class(name)
#
#             If watches are set on the variable(s) designated by 'name',
#             the corresponding agents are placed on the list of agents
#             to notify of a kernel variable update.
#
#   the call:
#
#      dvpool( name )
#
#   performs the delete operation.
#
#-Particulars
#
#   This routine enables users to programmatically remove variables
#   from the kernel pool, as opposed to having to clear the pool and
#   reload it.
#
#   Note that it is not necessary to remove kernel variables in order
#   to simply update them; this routine should be used only when
#   variables are to be removed.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine dvpool_c.
#
#   MICE.REQ
#   KERNEL.REQ
#
    function # dvpool
#       (name::AbstractString) =   # Ptr{ConstSpiceChar}
        dvpool()
        
#       enforce input array sizes
#       allocate the output parameters
        name = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        name_ptr = pointer(name)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:dvpool_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},),name)
        ccall((:dvpool_c,libNasaSpice),Void,
            (Ptr{AbstractString},),
            name_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return name[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( '/kernels/gen/lsk/naif0009.tls'
#                                '/kernels/gen/spk/de421.bsp'
#                                '/kernels/gen/pck/pck00009.tpc'
#                      )
#
#         \begintext
#
#
#      %
#      % Load a kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % A template for the leapseconds kernel variables.
#      %
#      VAR = 'DELTET*';
#
#      %
#      % Query for the variable name, return 10 or less matches from
#      % index 1.
#      %
#      INDEX  = 1;
#      ROOM   = 10;
#
#
#      txt = sprintf( 'Kernel pool state after load.' );
#      disp( txt )
#
#      [kervar, found] = cspice_gnpool( VAR, INDEX, ROOM );
#
#      if( found )
#
#         n_elements = size(kervar, 1);
#
#         %
#         % Output the returned variable names.
#         %
#         for n=1: n_elements
#            txt = sprintf( 'Variable %d matching %s: %s', ...
#                                        n, VAR, kervar(n,:) );
#            disp( txt )
#         end
#
#      else
#         txt = sprintf( ['Failed to find  ' VAR ' in the kernel pool.'] );
#         disp( txt )
#      end
#
#
#      %
#      % Delete the kernel pool variables returned from cspice_gnpool.
#      %
#      dvpool( kervar )
#
#      txt = sprintf( '\nKernel pool state after deletion.' );
#      disp( txt )
#
#      %
#      % Confirm the variables were deleted from the pool.
#      %
#      [kervar, found] = cspice_gnpool( VAR, INDEX, ROOM );
#
#      if ( found )
#
#         n_elements = size(kervar, 1);
#
#         %
#         % Output the returned variable names.
#         %
#         for n=1: n_elements
#            txt = sprintf( 'Variable %d matching %s: %s', ...
#                                        n, VAR, kervar(n,:) );
#            disp( txt )
#         end
#
#      else
#         txt = sprintf( ['Failed to find  ' VAR ' in the kernel pool.'] );
#         disp( txt )
#      end
#
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Kernel pool state after load.
#      Variable 1 matching DELTET*: DELTET/DELTA_T_A
#      Variable 2 matching DELTET*: DELTET/DELTA_AT
#      Variable 3 matching DELTET*: DELTET/K
#      Variable 4 matching DELTET*: DELTET/M
#      Variable 5 matching DELTET*: DELTET/EB
#
#      Kernel pool state after deletion.
#      Failed to find  DELTET* in the kernel pool.
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #####   #          #    #    #  #####
#    #       #    #  #          #    ##  ##  #    #
#    #####   #    #  #          #    # ## #  #####
#    #       #    #  #          #    #    #  #    #
#    #       #    #  #          #    #    #  #    #
#    ######  #####   ######     #    #    #  #####
#
#   ellipsoid limb
#
################################################################################
#-Abstract
#
#   edlimb calculates the limb of a triaxial ellipsoid
#   as viewed from a specified location.
#
#-I/O
#
#   Given:
#
#      a
#      b
#      c        [1,1] = size(a); double = class(a)
#               [1,1] = size(b); double = class(b)
#               [1,1] = size(c); double = class(c)
#
#               are the  lengths of the semi-axes of a triaxial ellipsoid.
#               The ellipsoid is centered at the origin and oriented so that
#               its axes lie on the x, y and z axes. 'a', 'b', and 'c' are
#               the lengths of the semi-axes that respectively point in the
#               x, y, and z directions.
#
#      viewpt   a point from which the ellipsoid is viewed. 'viewpt' must be
#               outside of the ellipsoid.
#
#               [3,1] = size(viewpt); double = class(viewpt)
#
#   the call:
#
#      limb = edlimb( a, b, c, viewpt )
#
#   returns:
#
#      limb   the SPICE ellipse that represents the limb of the ellipsoid
#             observed from 'viewpt'.
#
#              [1,1] = size(limb); struct = class(limb)
#
#              The structure has the fields:
#
#                 center:    [3x1 double]
#                 semiMajor: [3x1 double]
#                 semiMinor: [3x1 double]
#
#-Particulars
#
#   The limb of a body, as seen from a viewing point, is the boundary
#   of the portion of the body's surface that is visible from that
#   viewing point.  In this definition, we consider a surface point
#   to be `visible' if it can be connected to the viewing point by a
#   line segment that doesn't pass through the body.  This is a purely
#   geometrical definition that ignores the matter of which portions
#   of the surface are illuminated, or whether the view is obscured by
#   any additional objects.
#
#   If a body is modeled as a triaxial ellipsoid, the limb is always
#   an ellipse.  The limb is determined by its center, a semi-major
#   axis vector, and a semi-minor axis vector.
#
#   We note that the problem of finding the limb of a triaxial
#   ellipsoid is mathematically identical to that of finding its
#   terminator, if one makes the simplifying assumption that the
#   terminator is the limb of the body as seen from the vertex of the
#   umbra.  So, this routine can be used to solve this simplified
#   version of the problem of finding the terminator.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine edlimb_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # edlimb
#       (limb::NasaSpice.Ellipse) =   # Ptr{SpiceEllipse}
        edlimb(
            a::Float64, # SpiceDouble
            b::Float64, # SpiceDouble
            c::Float64, # SpiceDouble
            viewpt::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(viewpt) != 3
            error("Incorrect size for parameter 4")
        end
#       allocate the output parameters
        limb = Ellipse()
        iolimb = IOBuffer()
        StrPack.pack( iolimb, limb)
        limb_ptr = convert( Ptr{Ptr{SpiceEllipse}}, convert( Ptr{Void}, pointer(iolimb.data) ) )
        
#       make transposed copies of all input arrays and their pointers
        viewpt_t = viewpt'
        viewpt_ptr = pointer(viewpt_t)
        
#       ccall((:edlimb_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_ConstSpiceDouble,Ptr{SpiceEllipse}),a,b,c,viewpt,limb)
        ccall((:edlimb_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Ptr{SpiceEllipse}}),
            a,b,c,viewpt_ptr,limb_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(iolimb,0)
        limb = StrPack.unpack( iolimb, Ellipse )
        return limb
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define an ellipsoid
#      %
#      a = sqrt(2.);
#      b = 2.*sqrt(2.);
#      c = sqrt(2.);
#
#      %
#      % Locate a viewpoint exterior to the ellipsoid.
#      %
#      viewpt = [ 2., 0.,  0. ]';
#
#      %
#      % Calculate the limb ellipse as seen by from the viewpoint.
#      %
#      limb = edlimb( a, b, c, viewpt );
#
#      %
#      % Output the structure components.
#      %
#      smin   = limb.semiMinor
#      smaj   = limb.semiMajor
#      center = limb.center
#
#      %
#      % Check against expected values:
#      %
#      % Semiminor: 0., 0., -1.
#      % Semimajor: 0., 2.,  0.
#      % Center   : 1., 0.,  0.
#      %
#
#   MATLAB outputs:
#
#      smin =
#
#           0
#           0
#          -1
#
#
#      smaj =
#
#           0
#           2
#           0
#
#
#      center =
#
#           1.000000000000000e+00
#                               0
#                               0
#
#-Version
#
#   -Mice Version 1.0.0, 09-NOV-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #####    #####  ######  #####   #    #
#    #       #    #     #    #       #    #  ##  ##
#    #####   #    #     #    #####   #    #  # ## #
#    #       #    #     #    #       #####   #    #
#    #       #    #     #    #       #   #   #    #
#    ######  #####      #    ######  #    #  #    #
#
#   find terminator on ellipsoid
#   find umbral terminator on ellipsoid
#   find penumbral terminator on ellipsoid
#
################################################################################
#-Abstract
#
#   edterm computes a set of points on the umbral or penumbral
#   terminator of a specified target body, where the target shape is modeled
#   as an ellipsoid.
#
#-I/O
#
#   Given:
#
#      trmtyp   string indicating the type of terminator to
#               compute: umbral or penumbral. The umbral terminator is
#               the boundary of the portion of the ellipsoid surface in
#               total shadow. The penumbral terminator is the boundary
#               of the portion of the surface that is completely
#               illuminated. Note that in astronomy references, the
#               unqualified word "terminator" refers to the umbral
#               terminator. Here, the unqualified word refers to either
#               type of terminator.
#
#               Possible values of 'trmtyp' are
#
#                  'UMBRAL'
#                  'PENUMBRAL'
#
#               Case and leading or trailing blanks in 'trmtyp' are
#               not significant.
#
#               [1,c1] = size(trmtyp); char = class(trmtyp)
#
#      source   string name of the body acting as a light source.
#               'source' is case-insensitive, and leading and trailing
#               blanks in 'target' are not significant. Optionally, you
#               may supply a string containing the integer ID code for
#               the object. For example both "SUN" and "10" are
#               legitimate strings that indicate the Sun is the light
#               source.
#
#               This routine assumes that a kernel variable representing
#               the light source's radii is present in the kernel pool.
#               Normally the kernel variable would be defined by loading
#               a PCK file.
#
#               The shape of the light source is always modeled as a
#               sphere, regardless of whether radii defining a triaxial
#               ellipsoidal shape model are available in the kernel
#               pool. The maximum radius of the body is used as the
#               radius of the sphere.
#
#               [1,c2] = size(source); char = class(source)
#
#      target   string name of the target body. 'target' is
#               case-insensitive, and leading and trailing blanks in
#               'target' are not significant. Optionally, you may supply
#               a string containing the integer ID code for the object.
#               For example both "MOON" and "301" are legitimate strings
#               that indicate the moon is the target body.
#
#               This routine assumes that a kernel variable representing
#               the target's radii is present in the kernel pool.
#               Normally the kernel variable would be defined by loading
#               a PCK file.
#
#               [1,c3] = size(target); char = class(target)
#
#      et       epoch of participation of the observer, expressed
#               as ephemeris seconds past J2000 TDB: 'et' is the epoch
#               at which the observer's position is computed.
#
#               When aberration corrections are not used, 'et' is also
#               the epoch at which the position and orientation of the
#               target body and position of the light source are
#               computed.
#
#               When aberration corrections are used, 'et' is the epoch
#               at which the observer's position relative to the solar
#               system barycenter is computed; in this case the position
#               and orientation of the target body are computed at
#               et-lt, where lt is the one-way light time between the
#               target body's center and the observer. See the
#               description of 'abcorr' below for details.
#
#               [1,1] = size(et); double = class(et)
#
#      fixref   string name of the reference frame relative to
#               which the output terminator points are expressed. This must
#               be a body-centered, body-fixed frame associated with the
#               target. The frame's axes must be compatible with the
#               triaxial ellipsoidal shape model associated with the
#               target body (normally provide via a PCK): this routine
#               assumes that the first, second, and third axis lengths
#               correspond, respectively, to the x, y, and z-axes of the
#               frame designated by 'fixref'.
#
#               'fixref' may refer to a built-in frame (documented in
#               the Frames Required Reading) or a frame defined by a
#               loaded frame kernel (FK).
#
#               The orientation of the frame designated by 'fixref' is
#               evaluated at epoch of participation of the target body.
#               See the descriptions of 'et' and 'abcorr' for details.
#
#               [1,c4] = size(fixref); char = class(fixref)
#
#      abcorr   string indicating the aberration correction to be
#               applied when computing the observer-target position, the
#               orientation of the target body, and the target-
#               source position vector. 'abcorr' may be any of
#               the following.
#
#                  'NONE'     Apply no correction. Compute the
#                             terminator points using the position
#                             of the light source and target, and
#                             the orientation of the target, at 'et'.
#
#               Let 'lt' represent the one-way light time between the
#               observer and the target body's center. The following
#               values of 'abcorr' apply to the "reception" case in
#               which photons depart from the target body's center at
#               the light-time corrected epoch et-lt and *arrive* at
#               the observer's location at 'et':
#
#
#                  'LT'       Correct for one-way light time (also
#                             called "planetary aberration") using a
#                             Newtonian formulation. This correction
#                             yields the location of the terminator
#                             points at the approximate time they
#                             emitted photons arriving at the
#                             observer at 'et' (the difference between
#                             light time to the target center and
#                             light time to the terminator points
#                             is ignored).
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             'LT' option uses one iteration.
#
#                             The target position as seen by the
#                             observer, the position of the light
#                             source as seen from the target at
#                             et-lt, and the rotation of the target
#                             body, are corrected for light time.
#
#                  'LT+S'     Correct for one-way light time and
#                             stellar aberration using a Newtonian
#                             formulation. This option modifies the
#                             positions obtained with the 'LT' option
#                             to account for the observer's velocity
#                             relative to the solar system
#                             barycenter. This correction also
#                             applies to the position of the light
#                             source relative to the target. The
#                             result is the apparent terminator as
#                              seen by the observer.
#
#                  'CN'       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the 'CN' correction iterates
#                             until the solution converges. The
#                             position and rotation of the target
#                             body and the position of the light
#                             source relative to the target are
#                             corrected for light time.
#
#                  'CN+S'     Converged Newtonian light time
#                             and stellar aberration corrections.
#
#               [1,c5] = size(abcorr); char = class(abcorr)
#
#      obsrvr   string name of the observing body. This is typically
#               a spacecraft, the Earth, or a surface point on the
#               Earth. 'obsrvr' is case-insensitive, and leading and
#               trailing blanks in 'obsrvr' are not significant.
#               Optionally, you may supply a string containing the
#               integer ID code for the object. For example both
#               'EARTH' and '399' are legitimate strings that indicate
#               the Earth is the observer.
#
#               [1,c5] = size(obsrvr); char = class(obsrvr)
#
#      npts     number of terminator points to compute.
#
#               [1,1] = size(npts); int32 = class(npts)
#
#   the call:
#
#     [ trgepc, obspos, termpts] = edterm( trmtyp, source, ...
#                                                 target, et,     ...
#                                                 fixfrm, abcorr, ...
#                                                 obsrvr, npts)
#
#   returns:
#
#      trgepc   the "target epoch" of the calculation. 'trgepc' is
#               defined as follows: letting 'lt' be the one-way light
#               time between the target center and observer, 'trgepc' is
#               either the epoch et-lt or 'et' depending on whether the
#               requested aberration correction is, respectively, for
#               received radiation or omitted. 'lt' is computed using the
#               method indicated by 'abcorr'.
#
#               'trgepc' is expressed as seconds past J2000 TDB.
#
#               [1,1] = size(trgepc); double = class(trgepc)
#
#      obspos   position vector from the center of the target body
#               at epoch 'trgepc' to the observer at epoch 'et'. 'obspos' is
#               expressed in the target body-fixed reference frame
#               'fixref', which is evaluated at 'trgepc'.
#
#               'obspos' is returned to simplify various related
#               computations that would otherwise be cumbersome. For
#               example, the vector 'xvec' from the observer to the
#               ith terminator point can be calculated via the call
#
#                  xvec = trmpts(*,i) - obspos
#
#               To transform the vector 'obspos' from a reference frame
#               'fixref' at time 'trgepc' to a time-dependent reference
#               frame 'ref' at time 'et', the routine pxfrm2_c should be
#               called. Let 'xform' be the 3x3 matrix representing the
#               rotation from the reference frame 'fixref' at time
#               'trgepc' to the reference frame 'ref' at time 'et'. Then
#               'obspos' can be transformed to the result 'refvec' as
#               follows:
#
#                   xform  = cspice_pxfrm2( fixref, ref, trgepc, et )
#                   refvec = xform*obspos
#
#               [3,1] = size(obspos); double = class(obspos)
#
#      trmpts   array of points on the umbral or penumbral terminator
#               of the ellipsoid, as specified by the input argument
#               'trmtyp'. The ith point is contained in the array
#
#                   pos_i = trmpts(*,i)
#
#               Each terminator point is the point of tangency of a
#               plane that is also tangent to the light source. These
#               associated points of tangency on the light source have
#               uniform distribution in longitude when expressed in a
#               cylindrical coordinate system whose Z-axis is the target
#               center to source center vector. The magnitude of the
#               separation in longitude between the tangency points on
#               the light source is
#
#                  2*pi / npts
#
#               If the target is spherical, the terminator points
#               also are uniformly distributed in longitude in the
#               cylindrical system described above. If the target is
#               non-spherical, the longitude distribution of the
#               points generally is not uniform.
#
#               The terminator points are expressed in the body-fixed
#               reference frame designated by 'fixref'. Units are km.
#
#               [3,npts] = size(trmpts); double = class(trmpts)
#
#-Particulars
#
#   This routine models the boundaries of shadow regions on an
#   ellipsoidal target body "illuminated" by a spherical light
#   source. Light rays are assumed to travel along straight lines;
#   refraction is not modeled.
#
#   Points on the target body's surface are classified according to
#   their illumination as follows:
#
#      -  A target surface point X for which no vector from X to any
#         point in the light source intersects the target, except at
#         X, is considered to be "completely illuminated."
#
#      -  A target surface point X for which each vector from X to a
#         point in the light source intersects the target at points
#         other than X is considered to be "in total shadow."
#
#      -  All other target points are considered to be in partial
#         shadow.
#
#   In this routine, we use the term "umbral terminator" to denote
#   the curve usually called the "terminator": this curve is the
#   boundary of the portion of the target body's surface that lies in
#   total shadow. We use the term "penumbral terminator" to denote
#   the boundary of the completely illuminated portion of the
#   surface.
#
#   In general, the terminator on an ellipsoid is a more complicated
#   curve than the limb (which is always an ellipse). Aside from
#   various special cases, the terminator does not lie in a plane.
#
#   However, the condition for a point X on the ellipsoid to lie on
#   the terminator is simple: a plane tangent to the ellipsoid at X
#   must also be tangent to the light source. If this tangent plane
#   does not intersect the vector from the center of the ellipsoid to
#   the center of the light source, then X lies on the umbral
#   terminator; otherwise X lies on the penumbral terminator.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine edterm_c.
#
#   MICE.REQ
#
    function # edterm
#       (trgepc::Float64,  # Ptr{SpiceDouble}
#        obspos::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        termpts::Array{Float64,1}(3)) =   # Ptr{Array_3_SpiceDouble}
        edterm(
            trmtyp::AbstractString, # Ptr{ConstSpiceChar}
            source::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            fixfrm::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            npts::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        trgepc = Array{Float64}(1);  # Ptr{SpiceDouble}
        trgepc_ptr = pointer(trgepc)
        obspos = Array{Float64,1}(3);  # Array_3_SpiceDouble
        obspos_ptr = pointer(obspos)
        termpts = Array{Float64,1}(3);  # Ptr{Array_3_SpiceDouble}
        termpts_ptr = pointer(termpts)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:edterm_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceInt,Ptr{SpiceDouble},Array_3_SpiceDouble,Ptr{Array_3_SpiceDouble}),trmtyp,source,target,et,fixfrm,abcorr,obsrvr,npts,trgepc,obspos,termpts)
        ccall((:edterm_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Int32,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            trmtyp,source,target,et,fixfrm,abcorr,obsrvr,npts,trgepc_ptr,obspos_ptr,termpts_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return trgepc[1], obspos, termpts
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00010.tpc                  Planet orientation and
#                                          radii
#            naif0010.tls                  Leapseconds
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'de421.bsp',
#                                'pck00010.tpc',
#                                'naif0010.tls'  )
#
#         \begintext
#
#   Example:
#
#      Compute sets of umbral and penumbral terminator points on the
#      Moon. Perform a consistency check using the solar incidence
#      angle at each point. We expect to see a solar incidence angle of
#      approximately 90 degrees. Since the solar incidence angle is
#      measured between the local outward normal and the direction to
#      the center of the Sun, the solar incidence angle at an umbral
#      terminator point should exceed 90 degrees by approximately the
#      angular radius of the Sun, while the angle at a penumbral
#      terminator points should be less than 90 degrees by that amount.
#
#      META    = 'standard.tm';
#      NPTS    =  3;
#      first   = true;
#      trmtyps = { 'UMBRAL', 'PENUMBRAL' };
#      s       = [ -1, 1];
#      R2D     = cspice_dpr();
#
#      %
#      % Load meta-kernel.
#      %
#      cspice_furnsh( META )
#
#      %
#      % Set observation time.
#      %
#      utc    = '2007 FEB 3 00:00:00.000';
#
#      et = cspice_str2et( utc );
#
#      %
#      % Set participating objects, frame, and aberration
#      % corrections.
#      %
#      obsrvr = 'EARTH';
#      target = 'MOON';
#      source = 'SUN';
#      fixref = 'IAU_MOON';
#      abcorr = 'LT+S';
#
#      %
#      % Look up the radii of the sun.
#      %
#      srcrad = cspice_bodvrd( source, 'RADII', 3 );
#
#      %
#      % Compute terminator points.
#      %
#      for trmidx=1:2
#
#         [ trgepc, obspos, trmpts] = edterm(      ...
#                        trmtyps(trmidx), source, target, ...
#                        et,              fixref, abcorr, ...
#                        obsrvr,          NPTS );
#
#         %
#         % Validate terminator points.
#         %
#         % Look up the target-sun vector at the light-time
#         % corrected target epoch.
#         %
#         if ( first )
#            [srcpos, ltime] = cspice_spkpos( source, trgepc, ...
#                                             fixref, abcorr, ...
#                                             target );
#
#            first = false;
#         end
#
#         fprintf(' Terminator type: %s\n', char(trmtyps(trmidx)) )
#
#         for i = 1:NPTS
#
#            %
#            % Convert the ith terminator point to latitudinal
#            % coordinates. Display the point.
#            %
#            [radius, lon, lat] = cspice_reclat( trmpts(:,i) );
#
#            fprintf('Terminator point :%d\n', i )
#            fprintf('  Radius                     (km):  %f\n', radius)
#            fprintf('  Planetocentric longitude   (deg): %f\n', lon *R2D)
#            fprintf('  Planetocentric latitude    (deg): %f\n', lat *R2D)
#
#            %
#            % Find the illumination angles at the
#            % ith terminator point.
#            %
#            [trgepc, srfvec, phase, solar, emissn] = ...
#                                     cspice_ilumin( 'Ellipsoid', ...
#                                            target, et,          ...
#                                            fixref, abcorr,      ...
#                                            obsrvr, trmpts(:,i) );
#
#            fprintf('  Solar incidence angle      (deg): %f\n', solar *R2D)
#
#
#            %
#            % Find the angular radius of the Sun as seen from
#            % the terminator point.
#            %
#            angrad = asin( srcrad(1)/cspice_vdist( srcpos, trmpts(:,i)) );
#
#
#            %
#            % Display the solar incidence angle after
#            % adjusting the angular radius of the Sun
#            % as seen from the terminator point.The
#            % result should be approximately 90 degrees.
#            %
#            fprintf('  Solar incidence angle adjusted for\n' )
#            fprintf('  sun''s angular radius (deg): %18.9f\n\n', ...
#                         ( solar + ( s(trmidx)*angrad ) ) *R2D)
#
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#       Terminator type: UMBRAL
#      Terminator point :1
#        Radius                     (km):  1737.400000
#        Planetocentric longitude   (deg): -95.084553
#        Planetocentric latitude    (deg): 0.004053
#        Solar incidence angle      (deg): 90.269766
#        Solar incidence angle adjusted for
#        sun's angular radius (deg):       90.000000125
#
#      Terminator point :2
#        Radius                     (km):  1737.400000
#        Planetocentric longitude   (deg): 84.228092
#        Planetocentric latitude    (deg): 59.995756
#        Solar incidence angle      (deg): 90.269766
#        Solar incidence angle adjusted for
#        sun's angular radius (deg):       90.000000019
#
#      Terminator point :3
#        Radius                     (km):  1737.400000
#        Planetocentric longitude   (deg): 87.216418
#        Planetocentric latitude    (deg): -59.979551
#        Solar incidence angle      (deg): 90.269766
#        Solar incidence angle adjusted for
#        sun's angular radius (deg):       90.000000043
#
#       Terminator type: PENUMBRAL
#      Terminator point :1
#        Radius                     (km):  1737.400000
#        Planetocentric longitude   (deg): 84.914101
#        Planetocentric latitude    (deg): -0.004073
#        Solar incidence angle      (deg): 89.730234
#        Solar incidence angle adjusted for
#        sun's angular radius (deg):       90.000000122
#
#      Terminator point :2
#        Radius                     (km):  1737.400000
#        Planetocentric longitude   (deg): -95.769216
#        Planetocentric latitude    (deg): -59.995785
#        Solar incidence angle      (deg): 89.730234
#        Solar incidence angle adjusted for
#        sun's angular radius (deg):       90.000000021
#
#      Terminator point :3
#        Radius                     (km):  1737.400000
#        Planetocentric longitude   (deg): -92.780892
#        Planetocentric latitude    (deg): 59.979499
#        Solar incidence angle      (deg): 89.730234
#        Solar incidence angle adjusted for
#        sun's angular radius (deg):       90.000000044
#
#-Version
#
#   -Mice Version 1.0.0, 18-JUN-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #    #   ####   #####
#    #       #   #   #    #  #    #
#    #####   ####    #       #    #
#    #       #  #    #  ###  #    #
#    #       #   #   #    #  #    #
#    ######  #    #   ####   #####
#
#   fetch element from double precision column entry
#
################################################################################
#-Abstract
#
#   ekgd returns an element of double precision data from a
#   specified row in a specified column of the set of rows matching
#   the previous cspice_ekfind SELECT query.
#
#-I/O
#
#   Given:
#
#      selidx   the scalar integer index for a column of interest
#               satisfying the SELECT clause, the column indices
#               range from 1 to number of columns in the SELECT clause.
#
#      row      the scalar integer index for a row in the column
#               identified by 'selidx', the column indices
#               range from 1 to 'nmrows' where 'nmrows' equals the total
#               number of rows satisfying the SELECT clause.
#
#      elment   the scalar integer index for an element of
#               the data at the 'selidx','row' position; a scalar
#               value at 'selidx', 'row' has 'elment' value one.
#
#   the call:
#
#      [ ddata, null, found] = ekgd( selidx, row, elment )
#
#   returns:
#
#      ddata    the scalar double value of the requested element at
#               data location 'selidx', 'row', 'elment'.
#
#      null     a scalar boolean indicating if 'ddata' has a null value.
#
#      found    a scalar boolean indicating whether the specified
#               value at 'selidx', 'row', 'elment' was found.
#
#-Particulars
#
#   Suppose a SELECT clause return data consisting of three columns (N=3)
#   and four rows (M=4):
#
#              col 1    col 2    col 3
#
#      row 1   val_11   val_12   val_13
#      row 2   val_21   val_22   val_23
#      row 3   val_31   val_32   val_33
#      row 4   val_41   val_42   val_43
#
#   with "col 2" and "col 3" containing scalar double precision data
#   and "val_42" containing a vector of K doubles.
#
#   Retrieving the data elements depends on the values for the index set
#   "selidx," "row," and "elment."
#
#   Use the set
#
#      'selidx' = 2, 'row' = 3, 'elment' = 1
#
#   to fetch scalar "val_32."
#
#   Use the set
#
#      'selidx' = 3, 'row' = 4, 'elment' = 1
#
#   to fetch scalar "val_43."
#
#   Use the set
#
#      'selidx' = 2, 'row' = 4, 'elment' = K
#
#   to fetch the final element of vector "val_42"
#
#   'elment' is allowed to exceed the number of elements in the column
#   entry; if it does, 'found' returns as false.  This allows the caller
#   to read data from the column entry in a loop without checking the
#   number of available elements first.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ekgd_c.
#
#   MICE.REQ
#   EK.REQ
#
    function # ekgd
#       (ddata::Float64,  # Ptr{SpiceDouble}
#        null::Int32,  # Ptr{SpiceBoolean}
#        found::Int32) =   # Ptr{SpiceBoolean}
        ekgd(
            selidx::Int32, # SpiceInt
            row::Int32, # SpiceInt
            elment::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        ddata = Array{Float64}(1);  # Ptr{SpiceDouble}
        ddata_ptr = pointer(ddata)
        null = Array{Int32}(1);  # Ptr{SpiceBoolean}
        null_ptr = pointer(null)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ekgd_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceInt,SpiceInt,Ptr{SpiceDouble},Ptr{SpiceBoolean},Ptr{SpiceBoolean}),selidx,row,elment,ddata,null,found)
        ccall((:ekgd_c,libNasaSpice),Void,
            (Int32,Int32,Int32,Ptr{Float64},Ptr{Int32},Ptr{Int32}),
            selidx,row,elment,ddata_ptr,null_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return ddata[1], convert( Bool, null[1] ), convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Assign an EK file to load.
#      %
#      EK = 'test_file.ek';
#
#      %
#      % Load the EK.
#      %
#      cspice_furnsh( EK )
#
#      %
#      % Assume the file test_file.ek contains the table 'scalar_2',
#      % and that "scalar_2' has the column named 'd_col_1' of scalar double
#      % precision values.
#      %
#      % Define a set of constraints to perform a query on all
#      % loaded EK files (the SELECT clause). In this case select
#      % the column "d_col_1" from table "scalar_2."
#      %
#      query = 'Select d_col_1 from scalar_2 order by row_no';
#
#      %
#      % Query the EK system for data rows matching the
#      % SELECT constraints.
#      %
#      [ nmrows, ok, errmsg ] = cspice_ekfind( query );
#
#      %
#      % Check whether an error occurred while processing the
#      % SELECT clause. If so, output the error message.
#      %
#      if ( ok )
#         printf( 'SELECT clause error: %s\n', errmsg );
#      end
#
#      %
#      % Loop over each row found matching the query.
#      %
#      for rowno = 1:nmrows
#
#         %
#         % Fetch the double precision data. We know the query returned
#         % one column and the column contains only scalar data,
#         % so the index of all elements is 1.
#         %
#         selidx = 1;
#         eltidx = 1;
#
#         %
#         % Use ekgd to retrieve the value from
#         % row/column position.
#         %
#         [ ddata, isnull, found ] = ekgd( selidx, ...
#                                                 rowno,  ...
#                                                 eltidx );
#
#         %
#         % Output the value, if non-null data exist at the
#         % requested position.
#         %
#         if  ~isnull
#            fprintf( 'Double precision data: %f\n', ddata );
#         end
#
#      end
#
#      %
#      % Clear the kernel pool and database. Note, you don't normally
#      % unload an EK after a query, rather at the end of a program.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Double precision data: -2000001.000000
#      Double precision data: -2000002.000000
#      Double precision data: -2000003.000000
#      Double precision data: -2000004.000000
#      Double precision data: -2000005.000000
#      Double precision data: -2000006.000000
#      Double precision data: -2000007.000000
#      Double precision data: -2000008.000000
#      Double precision data: -2000009.000000
#      Double precision data: -2000010.000000
#      Double precision data: -2000011.000000
#      Double precision data: -2000012.000000
#      Double precision data: -2000013.000000
#      Double precision data: -2000014.000000
#      Double precision data: -2000015.000000
#      Double precision data: -2000016.000000
#      Double precision data: -2000017.000000
#      Double precision data: -2000018.000000
#      Double precision data: -2000019.000000
#      Double precision data: -2000020.000000
#
#-Version
#
#   -Mice Version 1.2.0, 10-MAY-2011, EDW (JPL)
#
#      "logical" call replaced with "zzmice_logical."
#
#   -Mice Version 1.0.0, 10-APR-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #    #   ####      #
#    #       #   #   #    #     #
#    #####   ####    #          #
#    #       #  #    #  ###     #
#    #       #   #   #    #     #
#    ######  #    #   ####      #
#
#   fetch element from integer column entry
#
################################################################################
#-Abstract
#
#   ekgi returns an element of integer data from a
#   specified row in a specified column of the set of rows matching
#   the previous cspice_ekfind SELECT query.
#
#-I/O
#
#   Given:
#
#      selidx   the scalar integer index for a column of interest
#               satisfying the SELECT clause, the column indices
#               range from 1 to number of columns in the SELECT clause.
#
#      row      the scalar integer index for a row in the column
#               identified by 'selidx', the column indices
#               range from 1 to 'nmrows' where 'nmrows' equals the total
#               number of rows satisfying the SELECT clause.
#
#      elment   the scalar integer index for an element of
#               the data at the 'selidx','row' position; a scalar
#               value at 'selidx', 'row' has 'elment' value one.
#
#   the call:
#
#      [ idata, null, found] = ekgi( selidx, row, elment )
#
#   returns:
#
#      idata    the integer value of the requested element at
#               data location 'selidx', 'row', 'elment'.
#
#      null     a scalar boolean indicating if 'idata' has a null value.
#
#      found    a scalar boolean indicating whether the specified
#               value at 'selidx', 'row', 'elment' was found.
#
#-Particulars
#
#   Suppose a SELECT clause return data consisting of three columns (N=3)
#   and four rows (M=4):
#
#              col 1    col 2    col 3
#
#      row 1   val_11   val_12   val_13
#      row 2   val_21   val_22   val_23
#      row 3   val_31   val_32   val_33
#      row 4   val_41   val_42   val_43
#
#   with "col 2" and "col 3" containing scalar integer data and "val_42"
#   containing a vector of K integers.
#
#   Retrieving the data elements depends on the values for the index set
#   "selidx," "row," and "elment."
#
#   Use the set
#
#      'selidx' = 2, 'row' = 3, 'elment' = 1
#
#   to fetch scalar "val_32."
#
#   Use the set
#
#      'selidx' = 3, 'row' = 4, 'elment' = 1
#
#   to fetch scalar "val_43."
#
#   Use the set
#
#      'selidx' = 2, 'row' = 4, 'elment' = K
#
#   to fetch the final element of vector "val_42"
#
#   'elment' is allowed to exceed the number of elements in the column
#   entry; if it does, 'found' returns as false.  This allows the caller
#   to read data from the column entry in a loop without checking the
#   number of available elements first.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ekgi_c.
#
#   MICE.REQ
#   EK.REQ
#
    function # ekgi
#       (idata::Int32,  # Ptr{SpiceInt}
#        null::Int32,  # Ptr{SpiceBoolean}
#        found::Int32) =   # Ptr{SpiceBoolean}
        ekgi(
            selidx::Int32, # SpiceInt
            row::Int32, # SpiceInt
            elment::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        idata = Array{Int32}(1);  # Ptr{SpiceInt}
        idata_ptr = pointer(idata)
        null = Array{Int32}(1);  # Ptr{SpiceBoolean}
        null_ptr = pointer(null)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ekgi_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceInt,SpiceInt,Ptr{SpiceInt},Ptr{SpiceBoolean},Ptr{SpiceBoolean}),selidx,row,elment,idata,null,found)
        ccall((:ekgi_c,libNasaSpice),Void,
            (Int32,Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32}),
            selidx,row,elment,idata_ptr,null_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return idata[1], convert( Bool, null[1] ), convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Assign an EK file to load..
#      %
#      EK = 'test_file.ek';
#
#      %
#      % Load the EK.
#      %
#      cspice_furnsh( EK )
#
#      %
#      % Assume the file test_file.ek contains the table 'scalar_2',
#      % and that "scalar_2' has the column named 'i_col_1' of integer
#      % values.
#      %
#      % Define a set of constraints to perform a query on all
#      % loaded EK files (the SELECT clause). In this case select
#      % the column "i_col_1" from table "scalar_2."
#      %
#      query = 'Select i_col_1 from scalar_2 order by row_no';
#
#      %
#      % Query the EK system for data rows matching the
#      % SELECT constraints.
#      %
#      [ nmrows, ok, errmsg ] = cspice_ekfind( query );
#
#      %
#      % Check whether an error occurred while processing the
#      % SELECT clause. If so, output the error message.
#      %
#      if ( ok )
#         printf( 'SELECT clause error: %s\n', errmsg );
#      end
#
#      %
#      % Loop over each row found matching the query.
#      %
#      for rowno = 1:nmrows
#
#         %
#         % Fetch the integer data. We know the query returned
#         % one column and the column contains only scalar data,
#         % so the index of all elements is 1.
#         %
#         selidx = 1;
#         eltidx = 1;
#
#         %
#         % Use ekgi to retrieve the value from
#         % row/column position.
#         %
#         [ idata, isnull, found ] = ekgi( selidx, ...
#                                                 rowno,  ...
#                                                 eltidx );
#
#         %
#         % Output the value, if non-null data exist at the
#         % requested position.
#         %
#         if  ~isnull
#            fprintf( 'Integer data: %d\n', idata );
#         end
#
#      end
#
#      %
#      % Clear the kernel pool and database. Note, you don't normally
#      % unload an EK after a query, rather at the end of a program.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Integer data: 2000001
#      Integer data: 2000002
#      Integer data: 2000003
#      Integer data: 2000004
#      Integer data: 2000005
#      Integer data: 2000006
#      Integer data: 2000007
#      Integer data: 2000008
#      Integer data: 2000009
#      Integer data: 2000010
#      Integer data: 2000011
#      Integer data: 2000012
#      Integer data: 2000013
#      Integer data: 2000014
#      Integer data: 2000015
#      Integer data: 2000016
#      Integer data: 2000017
#      Integer data: 2000018
#      Integer data: 2000019
#      Integer data: 2000020
#
#-Version
#
#   -Mice Version 1.2.0, 10-MAY-2011, EDW (JPL)
#
#      "logical" call replaced with "zzmice_logical."
#
#   -Mice Version 1.0.0, 10-APR-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #    #  #    #  ######  #        #####
#    #       #   #   ##   #  #       #          #
#    #####   ####    # #  #  #####   #          #
#    #       #  #    #  # #  #       #          #
#    #       #   #   #   ##  #       #          #
#    ######  #    #  #    #  ######  ######     #
#
#   return the number of elements in a column entry
#
################################################################################
#-Abstract
#
#   eknelt returns the number of elements in a specified column entry
#   in the current row.
#
#-I/O
#
#   Given:
#
#      selidx   the scalar integer index of the column in the
#               SELECT from which to retrieve data. The range of
#               'selidx' is 1:nsel inclusive, where 'nsel' is the
#               number of items in the SELECT clause of the current
#               query.
#
#      row      the scalar integer index of the row containing the element.
#               This number refers to a member of the set of rows
#               matching a query. 'row' must be in the range
#
#                  1:nmrows
#
#               where 'nmrows' is the matching row count returned
#               by cspice_ekfind.
#
#   the call:
#
#       nelt = eknelt( selidx, row )
#
#   returns:
#
#      nelt    the scalar integer number of elements in the column entry
#              belonging to the specified column in the specified row.
#
#      Null entries in variable-size columns are considered to have size 1.
#
#-Particulars
#
#   This routine is meant to be used in conjunction with the EK fetch
#   entry points cspice_ekgc, cspice_ekgd, and cspice_ekgi.  This routine
#   allows the caller of those routines to determine appropriate
#   loop bounds to use to fetch each column entry in the current row.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine eknelt_c.
#
#   MICE.REQ
#   EK.REQ
#
    function # eknelt
#       (nelt::Int32) =   # SpiceInt
        eknelt(
            selidx::Int32, # SpiceInt
            row::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        nelt = Array{Int32}(1);  # SpiceInt
        nelt_ptr = pointer(nelt)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:eknelt_c,"/home/don/.julia/v0.3/cspice.so"),SpiceInt,(SpiceInt,SpiceInt),selidx,row)
        return ccall((:eknelt_c,libNasaSpice),Int32,
            (Int32,Int32,Ptr{Int32}),
            selidx,row,nelt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Assign an EK file to load.
#      %
#      EK = 'test_file.ek';
#
#      %
#      % Load the EK.
#      %
#      cspice_furnsh( EK )
#
#      %
#      % The file "test_file.ek" contains the table 'vector_1', and
#      % 'vector_1' has the column named 'd_col_1', a vector of double
#      % precision values.
#      %
#
#      %
#      % Define a set of constraints to perform a query on all
#      % loaded EK files (the SELECT clause). In this case select
#      % the column "d_col_1" from table "vector_1."
#      %
#      query = 'Select d_col_1 from vector_1 order by row_no';
#
#      %
#      % Query the EK system for data rows matching the
#      % SELECT restraints.
#      %
#      [ nmrows, ok, errmsg ] = cspice_ekfind( query );
#
#      %
#      % Check whether an error occurred while processing the
#      % SELECT clause. If so, output the error message.
#      %
#      if ( ok )
#         printf( 'SELECT clause error: %s\n', errmsg );
#      end
#
#      %
#      % Loop over each row found matching the query.
#      %
#      for rowno = 1:nmrows
#
#         %
#         % Fetch the double precision data. We know the query returned
#         % one column, determine the number of values in the row of
#         % interest.
#         %
#         selidx = 1;
#         nelt   = eknelt( selidx, rowno);
#
#         %
#         % Use cspice_ekgd to retrieve the value from
#         % row/column position.
#         %
#
#         for eltidx = 1:nelt
#
#            [ ddata, isnull, found ] = cspice_ekgd( selidx, ...
#                                                    rowno,  ...
#                                                    eltidx );
#
#            %
#            % Output the value, if non-null data exist at the
#            % requested position.
#            %
#            if  ~isnull
#               fprintf( 'Double precision data (%d,%d,%d): %f\n', ...
#                        selidx, rowno, eltidx, ddata );
#            end
#
#         end
#
#      end
#
#      %
#      % Clear the kernel pool and database. Note, you don't normally
#      % unload an EK after a query, rather at the end of a program.
#      %
#      cspice_kclear
#
#   Matlab outputs:
#
#      Double precision data (1,1,1): 5000101.000000
#      Double precision data (1,1,2): 5000102.000000
#      Double precision data (1,1,3): 5000103.000000
#      Double precision data (1,1,4): 5000104.000000
#      Double precision data (1,2,1): 5000201.000000
#      Double precision data (1,2,2): 5000202.000000
#      Double precision data (1,2,3): 5000203.000000
#      Double precision data (1,2,4): 5000204.000000
#      Double precision data (1,3,1): 5000301.000000
#      Double precision data (1,3,2): 5000302.000000
#      Double precision data (1,3,3): 5000303.000000
#      Double precision data (1,3,4): 5000304.000000
#
#-Version
#
#   -Mice Version 1.0.0, 10-APR-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                    #####
#    ######  #      #     #   ####    ####   #    #
#    #       #            #  #    #  #    #  #    #
#    #####   #       #####   #       #       #    #
#    #       #      #        #       #  ###  #    #
#    #       #      #        #    #  #    #   #  #
#    ######  ###### #######   ####    ####     ##
#
#   ellipse to center and generating vectors
#
################################################################################
#-Abstract
#
#   el2cgv converts a SPICE ellipse to a center vector and two
#   generating vectors. The selected generating vectors are semi-axes of
#   the ellipse.
#
#-I/O
#
#   Given:
#
#      ellipse   a structure describing a SPICE ellipse. The structure has
#                the fields:
#
#                [1,1] = size(ellipse); struct = class(ellipse)
#
#                The structure has the fields:
#
#                center:    [3,1] = size(center); double = class(center)
#                semiMinor: [3,1] = size(semiMinor); double = class(semiMinor)
#                semiMajor: [3,1] = size(semiMajor); double = class(semiMajor)
#
#   the call:
#
#      [center, semiMajor, semiMinor] = el2cgv( ellipse )
#
#   returns:
#
#      center   the location of the center of 'ellipse'.
#
#               [3,1] = size(center); double = class(center)
#
#      smajor   the semi-major axis of 'ellipse'.
#
#               [3,1] = size(smajor); double = class(smajor)
#
#      sminor   double precision 3x1 array defining the semi-minor
#               axis of 'ellipse'
#
#               [3,1] = size(sminor); double = class(sminor)
#
#               This ellipse is the set of points
#
#                  center + cos(theta) smajor + sin(theta) sminor
#
#                where theta ranges over the interval (-pi, pi].
#
#-Particulars
#
#   SPICE ellipses serve to simplify calling sequences and reduce
#   the chance for error in declaring and describing argument lists
#   involving ellipses.
#
#   The set of ellipse conversion routines is
#
#      cspice_cgv2el( Center and generating vectors to ellipse )
#      el2cgv( Ellipse to center and generating vectors )
#
#   A word about the output of this routine:   the semi-major axis of
#   an ellipse is a vector of largest possible magnitude in the set
#
#      cos(theta) vec1  +  sin(theta) vec2,
#
#   where theta is in the interval (-pi, pi].  There are two such
#   vectors; they are additive inverses of each other. The semi-minor
#   axis is an analogous vector of smallest possible magnitude.  The
#   semi-major and semi-minor axes are orthogonal to each other.  If
#   smajor and sminor are choices of semi-major and semi-minor axes,
#   then the input ellipse can also be represented as the set of
#   points
#
#      center + cos(theta) smajor + sin(theta) sminor
#
#   where theta ranges over the interval (-pi, pi].
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine el2cgv_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # el2cgv
#       (center::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        smajor::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        sminor::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        el2cgv(
            ellipse::NasaSpice.Ellipse) # Ptr{ConstSpiceEllipse}
        
#       enforce input array sizes
#       allocate the output parameters
        center = Array{Float64,1}(3);  # Array_3_SpiceDouble
        center_ptr = pointer(center)
        smajor = Array{Float64,1}(3);  # Array_3_SpiceDouble
        smajor_ptr = pointer(smajor)
        sminor = Array{Float64,1}(3);  # Array_3_SpiceDouble
        sminor_ptr = pointer(sminor)
        
#       make transposed copies of all input arrays and their pointers
        ioellipse = IOBuffer()
        StrPack.pack( ioellipse, ellipse)
        ellipse_ptr = convert( Ptr{Ptr{ConstSpiceEllipse}}, convert( Ptr{Void}, pointer(ioellipse.data) ) )
        
#       ccall((:el2cgv_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceEllipse},Array_3_SpiceDouble,Array_3_SpiceDouble,Array_3_SpiceDouble),ellipse,center,smajor,sminor)
        ccall((:el2cgv_c,libNasaSpice),Void,
            (NasaSpice.Ellipse,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            ellipse,center_ptr,smajor_ptr,sminor_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return center, smajor, sminor
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define two arbitrary, linearly independent vectors
#      % and a center vector.
#      %
#      vec1    = [ 1;  1; 1 ];
#      vec2    = [ 1; -1; 1 ];
#      center  = [ 1;  1; 1 ];
#
#      %
#      % Calculate the semi-major and semi-minor axes of
#      % the ellipse as generated by 'vec1' and 'vec2'.
#      % [The cspice_saelgv call determines the orthogonal axes
#      % of an ellipse from two generating vectors.]
#      %
#      [smajor, sminor ] = cspice_saelgv( vec1, vec2 );
#
#      %
#      % Load the generating vectors into an ellipse structure.
#      %
#      [ ellipse ] = cspice_cgv2el( center, smajor, sminor );
#
#      %
#      % Extract the CSPICE_ELLIPSE structure components into
#      % variable.
#      %
#      [ cent, smaj, smin ] = el2cgv( ellipse )
#
#   MATLAB outputs:
#
#      cent =
#
#           1
#           1
#           1
#
#      smaj =
#
#          1.4142
#         -0.0000
#          1.4142
#
#      smin =
#
#          0.0000
#          1.4142
#          0.0000
#
#-Version
#
#   -Mice Version 1.0.1, 09-NOV-2012, EDW (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 30-DEC-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#    ######  #    #  #      #     #  #    #
#    #       #    #  #            #  ##  ##
#    #####   #    #  #       #####   # ## #
#    #       #    #  #      #        #    #
#    #       #    #  #      #        #    #
#    ######   ####   ###### #######  #    #
#
#   euler angles to matrix
#
################################################################################
#-Abstract
#
#   eul2m constructs a 3x3, double precision rotation matrix
#   from a set of Euler angles and the corresponding rotation axes.
#
#-I/O
#
#   Given:
#
#      angle3
#      angle2
#      angle1    a set of scalar or 1xN arrays of double precision
#                rotation angles measured in radians
#      axis3
#      axis2
#      axis1     the scaler integer indices defining the rotation axis
#                corresponding to each angle
#
#                The values of axisX may be 1, 2, or 3, indicating
#                the x, y, and z axes respectively.
#
#   the call:
#
#      r = eul2m(angle3, angle2, angle1, axis3, axis2, axis1)
#
#   returns:
#
#      r   a 3x3 or 3x3xN array of double precision matrices defined by
#          the Euler rotation scheme, with r defined as:
#
#          r = [ angle3 ]     [ angle2 ]      [ angle1 ]
#                        axis3          axis2           axis1
#
#         'r' return with the same vectorization measure (N) as
#         'angle3', 'angle2', and 'angle1'.
#
#      Note: the rotation defines a coordinate system rotation,
#      e.g. a single rotation of 90 degrees about Z maps
#      the vector [ 1, 0, 0] (the +x unit vector) to [ 0, -1, 0]
#      (the -y unit vector). A vector rotation would map the
#      +x unit vector to the +y unit vector.
#
#-Particulars
#
#   A word about notation:  the symbol
#
#      [ x ]
#           i
#
#   indicates a rotation of x radians about the ith coordinate axis.
#   To be specific, the symbol
#
#      [ x ]
#           1
#
#   indicates a coordinate system rotation of x radians about the
#   first, or x-, axis; the corresponding matrix is
#
#      +-                    -+
#      |  1      0       0    |
#      |                      |
#      |  0    cos(x)  sin(x) |.
#      |                      |
#      |  0   -sin(x)  cos(x) |
#      +-                    -+
#
#   Remember, this is a COORDINATE SYSTEM rotation by x radians; this
#   matrix, when applied to a vector, rotates the vector by -x
#   radians, not x radians.  Applying the matrix to a vector yields
#   the vector's representation relative to the rotated coordinate
#   system.
#
#   The analogous rotation about the second, or y-, axis is
#   represented by
#
#      [ x ]
#           2
#
#   which symbolizes the matrix
#
#      +-                    -+
#      | cos(x)   0   -sin(x) |
#      |                      |
#      |  0       1      0    |,
#      |                      |
#      | sin(x)   0    cos(x) |
#      +-                    -+
#
#   and the analogous rotation about the third, or z-, axis is
#   represented by
#
#      [ x ]
#           3
#
#   which symbolizes the matrix
#
#      +-                    -+
#      |  cos(x)  sin(x)   0  |
#      |                      |
#      | -sin(x)  cos(x)   0  |.
#      |                      |
#      |  0        0       1  |
#      +-                    -+
#
#   From time to time, (depending on one's line of work, perhaps) one
#   may happen upon a pair of coordinate systems related by a
#   sequence of rotations.  For example, the coordinate system
#   defined by an instrument such as a camera is sometime specified
#   by RA, DEC, and twist; if alpha, delta, and phi are the rotation
#   angles, then the series of rotations
#
#      [ phi ]     [ pi/2  -  delta ]     [ alpha ]
#             3                      2             3
#
#   produces a transformation from inertial to camera coordinates.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine eul2m_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # eul2m
#       (r::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        eul2m(
            angle3::Float64, # SpiceDouble
            angle2::Float64, # SpiceDouble
            angle1::Float64, # SpiceDouble
            axis3::Int32, # SpiceInt
            axis2::Int32, # SpiceInt
            axis1::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        r = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        r_ptr = pointer(r)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:eul2m_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,SpiceInt,SpiceInt,SpiceInt,Array_3_Array_3_SpiceDouble),angle3,angle2,angle1,axis3,axis2,axis1,r)
        ccall((:eul2m_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Int32,Int32,Int32,Ptr{Float64}),
            angle3,angle2,angle1,axis3,axis2,axis1,r_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Create the rotation matrix for a single coordinate
#      % rotation of 90 degrees about the Z axis. As the
#      % second and third angles are 0, the final two axes IDs,
#      % 1, 1, have no effect for in this example.
#      %
#      rot = eul2m( cspice_halfpi, 0, 0, 3, 1, 1 );
#
#      %
#      % Output the result of rotating the +x unit vector
#      % using the 'rot' matrix.
#      %
#      rot * [1; 0; 0 ]
#
#   MATLAB outputs:
#
#      ans =
#
#          0.0000
#         -1.0000
#               0
#
#   A representation of the -y unit vector to round-off error accuracy.
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#    ######  #    #  #      #     #  #    #  ######
#    #       #    #  #            #   #  #   #
#    #####   #    #  #       #####     ##    #####
#    #       #    #  #      #          ##    #
#    #       #    #  #      #         #  #   #
#    ######   ####   ###### #######  #    #  #
#
#   State transformation from Euler angles and derivatives
#
################################################################################
#-Abstract
#
#   eul2xf computes a state transformation from an Euler angle
#   factorization of a rotation and the derivatives of those Euler
#   angles.
#
#-I/O
#
#   Given:
#
#       eulang   the double precision 6x1 or double precision 6xN
#                array of Euler angles corresponding to the
#                specified factorization
#
#                If we represent r as shown here:
#
#                   r =  [ alpha ]     [ beta ]     [ gamma ]
#                                 axisa        axisb         axisc
#
#                then (6x1)
#
#                  eulang[1] = alpha
#                  eulang[2] = beta
#                  eulang[3] = gamma
#                  eulang[4] = dalpha/dt
#                  eulang[5] = dbeta/dt
#                  eulang[6] = dgamma/dt
#
#                or (6xN)
#
#                  eulang[:,N] = alpha_N
#                  eulang[:,N] = beta_N
#                  eulang[:,N] = gamma_N
#                  eulang[:,N] = dalpha_N/dt
#                  eulang[:,N] = dbeta_N/dt
#                  eulang[:,N] = dgamma_N/dt
#
#      axisa
#      axisb
#      axisc     the scalar integers defining the axes desired for the
#                factorization of "r". All must be in the range from 1 to 3.
#
#                Every rotation matrix can be represented as a product
#                of three rotation matrices about the principal axes
#                of a reference frame.
#
#                   r =  [ alpha ]     [ beta ]     [ gamma ]
#                                 axisa        axisb         axisc
#
#                The value 1 corresponds to the X axis.
#                The value 2 corresponds to the Y axis.
#                The value 3 corresponds to the Z axis.
#
#   the call:
#
#      xform = eul2xf(eulang, axisa, axisb, axisc)
#
#   returns:
#
#      xform   a double precision 6x6 or double precision 6x6xN
#              array of a state transformation matrices corresponding to
#              'r' as described above
#
#              'xform'  returns with the same vectorization
#              measure (N) as 'eulang'.
#
#-Particulars
#
#   This function is intended to provide an inverse for the function
#   cspice_xf2eul.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine eul2xf_c.
#
#   MICE.REQ
#
    function # eul2xf
#       (xform::Array{Float64,2}(6,6)) =   # Array_6_Array_6_SpiceDouble
        eul2xf(
            eulang::Array{Float64,1}, # Array_6_ConstSpiceDouble
            axisa::Int32, # SpiceInt
            axisb::Int32, # SpiceInt
            axisc::Int32) # SpiceInt
        
#       enforce input array sizes
        if length(eulang) != 6
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        xform = Array{Float64,2}(6,6);  # Array_6_Array_6_SpiceDouble
        xform_ptr = pointer(xform)
        
#       make transposed copies of all input arrays and their pointers
        eulang_t = eulang'
        eulang_ptr = pointer(eulang_t)
        
#       ccall((:eul2xf_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,SpiceInt,SpiceInt,SpiceInt,Array_6_Array_6_SpiceDouble),eulang,axisa,axisb,axisc,xform)
        ccall((:eul2xf_c,libNasaSpice),Void,
            (Ptr{Float64},Int32,Int32,Int32,Ptr{Float64}),
            eulang_ptr,axisa,axisb,axisc,xform_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return xform'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Suppose you have a set of Euler angles and their derivatives
#      % for a 3 1 3 rotation, and that you would like to determine
#      % the equivalent angles and derivatives for a 1 2 3 rotation.
#      %
#      % r = [alpha]  [beta]  [gamma]
#      %           3       1        3
#      %
#      % r = [roll]  [pitch]  [yaw]
#      %           1        2      3
#      %
#      % The following code fragment will perform the desired computation.
#      %
#      abgang = [0.01; 0.03; 0.09; -0.001; -0.003; -0.009 ];
#
#      xform              = eul2xf( abgang, 3, 1, 3 );
#      [ rpyang, unique ] = cspice_xf2eul( xform , 1, 2, 3 );
#
#      if( unique )
#         disp( '1-2-3 equivalent rotation to input (radians):')
#         fprintf( 'Roll  %12.6f, dRoll/dt  %12.6f\n', rpyang(1), rpyang(4) )
#         fprintf( 'Pitch %12.6f, dPitch/dt %12.6f\n', rpyang(2), rpyang(5) )
#         fprintf( 'Yaw   %12.6f, dYaw/dt   %12.6f\n', rpyang(3), rpyang(6) )
#      else
#         disp( 'The values in ''rpyang'' not uniquely determined.' )
#      end
#
#   MATLAB outputs:
#
#      1-2-3 equivalent rotation to input (radians):
#      Roll      0.029999, dRoll/dt     -0.003000
#      Pitch    -0.000300, dPitch/dt     0.000060
#      Yaw       0.099996, dYaw/dt      -0.009999
#
#-Version
#
#   -Mice Version 1.0.2, 29-FEB-2012, EDW (JPL)
#
#      Edit to "Usage" string. "xform(3,3)" corrected to read
#      "xform(6,6)."
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 02-APR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######   ####   #    #  #####     ##     #   #
#    #       #    #  #    #  #    #   #  #     # #
#    #####   #    #  #    #  #    #  #    #     #
#    #       #    #  #    #  #####   ######     #
#    #       #    #   #  #   #   #   #    #     #
#    #        ####     ##    #    #  #    #     #
#
#   Ray in instrument FOV at specified time
#   Ray in instrument field_of_view at specified time
#
################################################################################
#-Abstract
#
#   fovray determines if a specified ray is within the field-of-view
#   (FOV) of a specified instrument at a given time.
#
#-I/O
#
#   Given:
#
#      Parameters-
#
#      SPICE_GF_MAXVRT     is the maximum number of vertices that may be used
#                          to define the boundary of the specified instrument's
#                          field of view. See SpiceGF.h for more details.
#
#      MARGIN              is a small positive number used to constrain the
#                          orientation of the boundary vectors of polygonal
#                          FOVs. Such FOVs must satisfy the following
#                          constraints:
#
#                          1)  The boundary vectors must be contained within
#                              a right circular cone of angular radius less
#                              than than (pi/2) - MARGIN radians; in
#                              other words, there must be a vector A such that
#                              all boundary vectors have angular separation
#                              from A of less than (pi/2)-MARGIN radians.
#
#                          2)  There must be a pair of boundary vectors U, V
#                              such that all other boundary vectors lie in
#                              the same half space bounded by the plane
#                              containing U and V. Furthermore, all other
#                              boundary vectors must have orthogonal
#                              projections onto a specific plane normal to
#                              this plane (the normal plane contains the angle
#                              bisector defined by U and V) such that the
#                              projections have angular separation of at least
#                              2*MARGIN radians from the plane spanned
#                              by U and V.
#
#                          MARGIN is currently set to 1.D-6.
#
#      Arguments-
#
#      inst     indicates the name of an instrument, such as a
#               spacecraft-mounted framing camera. The field of view
#               (FOV) of the instrument will be used to determine if
#               the direction from the observer to a target,
#               represented as a ray, is visible with respect to the
#               instrument.
#
#               [1,a] = size(inst), char = class(inst)
#
#               The position of the instrument is considered to
#               coincide with that of the ephemeris object 'obsrvr' (see
#               description below).
#
#               The size of the instrument's FOV is constrained by the
#               following: There must be a vector A such that all of
#               the instrument's FOV boundary vectors have an angular
#               separation from A of less than (pi/2)-MARGIN radians
#               (see description above). For FOVs that are circular or
#               elliptical, the vector A is the boresight. For FOVs
#               that are rectangular or polygonal, the vector A is
#               calculated.
#
#               See the header of the CSPICE routine getfov_c for a
#               description of the required parameters associated with
#               an instrument.
#
#               Both object names and NAIF IDs are accepted. For
#               example, both 'CASSINI_ISS_NAC' and '-82360' are
#               accepted. Case and leading or trailing blanks are not
#               significant in the string.
#
#      raydir   is the direction vector defining a ray of interest.
#               The ray emanates from the location of the ephemeris
#               object designated by the input argument 'obsrvr' and
#               is expressed relative to the reference frame designated
#               by 'rframe' (see description below).
#
#               [3,1] = size(raydir), double = class(raydir)
#
#      rframe   is the name of the reference frame associated with
#               the input ray's direction vector 'raydir'. Note:
#               'rframe' does not need to be the instrument's reference
#               frame.
#
#               [1,b] = size(rframe), char = class(rframe)
#
#               Since light time corrections are not supported for
#               rays, the orientation of the frame is always evaluated
#               at the epoch associated with the observer, as opposed
#               to the epoch associated with the light-time corrected
#               position of the frame center.
#
#      abcorr   indicates the aberration corrections to be applied
#               when computing the target's position and orientation.
#
#               [1,c] = size(abcorr), char = class(abcorr)
#
#               The supported aberration correction options are:
#
#                 'NONE'          No correction.
#                 'S'             Stellar aberration correction,
#                                 reception case.
#                 'XS'            Stellar aberration correction,
#                                 transmission case.
#
#               For detailed information, see the geometry finder
#               required reading, gf.req.
#
#               Case, leading and trailing blanks are not significant
#               in the string.
#
#      obsrvr   is the name of the body from which the target
#               represented by 'raydir' is observed. The instrument
#               is treated as if it were co-located with the observer.
#
#               [1,d] = size(obsrvr), char = class(obsrvr)
#
#               Both object names and NAIF IDs are accepted. For
#               example, both 'CASSINI' and '-82' are accepted. Case and
#               leading or trailing blanks are not significant in the
#               string.
#
#      et       is the observation time in seconds past the J2000
#               epoch.
#
#               [1,n] = size(et), double = class(et)
#
#   the call:
#
#
#       visibl = fovray ( inst, raydir,   rframe, ...
#                                abcorr,     obsrvr, et )
#
#   returns:
#
#       visibl  is true if the ray is "visible", or in the
#               field-of-view, of the instrument at the time 'et'.
#               Otherwise, 'visibl' is false.
#
#               [1,n] = size(visibl), logical = class(visibl)
#
#-Particulars
#
#   To treat the target as an ephemeris object rather than a ray, use
#   the higher-level Mice routine cspice_fovtrg. cspice_fovtrg may be used to
#   determine if ephemeris objects such as Saturn are visible in an
#   instrument's FOV at a given time.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine fovray_c.
#
    function # fovray
        fovray(
            inst::AbstractString, # Ptr{ConstSpiceChar}
            raydir::Array{Float64,1}, # Array_3_ConstSpiceDouble
            rframe::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64) # Ptr{SpiceDouble}
        
#       enforce input array sizes
        if length(raydir) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        raydir_t = raydir'
        raydir_ptr = pointer(raydir_t)
        
#       ccall((:fovray_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Array_3_ConstSpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{SpiceDouble},Ptr{SpiceBoolean}),inst,raydir,rframe,abcorr,obsrvr,et,visible)
        ccall((:fovray_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Float64},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Float64),
            inst,raydir_ptr,rframe,abcorr,obsrvr,et)
    
#       unpack any structures and transpose back any returned arrays
        return 
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#   Example(1):
#
#      The Cassini Ultraviolet Imaging Spectrograph (UVIS)
#      has been used to measure variations in starlight as
#      rings and moons occult Cassini's view of the stars.
#      One of these events happened at 2008-054T21:31:55.158 UTC.
#      Let's verify that Epsilon CMa (Adhara) was in the
#      Cassini UVIS field-of-view at the observation time.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: fovray_ex.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                      Contents
#            ---------                      --------
#            naif0010.tls                   Leapseconds
#            cpck26Jan2007.tpc              Satellite orientation and
#                                           radii
#            cas00145.tsc                   Cassini SCLK
#            cas_v40.tf                     Cassini frames
#            cas_uvis_v06.ti                Cassini UVIS instrument
#            080428R_SCPSE_08045_08067.bsp  Merged spacecraft,
#                                           planetary, and satellite
#                                           ephemeris
#            08052_08057ra.bc               Orientation for Cassini
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'naif0010.tls'
#                                'cpck26Jan2007.tpc'
#                                'cas00145.tsc'
#                                'cas_v40.tf'
#                                'cas_uvis_v06.ti'
#                                '080428R_SCPSE_08045_08067.bsp'
#                                '08052_08057ra.bc')
#
#         \begintext
#
#         End of meta-kernel
#
#       Example program starts here.
#
#         %
#         %   Load the meta kernel.
#         %
#         cspice_furnsh ( 'fovray_ex.tm' );
#
#         %
#         %   Convert the observation time to 'et'.
#         %
#         et = cspice_str2et ( '2008-054T21:31:55.158' );
#
#         %
#         %   The variables 'right_asc' and 'dec' are the right ascension
#         %   and declination of Epsilon CMa in degrees.
#         %
#         right_asc = 104.656;
#         dec       = -28.972;
#
#         %
#         %   Create a unit direction vector pointing from Cassini
#         %   to the specified star. For details on corrections such
#         %   as parallax, please see the example in cspice_gfrfov.
#         %
#
#         raydir = cspice_radrec ( 1, right_asc*cspice_rpd, dec*cspice_rpd );
#
#         %
#         %   Is the star in the field-of-view of Cassini's UVIS?
#         %
#         visible = fovray ( 'CASSINI_UVIS_FUV_OCC', raydir, ...
#                                   'J2000', 's', 'cassini', et );
#
#         %
#         %   Put the time in a specified format for output and
#         %   report the result.
#         %
#         time_output = cspice_timout ( et, ...
#                                 'YYYY-MON-DD HR:MN:SC.###::TDB (TDB)' );
#
#         if ( visible )
#             fprintf ( 'Epsilon CMa was visible from the Cassini\n' );
#             fprintf ( 'UVIS instrument at %s\n', time_output );
#         end
#
#         %
#         %   Unload kernels.
#         %
#         cspice_kclear
#
#   MATLAB outputs:
#
#         Epsilon CMa was visible from the Cassini
#         UVIS instrument at 2008-FEB-23 21:33:00.343 (TDB)
#
#-Version
#
#   -Mice Version 1.0.0, 13-NOV-2013, SCK (JPL), EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######   ####   #    #   #####  #####    ####
#    #       #    #  #    #     #    #    #  #    #
#    #####   #    #  #    #     #    #    #  #
#    #       #    #  #    #     #    #####   #  ###
#    #       #    #   #  #      #    #   #   #    #
#    #        ####     ##       #    #    #   ####
#
#   Target in instrument FOV at specified time
#   Target in instrument field_of_view at specified time
#
#
################################################################################
#-Abstract
#
#   fovtrg determines if a specified ephemeris object is within
#   the field-of-view (FOV) of a specified instrument at a given time.
#
#-I/O
#
#   Given:s
#
#      Parameters-
#
#      SPICE_GF_MAXVRT     is the maximum number of vertices that may be used
#                          to define the boundary of the specified instrument's
#                          field of view. See SpiceGF.h for more details.
#
#      MARGIN              is a small positive number used to constrain the
#                          orientation of the boundary vectors of polygonal
#                          FOVs. Such FOVs must satisfy the following
#                          constraints:
#
#                          1)  The boundary vectors must be contained within
#                              a right circular cone of angular radius less
#                              than than (pi/2) - MARGIN radians; in
#                              other words, there must be a vector A such that
#                              all boundary vectors have angular separation
#                              from A of less than (pi/2)-MARGIN radians.
#
#                          2)  There must be a pair of boundary vectors U, V
#                              such that all other boundary vectors lie in
#                              the same half space bounded by the plane
#                              containing U and V. Furthermore, all other
#                              boundary vectors must have orthogonal
#                              projections onto a specific plane normal to
#                              this plane (the normal plane contains the angle
#                              bisector defined by U and V) such that the
#                              projections have angular separation of at least
#                              2*MARGIN radians from the plane spanned
#                              by U and V.
#
#                          MARGIN is currently set to 1.D-6.
#
#      Arguments-
#
#      instrument    indicates the name of an instrument, such as a
#                    spacecraft-mounted framing camera. The field of view
#                    (FOV) of the instrument will be used to determine if
#                    the target is visible with respect to the instrument.
#
#                    [1,a] = size(instrument), char = class(instrument)
#
#                    The position of the instrument is considered to
#                    coincide with that of the ephemeris object 'observer' (see
#                    description below).
#
#                    The size of the instrument's FOV is constrained by the
#                    following: There must be a vector A such that all of
#                    the instrument's FOV boundary vectors have an angular
#                    separation from A of less than (pi/2)-MARGIN radians
#                    (see description above). For FOVs that are circular or
#                    elliptical, the vector A is the boresight. For FOVs
#                    that are rectangular or polygonal, the vector A is
#                    calculated.
#
#                    See the header of the CSPICE routine getfov_c for a
#                    description of the required parameters associated with
#                    an instrument.
#
#                    Both object names and NAIF IDs are accepted. For
#                    example, both 'CASSINI_ISS_NAC' and '-82360' are
#                    accepted. Case and leading or trailing blanks are not
#                    significant in the string.
#
#      target        is the name of the target body. This routine determines
#                    if the target body appears in the instrument's field of
#                    view.
#
#                    [1,b] = size(target), char = class(target)
#
#                    Both object names and NAIF IDs are accepted. For
#                    example, both 'Moon' and '301' are accepted. Case and
#                    leading or trailing blanks are not significant in the
#                    string.
#
#      target_shape  is a string indicating the geometric model used to
#                    represent the shape of the target body.
#
#                    [1,c] = size(target_shape), char = class(target_shape)
#
#                    The supported options are:
#
#                       'ELLIPSOID'     Use a triaxial ellipsoid model,
#                                       with radius values provided via the
#                                       kernel pool. A kernel variable
#                                       having a name of the form
#
#                                          'BODYnnn_RADII'
#
#                                       where nnn represents the NAIF
#                                       integer code associated with the
#                                       body, must be present in the kernel
#                                       pool. This variable must be
#                                       associated with three numeric
#                                       values giving the lengths of the
#                                       ellipsoid's X, Y, and Z semi-axes.
#
#                       'POINT'         Treat the body as a single point.
#
#                    Case and leading or trailing blanks are not
#                    significant in the string.
#
#      target_frame  is the name of the body-fixed, body-centered reference
#                    frame associated with the target body. Examples of
#                    such names are 'IAU_SATURN' (for Saturn) and 'ITRF93'
#                    (for the Earth).
#
#                    [1,d] = size(target_frame), char = class(target_frame)
#
#                    If the target body is modeled as a point, 'target_frame'
#                    is ignored and should be left blank. (Ex: ' ').
#
#                    Case and leading or trailing blanks bracketing a
#                    non-blank frame name are not significant in the string.
#
#      abcorr        indicates the aberration corrections to be applied
#                    when computing the target's position and orientation.
#
#                    [1,e] = size(abcorr), char = class(abcorr)
#
#                    For remote sensing applications, where the apparent
#                    position and orientation of the target seen by the
#                    observer are desired, normally either of the
#                    corrections:
#
#                        'LT+S'
#                        'CN+S'
#
#                    should be used. These and the other supported options
#                    are described below.
#
#                    Supported aberration correction options for
#                    observation (the case where radiation is received by
#                    observer at 'et') are:
#
#                        'NONE'         No correction.
#                        'LT'           Light time only
#                        'LT+S'         Light time and stellar aberration.
#                        'CN'           Converged Newtonian (CN) light time.
#                        'CN+S'         CN light time and stellar aberration.
#
#                    Supported aberration correction options for
#                    transmission (the case where radiation is emitted from
#                    observer at 'et') are:
#
#                        'XLT'          Light time only.
#                        'XLT+S'        Light time and stellar aberration.
#                        'XCN'          Converged Newtonian (CN) light time.
#                        'XCN+S'        CN light time and stellar aberration.
#
#                    Case, leading and trailing blanks are not significant
#                    in the string.
#
#      observer      is the name of the body from which the target is
#                    observed. The instrument 'instrument' is treated as if it
#                    were co-located with the observer.
#
#                    [1,f] = size(observer), char = class(observer)
#
#                    Both object names and NAIF IDs are accepted. For
#                    example, both 'CASSINI' and '-82' are accepted. Case and
#                    leading or trailing blanks are not significant in the
#                    string.
#
#      et            is the observation time in seconds past the J2000
#                    epoch.
#
#                    [1,n] = size(et), double = class(et)
#
#   the call:
#
#       visibl = fovtrg ( instrument,   target, target_shape, ...
#                                target_frame, abcorr, observer, et )
#
#   returns:
#
#       visibl       is true if 'target' is fully or partially in the
#                    field-of-view of 'instrument' at the time 'et'. Otherwise,
#                    'visibl' is false.
#
#                    [1,n] = size(visibl), logical = class(visibl)
#
#-Particulars
#
#   To treat the target as a ray rather than as an ephemeris object,
#   use the higher-level Mice routine cspice_fovray. cspice_fovray may be used
#   to determine if distant target objects such as stars are visible
#   in an instrument's FOV at a given time, as long as the direction
#   from the observer to the target can be modeled as a ray.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine fovtrg_c.
#
#   MICE.REQ
#   DAF.REQ
#
    function # fovtrg
        fovtrg(
            inst::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            tshape::AbstractString, # Ptr{ConstSpiceChar}
            tframe::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64) # Ptr{SpiceDouble}
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:fovtrg_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{SpiceDouble},Ptr{SpiceBoolean}),inst,target,tshape,tframe,abcorr,obsrvr,et,visible)
        ccall((:fovtrg_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Float64),
            inst,target,tshape,tframe,abcorr,obsrvr,et)
    
#       unpack any structures and transpose back any returned arrays
        return 
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#   Example(1):
#
#      A spectacular picture was taken by Cassini's
#      narrow-angle camera on Oct. 6, 2010 that shows
#      six of Saturn's moons. Let's verify that the moons
#      in the picture are Epimetheus, Atlas, Daphnis, Pan,
#      Janus, and Enceladus.
#
#      To see this picture, visit:
#      http://photojournal.jpl.nasa.gov/catalog/PIA12741
#      or go to the PDS Image Node's Image Atlas at
#      http://pds-imaging.jpl.nasa.gov/search/search.html.
#      Select Cassini as the mission, ISS as the instrument,
#      and enter 1_N1665078907.122 as the Product ID in the
#      Product tab. Note: these directions may change as the
#      PDS Imaging Node changes.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels. For project meta-kernels similar to the one shown
#      below, please see the PDS section of the NAIF FTP server.
#      For example, look at the following path for Cassini
#      meta-kernels: ftp://naif.jpl.nasa.gov//pub/naif/pds/data/
#      co-s_j_e_v-spice-6-v1.0/cosp_1000/extras/mk
#
#         KPL/MK
#
#         File name: fovtrg_ex.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            naif0010.tls                  Leapseconds
#            cpck*.tpc                     Satellite orientation and
#                                          radii
#            pck00010.tpc                  Planet orientation and
#                                          radii
#            cas_rocks_v18.tf              FK for small satellites
#                                          around Saturn
#            cas_v40.tf                    Cassini FK
#            cas_iss_v10.ti                Cassini ISS IK
#            cas00149.tsc                  Cassini SCLK
#            *.bsp                         Ephemeris for Cassini,
#                                          planets, and satellites
#            10279_10284ra.bc              Orientation for Cassini
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'naif0010.tls'
#                                'cpck14Oct2010.tpc'
#                                'cpck_rock_21Jan2011_merged.tpc'
#                                'pck00010.tpc'
#                                'cas_rocks_v18.tf'
#                                'cas_v40.tf'
#                                'cas_iss_v10.ti'
#                                'cas00149.tsc'
#                                '110317AP_RE_90165_18018.bsp'
#                                '110120BP_IRRE_00256_25017.bsp'
#                                '101210R_SCPSE_10256_10302.bsp'
#                                '10279_10284ra.bc'              )
#
#         \begintext
#
#         End of meta-kernel
#
#       Example program starts here.
#
#         %
#         %   Load the meta kernel.
#         %
#         cspice_furnsh ( 'fovtrg_ex.tm' );
#
#         %
#         %   Retrieve Cassini's NAIF ID.
#         %
#         [cassini_id, found] = cspice_bodn2c ( 'cassini' );
#
#         if (~found)
#             fprintf ( 'Could not find ID code for Cassini.' );
#             return
#         end
#
#         %
#         %   Convert the image tag SCLK to ET.
#         %
#         et = cspice_scs2e ( cassini_id, '1665078907.122' );
#
#         %
#         %   Convert the ET to a string format for the output.
#         %
#         time_format = 'YYYY-MON-DD HR:MN:SC.###::TDB (TDB)';
#         time = cspice_timout ( et, time_format );
#
#         %
#         %   Search through all of Saturn's moons to see if each
#         %   satellite was in the ISS NAC's field-of-view at
#         %   the image time. We're going to take advantage of the
#         %   fact that all Saturn's moons have a NAIF ID of 6xx.
#         %
#         fprintf ( 'At time %s the following were\n', time     );
#         fprintf ( 'in the field of view of CASSINI_ISS_NAC\n' );
#         for body_id = 600:699
#             %
#             %   Check to see if the 'body_id' has a translation.
#             %
#             [body, found] = cspice_bodc2n ( body_id );
#
#             if (found)
#                 %
#                 %   Check to see if a body-fixed frame for this ID exists.
#                 %   If the frame is not in the kernel pool, we cannot
#                 %   perform the visibility test. The main cause of a
#                 %   failure is a missing kernel.
#                 %
#                 [frame_code, frame_name, found] = cspice_cidfrm ( body_id );
#
#                 if (found)
#                     %
#                     %   Is this body in the field-of-view of Cassini's
#                     %   ISS narrow-angle camera?
#                     %
#                     visibl = fovtrg ( 'cassini_iss_nac', body, ...
#                                     'ellipsoid', frame_name, 'cn+s', ...
#                                     'cassini', et );
#                     if ( visibl )
#                         fprintf ( '  %s\n', body);
#                     end
#                 end
#             end
#         end
#         %
#         %   Unload the kernels.
#         %
#         cspice_kclear
#
#   MATLAB outputs:
#
#         At time 2010-OCT-06 17:09:45.346 (TDB) the following were
#         in the field of view of CASSINI_ISS_NAC
#           ENCELADUS
#           JANUS
#           EPIMETHEUS
#           ATLAS
#           PAN
#           DAPHNIS
#           ANTHE
#
#         Note: there were actually 7 of Saturn's satellites in the
#         field-of-view of Cassini's narrow-angle camera. However, Anthe
#         is very small and was probably obscured by other objects or
#         shadow.
#
#-Version
#
#   -Mice Version 1.0.0, 16-FEB-2012, SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
#   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
#   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
#   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
#   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
#   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
#   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
#   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
#   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
#   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
#   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
#   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #####      #    #    #  ######   ####
#    #       #    #     #    ##   #  #       #    #
#    #####   #    #     #    # #  #  #####   #    #
#    #       #####      #    #  # #  #       #    #
#    #       #   #      #    #   ##  #       #    #
#    #       #    #     #    #    #  #        ####
#
#   fetch reference frame attributes
#
################################################################################
#-Abstract
#
#   frinfo retrieves the minimal attributes associated with a
#   frame needed for converting transformations to and from it.
#
#-I/O
#
#   Given:
#
#     frcode   a SPICE ID for some reference frame.
#
#              [1,n] = size(frcode); int32 = class(frcode)
#
#   the call:
#
#      [cent, clss, clssid, found] = frinfo( frcode )
#
#   returns:
#
#      cent     the SPICE body ID for the center of the reference frame
#               (if such an ID is appropriate).
#
#               [1,n] = size(cent); int32 = class(cent)
#
#      clss     the class ID or type of the frame. This identifies which
#               subsystem will perform frame transformations.
#
#               [1,n] = size(clss); int32 = class(clss)
#
#      clssid   the ID used for the frame within its class. This may be
#               different from the frame ID.
#
#               [1,n] = size(clssid); int32 = class(clssid)
#
#      found    flag returning true if 'cent', 'frclss' and 'frcode' are
#               available, false if not.
#
#               [1,n] = size(found); logical = class(found)
#
#               'cent', 'clss', 'clssid' and 'found' return with the same
#               vectorization measure (N) as 'frcode'.
#
#-Particulars
#
#   This is a low level routine needed by state transformation
#   software to transform states and attitudes between different
#   reference frames.
#
#   The routine first examines local "hard-coded" information about
#   reference frames to see if the requested frame belongs to this
#   set.  If it does that information is returned.
#
#   If the requested information is not stored locally, the routine
#   then examines the kernel pool to see if the requested information
#   is stored there.  If it is and has the expected format, the data
#   is retrieved and returned.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine frinfo_c.
#
#   MICE.REQ
#   FRAMES.REQ
#
    function # frinfo
#       (cent::Int32,  # Ptr{SpiceInt}
#        clss::Int32,  # Ptr{SpiceInt}
#        clssid::Int32,  # Ptr{SpiceInt}
#        found::Int32) =   # Ptr{SpiceBoolean}
        frinfo(
            frcode::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        cent = Array{Int32}(1);  # Ptr{SpiceInt}
        cent_ptr = pointer(cent)
        clss = Array{Int32}(1);  # Ptr{SpiceInt}
        clss_ptr = pointer(clss)
        clssid = Array{Int32}(1);  # Ptr{SpiceInt}
        clssid_ptr = pointer(clssid)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:frinfo_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,Ptr{SpiceInt},Ptr{SpiceInt},Ptr{SpiceInt},Ptr{SpiceBoolean}),frcode,cent,clss,clssid,found)
        ccall((:frinfo_c,libNasaSpice),Void,
            (Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32}),
            frcode,cent_ptr,clss_ptr,clssid_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return cent[1], clss[1], clssid[1], convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Retrieve frame information for a scalar 'code'.
#      %
#      disp('Scalar' )
#      code = 13000;
#
#      [cent, clss, clssid, found] = frinfo( code );
#      fprintf(' code   center  class  class_ID  found\n' );
#      fprintf( '%d    %d      %d     %d        %d\n', ...
#               code, cent, clss, clssid, int32(found) );
#
#      %
#      % Retrieve frame information for a vector of 'codes'.
#      %
#      disp('Vector' )
#      codes = [1:5];
#
#      [cent, clss, clssid, found] = frinfo( codes );
#
#      fprintf( 'code center class class_ID found\n')
#      fprintf( '%d    %d      %d     %d        %d\n', ...
#             [codes; cent; clss; clssid; int32(found) ] );
#
#   MATLAB outputs:
#
#      Scalar
#       code   center  class  class_ID  found
#      13000    399      2     3000        1
#
#      Vector
#      code center class class_ID found
#      1    0      1     1        1
#      2    0      1     2        1
#      3    0      1     3        1
#      4    0      1     4        1
#      5    0      1     5        1
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    ######  #    #  #####   #    #   ####   #    #
#    #       #    #  #    #  ##   #  #       #    #
#    #####   #    #  #    #  # #  #   ####   ######
#    #       #    #  #####   #  # #       #  #    #
#    #       #    #  #   #   #   ##  #    #  #    #
#    #        ####   #    #  #    #   ####   #    #
#
#   Load SPICE data from a list of items
#
################################################################################
#-Abstract
#
#   furnsh loads SPICE kernel files into MATLAB.
#
#-I/O
#
#   Given:
#
#      file   the name of a SPICE kernel file. The file may be either binary
#             or text. If the file is a binary SPICE kernel it will
#             be loaded into the appropriate SPICE subsystem.  If
#             'file' is a SPICE text kernel it will be loaded into the
#             kernel pool. If 'file' is a SPICE meta-kernel containing
#             initialization instructions (through use of the
#             correct kernel pool variables), the files specified in
#             those variables will be loaded into the appropriate
#             SPICE subsystem.
#
#             The SPICE text kernel format supports association of
#             names and data values using a "keyword = value"
#             format. The keyword-value pairs thus defined are
#             called "kernel variables."
#
#             While any information can be placed in a text kernel
#             file, the following string valued kernel variables are
#             recognized by SPICE as meta-kernel keywords:
#
#                  KERNELS_TO_LOAD
#                  PATH_SYMBOLS
#                  PATH_VALUES
#
#             Each kernel variable is discussed below.
#
#             KERNELS_TO_LOAD   is a list of SPICE kernels to be
#                               loaded into a program.  If file
#                               names do not fit within the kernel
#                               pool 80 character limit, they may be
#                               continued to subsequent array
#                               elements by placing the continuation
#                               character ('+') at the end of an
#                               element and then placing the
#                               remainder of the file name in the
#                               next array element.  (See the
#                               examples below for an illustration
#                               of this technique or consult the
#                               routine STPOOL for further details.)
#
#                               You may use one or more PATH_SYMBOL
#                               assignments (see below) to specify
#                               strings to be substituted for some
#                               part of a file name.
#
#             PATH_SYMBOLS      is a list of strings (without
#                               embedded blanks) which if
#                               encountered following the '$'
#                               character will be replaced with the
#                               corresponding PATH_VALUES string.
#                               Note that PATH_SYMBOLS are
#                               interpreted only in values
#                               associated with the KERNELS_TO_LOAD
#                               variable. There must be a one-to-one
#                               correspondence between the values
#                               supplied for PATH_SYMBOLS and
#                               PATH_VALUES. For the purpose of
#                               determining this correspondence, any
#                               path value that is continued over
#                               multiple array elements counts as a
#                               single value.
#
#             PATH_VALUES       is a list of expansions to use when
#                               PATH_SYMBOLS are encountered. If
#                               path values do not fit within the
#                               kernel pool 80 character limit, they
#                               may be continued in the same way as
#                               file names (see the KERNELS_TO_LOAD
#                               description above).
#
#             These kernel pool variables persist within the kernel
#             pool only until all kernels associated with the
#             variable KERNELS_TO_LOAD have been loaded.  Once all
#             specified kernels have been loaded, the variables
#             KERNELS_TO_LOAD, PATH_SYMBOLS and PATH_VALUES are
#             removed from the kernel pool.
#
#             [n,m] = size(file); char = class(file)
#
#                or
#
#             [1,n] = size(file); cell = class(file)
#
#   the call:
#
#      furnsh( file )
#
#   loads 'file' into the SPICE kernel system.
#
#-Particulars
#
#   Text kernels input to this routine need not have native line
#   terminators for the platform. Lower level CSPICE routines can
#   read and process non-native text files. This functionality does
#   not exist in the FORTRAN SPICELIB.
#
#   Kernel pool variable names are restricted to a length of 32
#   characters or less.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine furnsh_c.
#
#   MICE.REQ
#   KERNEL.REQ
#
    function # furnsh
#       (file::AbstractString) =   # Ptr{ConstSpiceChar}
        furnsh()
        
#       enforce input array sizes
#       allocate the output parameters
        file = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        file_ptr = pointer(file)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:furnsh_c,"/home/don/.julia/v0.3/cspice"),Void,(Ptr{ConstSpiceChar},),file)
        ccall((:furnsh_c,libNasaSpice),Void,
            (Ptr{AbstractString},),
            file_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return file[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#     Example 1
#     ---------
#
#     Load the leapseconds kernel naif0010.tls and the planetary
#     ephemeris SPK file de405s.bsp.
#
#        furnsh( 'naif0010.tls' )
#        furnsh( 'de405s.bsp' )
#
#     Load a vector of kernel names or a cell of kernel names.
#
#        furnsh( { 'naif0008.tls', 'de405s.bsp' } )
#
#     Example 2
#     ---------
#
#     This example illustrates how you could create a meta-kernel file
#     for a program that requires several text and binary kernels.
#
#     First create a list of the kernels you need in a text file as
#     shown below.
#
#        \begintext
#
#           Here are the SPICE kernels required for my application
#           program.
#
#           Note that kernels are loaded in the order listed. Thus we
#           need to list the highest priority kernel last.
#
#
#        \begindata
#
#        KERNELS_TO_LOAD = (
#
#              '/home/mydir/kernels/spk/lowest_priority.bsp',
#              '/home/mydir/kernels/spk/next_priority.bsp',
#              '/home/mydir/kernels/spk/highest_priority.bsp',
#              '/home/mydir/kernels/text/leapsecond.ker',
#              '/home/mydir/kernels+',
#              '/custom+',
#              '/kernel_data/constants.ker',
#              '/home/mydir/kernels/text/sclk.tsc',
#              '/home/mydir/kernels/ck/c-kernel.bc' )
#
#
#     Note that the file name
#
#        /home/mydir/kernels/custom/kernel_data/constants.ker
#
#     is continued across several lines in the right hand side of the
#     assignment of the kernel variable KERNELS_TO_LOAD.
#
#     Once you've created your list of kernels, call FURNSH near the
#     beginning of your application program to load the meta-kernel
#     automatically at program start up.
#
#        furnsh( 'meta.tm' )
#
#     This will cause each of the kernels listed in your meta-kernel
#     to be loaded.
#
#
#     Example 3
#     ---------
#
#     This example illustrates how you can simplify the previous
#     kernel list by using PATH_SYMBOLS.
#
#
#        \begintext
#
#           Here are the SPICE kernels required for my application
#           program.
#
#           We are going to let A substitute for the directory that
#           contains SPK files; B substitute for the directory that
#           contains C-kernels; and C substitute for the directory that
#           contains text kernels.  And we'll let D substitute for
#           a "custom" directory that contains a special planetary
#           constants kernel made just for our mission.
#
#           Note that our PATH_VALUES and the corresponding
#           PATH_SYMBOLS must be listed in the same order.
#
#
#        \begindata
#
#        PATH_VALUES  = ( '/home/mydir/kernels/spk',
#                         '/home/mydir/kernels/ck',
#                         '/home/mydir/kernels/text',
#                         '/home/mydir/kernels/custom/kernel_data' )
#
#        PATH_SYMBOLS = ( 'A',
#                         'B',
#                         'C',
#                         'D'  )
#
#        KERNELS_TO_LOAD = (  '$A/lowest_priority.bsp',
#                             '$A/next_priority.bsp',
#                             '$A/highest_priority.bsp',
#                             '$C/leapsecond.ker',
#                             '$D/constants.ker',
#                             '$C/sclk.tsc',
#                             '$B/c-kernel.bc'         )
#
#
#     Example 4
#     ---------
#
#     This example illustrates continuation of path values. The
#     meta-kernel shown here is a modified version of that from
#     example 3.
#
#        \begintext
#
#           Here are the SPICE kernels required for my application
#           program.
#
#           We are going to let A substitute for the directory that
#           contains SPK files; B substitute for the directory that
#           contains C-kernels; and C substitute for the directory that
#           contains text kernels.  And we'll let D substitute for
#           a "custom" directory that contains a special planetary
#           constants kernel made just for our mission.
#
#           Note that our PATH_VALUES and the corresponding
#           PATH_SYMBOLS must be listed in the same order.
#
#           The values for path symbols A and D are continued over
#           multiple lines.
#
#        \begindata
#
#        PATH_VALUES  = ( '/very_long_top_level_path_name/mydir/+',
#                         'kernels/spk',
#                         '/home/mydir/kernels/ck',
#                         '/home/mydir/kernels/text',
#                         '/very_long_top_level_path_name+',
#                         '/mydir/kernels/custom+',
#                         '/kernel_data'                )
#
#        PATH_SYMBOLS = ( 'A',
#                         'B',
#                         'C',
#                         'D'  )
#
#        KERNELS_TO_LOAD = (  '$A/lowest_priority.bsp',
#                             '$A/next_priority.bsp',
#                             '$A/highest_priority.bsp',
#                             '$C/leapsecond.ker',
#                             '$D/constants.ker',
#                             '$C/sclk.tsc',
#                             '$B/c-kernel.bc'         )
#
#-Version
#
#   -Mice Version 1.0.2, 03-DEC-2013, EDW (JPL), SCK (JPL)
#
#      Expanded description of 'file' argument to match
#      all other SPICE language descriptions.
#
#      I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.1, 10-FEB-2010, EDW (JPL)
#
#      Added mention of the length restriction on the kernel pool variable
#      names.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   ######   ####   #####   ######   ####
#    #    #  #       #    #  #    #  #       #    #
#    #       #####   #    #  #    #  #####   #
#    #  ###  #       #    #  #####   #       #
#    #    #  #       #    #  #   #   #       #    #
#     ####   ######   ####   #    #  ######   ####
#
#   geodetic to rectangular coordinates
#
################################################################################
#-Abstract
#
#   georec converts geodetic coordinates to rectangular
#   coordinates.
#
#-I/O
#
#   Given:
#
#       lon   a double precision scalar or 1xN array describing
#             the geodetic longitude measured in radians
#
#       lat   a double precision scalar or 1xN array describing
#             the geodetic latitude measured in radians
#
#       alt   a double precision scalar or 1xN array describing
#             the altitude above the reference spheroid
#
#       re    the scalar, double precision equatorial radius of
#             the body of interest
#
#       f     the scalar, double precision flattening coefficient
#             of the body, a dimensionless value defined as:
#
#                    equatorial_radius - polar_radius
#                    --------------------------------
#                           equatorial_radius
#
#   the call:
#
#      rectan = georec( lon, lat, alt, re, f)
#
#   returns:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#               'rectan' returns with the same units associated with
#               'alt' and 're'
#
#               'rectan' returns with the same vectorization measure
#                (N) as 'lon', 'lat', and 'alt'
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine georec_c.
#
#   MICE.REQ
#
    function # georec
#       (rectan::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        georec(
            lon::Float64, # SpiceDouble
            lat::Float64, # SpiceDouble
            alt::Float64, # SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rectan = Array{Float64,1}(3);  # Array_3_SpiceDouble
        rectan_ptr = pointer(rectan)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:georec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble),lon,lat,alt,re,f,rectan)
        ccall((:georec_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Float64,Float64,Ptr{Float64}),
            lon,lat,alt,re,f,rectan_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rectan
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the standard kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Retrieve the triaxial radii of the earth
#      %
#      radii = cspice_bodvrd( 'EARTH', 'RADII', 3 );
#
#      %
#      % Calculate the flatness coefficient.
#      %
#      flat = (radii(1) - radii(3))/radii(1);
#
#      %
#      % Set a latitude,
#      % longitude, altitude coordinate at 118 west,
#      % 32 North, 0 altitude (convert the angular measures
#      % to radians).
#      %
#      lon  = 118. * cspice_rpd;
#      lat  = 32.  * cspice_rpd;
#      alt  = 0.;
#
#      x = georec( lon, lat, alt, radii(1), flat );
#
#      disp( 'Scalar:' )
#      txt = sprintf( '%14.6f   %14.6f   %14.6f', x );
#      disp( txt )
#
#      disp( ' ' )
#
#      %
#      % Using the equatorial radius of the Clark66 spheroid
#      % (CLARKR = 6378.2064 km) and the Clark 66 flattening
#      % factor (CLARKF = 1.0 / 294.9787 ) convert to
#      % body fixed rectangular coordinates.
#      %
#      CLARKR = 6378.2064;
#      CLARKF = 1./294.9787;
#
#      %
#      % Define a vector of scalar longitudes, latitudes, and altitudes.
#      % This is a vector of scalars (1xN), NOT the same as an N-vector (Nx1).
#      %
#      lon = [  0., ...
#               0., ...
#              90., ...
#               0., ...
#             180., ...
#             -90., ...
#               0., ...
#              45., ...
#               0., ...
#              90., ...
#              45. ];
#
#      lat = [ 90.      , ...
#              88.677225, ...
#              88.677225, ...
#              90.      , ...
#              88.677225, ...
#              88.677225, ...
#              -90.     , ...
#              88.129144, ...
#              88.707084, ...
#              88.707084, ...
#              88.171393 ];
#
#      alt = [ -6356.5838  , ...
#              -6356.572258, ...
#              -6356.572258, ...
#              -6355.5838,   ...
#              -6356.572258, ...
#              -6356.572258, ...
#              -6355.5838,   ...
#              -6356.560715, ...
#              -6355.572518, ...
#              -6355.572518, ...
#              -6355.561236  ];
#
#      %
#      % Convert angular measures to radians.
#      %
#      lon = lon*cspice_rpd;
#      lat = lat*cspice_rpd;
#
#      %
#      % Calculate then output the rectangular coordinates.
#      %
#      x = georec( lon, lat, alt, CLARKR, CLARKF);
#
#      disp( 'Vector:' )
#
#      %
#      % Create an array of values for output.
#      %
#      output = [  x(1,:);  x(2,:);  x(3,:) ];
#      txt    = sprintf( '%14.6f   %14.6f   %14.6f\n', output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#        -2541.748162      4780.333036      3360.428190
#
#      Vector:
#            0.000000         0.000000         0.000000
#            1.000000         0.000000        -0.000000
#            0.000000         1.000000        -0.000000
#            0.000000         0.000000         1.000000
#           -1.000000         0.000000        -0.000000
#            0.000000        -1.000000        -0.000000
#            0.000000         0.000000        -1.000000
#            1.000000         1.000000         0.000000
#            1.000000         0.000000         1.000000
#            0.000000         1.000000         1.000000
#            1.000000         1.000000         1.000000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   ######   ####    #####   ####   #
#    #    #  #       #          #    #    #  #
#    #       #####    ####      #    #    #  #
#    #  ###  #            #     #    #    #  #
#    #    #  #       #    #     #    #    #  #
#     ####   #        ####      #     ####   ######
#
#   change default convergence tolerance for GF routines
#
################################################################################
#-Abstract
#
#   gfstol overrides the default GF convergence value used in the high
#   level GF routines.
#
#-I/O
#
#   Given:
#
#      value   value to use as the GF subsystem convergence tolerance. This
#              value will override the default tolerance, SPICE_GF_CNVTOL,
#              defined in SpiceGF.h. Units are TDB seconds.
#
#              [1,1] = size(value); double = class(value)
#
#   the call:
#
#      gfstol( value )
#
#   returns:
#
#      None.
#
#-Particulars
#
#   The high level GF routines (see GF.REQ for a listing) use a default
#   value for the convergence tolerance, SPICE_GF_CNVTOL, defined in
#   SpiceGF.h. It may occur that a GF search run needs a different
#   convergence tolerance. gfstol programmatically changes the
#   tolerance used by those routines.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine gfstol_c.
#
#   MICE.REQ
#   GF.REQ
#
    function # gfstol
#       (value::Float64) =   # SpiceDouble
        gfstol()
        
#       enforce input array sizes
#       allocate the output parameters
        value = Array{Float64}(1);  # SpiceDouble
        value_ptr = pointer(value)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:gfstol_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,),value)
        ccall((:gfstol_c,libNasaSpice),Void,
            (Ptr{Float64},),
            value_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return value[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'de421.bsp',
#                                'pck00009.tpc',
#                                'naif0009.tls'  )
#
#         \begintext
#
#   Example:
#
#      In 14 A.D., the Roman princeps Tiberius sent his son Drusus to subdue
#      a revolt of a Roman Legion stationed in Pannonia. A Lunar eclipse
#      occurred during this mission.
#
#      Perform a search for occultation events of the sun by earth as
#      observed from the Moon center. Search during the interval from
#      14 A.D. SEP 1 to 14 A.D. SEP 30 (Julian).
#
#      TIMFMT  = 'YYYY ERA MON DD HR:MN:SC.#### ::JCAL';
#      MAXWIN  = 100;
#
#      %
#      % Load kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Use an SPK covering year 14 AD.
#      %
#      cspice_furnsh( 'de408.bsp' )
#
#      %
#      % Store the time bounds of our search interval in
#      % the cnfine confinement window.
#      %
#      et = cspice_str2et( { '14 A.D. SEP 1  00:00:00', ...
#                            '14 A.D. SEP 30 00:00:00'} );
#
#      cnfine = cspice_wninsd( et(1), et(2) );
#
#      %
#      % Select a 3-minute step. We'll ignore any occultations
#      % lasting less than 3 minutes.
#      %
#      step    = 180.;
#
#      occtyp  = 'any';
#      front   = 'earth';
#      fshape  = 'ellipsoid';
#      fframe  = 'iau_earth';
#      back    = 'sun';
#      bshape  = 'ellipsoid';
#      bframe  = 'iau_sun';
#      obsrvr  = 'moon';
#      abcorr  = 'lt';
#
#      %
#      % Perform the search. 'et(1)' and 'et(2)' have values ~-6*10^10,
#      % SPICE_GF_CNVTOL has value 10^-6, so double precision addition or
#      % subtraction of 'et(1)' and 'et(2)' with SPICE_GF_CNVTOL returns
#      % a result indistinguishable from 'et(1)' and 'et(2)'.
#      %
#      % Reduce the GF convergence tolerance by an order of magnitude
#      % to resolve this condition.
#      %
#
#      gfstol( 1e-5 )
#
#      result = cspice_gfoclt( occtyp, front,  fshape, fframe, ...
#                              back,   bshape, bframe,         ...
#                              abcorr, obsrvr, step,   cnfine, ...
#                              MAXWIN);
#
#      %
#      % List the beginning and ending times in each interval
#      % if result contains data.
#      %
#      count = cspice_wncard(result);
#
#      for i=1:count
#
#         [left, right] = cspice_wnfetd( result, i );
#
#         output = cspice_timout( [left,right], TIMFMT );
#
#         if( isequal( left, right) )
#
#            disp( ['Event time: ' output(1,:)] )
#
#         else
#
#            disp( ['Start time :' output(1,:)] )
#            disp( ['Stop time  :' output(2,:)] )
#            disp( ' ')
#
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Start time :  14 A.D. SEP 27 05:02:02.8250
#      Stop time  :  14 A.D. SEP 27 09:33:31.6995
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####      #    #####    ####    ####   #
#    #    #     #    #    #  #    #  #    #  #
#    #          #    #    #  #    #  #    #  #
#    #  ###     #    #####   #    #  #    #  #
#    #    #     #    #       #    #  #    #  #
#     ####      #    #        ####    ####   ######
#
#   RETURN the integer value of a pooled kernel variable
#
################################################################################
#-Abstract
#
#   gipool returns the value of an integer kernel
#   variable (scalar or array) from the kernel pool.
#
#-I/O
#
#   Given:
#
#      name     name of a pool variable associated to integer values.
#
#               [1,m] = size(name); char = class(name)
#
#      start    value for the index indicating the first component of the data
#               vector assigned to 'name' for return (index 1 for all
#               elements).
#
#               [1,1] = size(start); int32 = class(start)
#
#      room     value specifying the maximum number of components that can
#               return for 'name'.
#
#               [1,1] = size(room); int32 = class(room)
#
#   the call:
#
#      [ivals, found] = gipool( name, start, room )
#
#   returns:
#
#      ivals   the representation of the integer values assigned to 'name'
#              beginning at index 'start'. 'ivals' returns empty if the
#              variable 'name' does not exist in the kernel pool.
#
#              [n,1] = size(ivals); double = class(ivals)
#
#              This function does not return double precision values from
#              the kernel pool, rather double precision representations
#              of integer values.
#
#      found   the flag indicating true if 'name' exists in the kernel pool and
#              has numeric type, false if it is not.
#
#              [1,1] = size(found); logical = class(found)
#
#              'ivals' has a size of 'room' or less (N<='room').
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine gipool_c.
#
#   MICE.REQ
#   KERNEL.REQ
#
    function # gipool
#       (ivals::Int32,  # Ptr{SpiceInt}
#        found::Int32) =   # Ptr{SpiceBoolean}
        gipool(
            name::AbstractString, # Ptr{ConstSpiceChar}
            start::Int32, # SpiceInt
            room::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        ivals = Array{Int32}(1);  # Ptr{SpiceInt}
        ivals_ptr = pointer(ivals)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:gipool_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceInt,SpiceInt,Ptr{SpiceInt},Ptr{SpiceInt},Ptr{SpiceBoolean}),name,start,room,n,ivals,found)
        ccall((:gipool_c,libNasaSpice),Void,
            (Ptr{UInt8},Int32,Int32,Ptr{Int32},Ptr{Int32}),
            name,start,room,ivals_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return ivals[1], convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load a kernel containing the variable assignments:
#      %
#      %   CTEST_VAL = ('LARRY', 'MOE', 'CURLY' )
#      %
#      %   ITEST_VAL = ( 3141, 186, 282 )
#      %
#      %   DTEST_VAL = ( 3.1415, 186. , 282.397 )
#      %
#      cspice_furnsh( 'pool_t.ker' )
#
#      %
#      % Retrieve up-to 'ROOM' character entries for
#      % kernel pool variable named 'ITEST_VAL' to
#      % the array named 'cvals'. The first index to return,
#      % 'START', has value 1 (this returns all components).
#      %
#      VAR    = 'ITEST_VAL';
#      ROOM   = 25;
#      START  = 1;
#
#      %
#      % gipool returns an empty array if the variable
#      % does not exist in the kernel pool.
#      %
#      [ivals, found] = gipool( VAR, START, ROOM );
#
#      if ( found )
#
#         txt = sprintf( 'Found %s in the kernel pool', VAR );
#         disp(txt)
#
#         n_elements = size( ivals, 1);
#
#         %
#         % Retrieve the number of elements returned in 'ivals' from the
#         % second element returned from "size".
#         %
#         for n=1:n_elements
#            txt = sprintf( '   Element %d of %s: %i', i, VAR, ivals(n) );
#            disp(txt)
#         end
#
#      else
#
#         txt = sprintf( 'Failed to find %s in the kernel pool', VAR );
#         disp(txt)
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Found ITEST_VAL in the kernel pool
#         Element 1 of ITEST_VAL: 3141
#         Element 2 of ITEST_VAL: 186
#         Element 3 of ITEST_VAL: 282
#
#-Version
#
#   -Mice Version 1.2.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#      "logical" call replaced with "zzmice_logical."
#
#      I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #    ##    #       ######  #####      #
#    #    #   #  #   #       #       #    #     #
#    ######  #    #  #       #####   #    #     #
#    #    #  ######  #       #       #####      #
#    #    #  #    #  #       #       #          #
#    #    #  #    #  ######  #       #          #
#
#   half the value of pi
#
################################################################################
#-Abstract
#
#   halfpi returns the double precision value of the constant pi/2.0.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      halfpi_double = halfpi
#
#   returns:
#
#      A double precision scalar, the value of half the value of pi.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine halfpi_c.
#
#   MICE.REQ
#
    function # halfpi
        halfpi()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:halfpi_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:halfpi_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> half_pi = halfpi
#
#      half_pi =
#
#          1.5708
#
#      >> sprintf( 'Half pi: %2.11f', halfpi )
#
#      ans =
#
#      Half pi: 1.57079632679
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#       #    #       #    #  #    #     #    #    #
#       #    #       #    #  ##  ##     #    ##   #
#       #    #       #    #  # ## #     #    # #  #
#       #    #       #    #  #    #     #    #  # #
#       #    #       #    #  #    #     #    #   ##
#       #    ######   ####   #    #     #    #    #
#
#   illumination angles
#   lighting angles
#   phase angle
#   emission angle
#   solar incidence angle
#
################################################################################
#-Abstract
#
#   ilumin computes the illumination angles (phase, solar incidence,
#   and emission) at a specified surface point of a target body.
#
#   This routine supersedes cspice_illum, which lacks an input
#   argument for the target body-fixed frame name.
#
#-I/O
#
#   Given:
#
#      method   parameters defining the computation method to be used.
#               Parameters include, but are not limited to, the shape model
#               used to represent the surface of the target body.
#
#               [1,m] = size(method); char = class(method)
#
#               The only choice currently supported:
#
#                  "Ellipsoid"        The intercept computation uses
#                                     a triaxial ellipsoid to model
#                                     the surface of the target body.
#                                     The ellipsoid's radii must be
#                                     available in the kernel pool.
#
#               Neither case nor white space are significant in
#               `method'. For example, the string ' eLLipsoid ' is
#               valid.
#
#      target   name of the target body. `target' is  case-insensitive, and
#               leading and trailing blanks in `target' are not significant.
#               Optionally, you may supply a string containing the integer ID
#               code for the object. For example both "MOON" and "301" are
#               legitimate strings that indicate the moon is the target body.
#
#               [1,m] = size(target); char = class(target)
#
#      fixref   name of body-fixed, body-centered reference frame associated
#               with the target body. The input surface point `spoint' and the
#               output vector 'srfvec' are expressed relative to this reference
#               frame.
#
#               [1,m] = size(fixref); char = class(fixref)
#
#               'fixref' is case-insensitive, and leading and trailing
#               blanks are not significant.
#
#      et       epoch specified in ephemeris is seconds past J2000, at which
#               the apparent illumination angles at the specified surface point
#               on the target body, as seen from the observing body, are to be
#               computed.
#
#               [1,1] = size(et); double = class(et)
#
#
#      abcorr   aberration correction to be used in computing the location of
#               the surface point, the orientation of the target body, and the
#               location of the Sun.
#
#               [1,m] = size(abcorr); char = class(abcorr)
#
#               For remote sensing applications, where the apparent
#               illumination angles seen by the observer are desired,
#               normally either of the corrections
#
#                  "LT+S"
#                  "CN+S"
#
#               should be used. These and the other supported options
#               are described below. `abcorr' may be any of the
#               following:
#
#                  "NONE"     No aberration correction.
#
#                  "LT"       Correct the position of the input
#                             surface point SPOINT and orientation of
#                             target body for light time, and correct
#                             the position of the Sun as seen
#                             from the target for light time.
#
#                  "LT+S"     Correct the position of the surface
#                             point SPOINT for light time and stellar
#                             aberration, correct the orientation of
#                             the target body for light time, and
#                             correct the position of the Sun as seen
#                             from the target for light time and
#                             stellar aberration.
#
#                  "CN"       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the "CN" correction iterates
#                             until the solution converges. Both the
#                             position of the surface point SPOINT c
#                             and rotation of the target body, as
#                             well as the position of the Sun as seen
#                             from the target, are corrected for
#                             light time.
#
#                  "CN+S"     Converged Newtonian light time and
#                             stellar aberration corrections. This
#                             option produces a solution that is at
#                             least as accurate at that obtainable
#                             with the "LT+S" option. Whether the
#                             "CN+S" solution is substantially more
#                             accurate depends on the geometry of the
#                             participating objects and on the
#                             accuracy of the input data. In all
#                             cases this routine will execute more
#                             slowly when a converged solution is
#                             computed.
#
#               Neither case nor white space are significant in
#               `abcorr'. For example, the string
#
#                 "Lt + s"
#
#               is valid.
#
#      obsrvr   name of the observing body. This is typically a  spacecraft,
#               the earth, or a surface point on the earth. `obsrvr' is
#               case-insensitive, and leading and trailing blanks in `obsrvr'
#               are not significant. Optionally, you may supply a string
#               containing the integer ID code for the object. For example both
#               "EARTH" and "399" are legitimate strings that indicate the
#               earth is the observer.
#
#               [1,m] = size(obsrvr); char = class(obsrvr)
#
#               `obsrvr' may be not be identical to `target'.
#
#
#      spoint   a surface location on the target body, expressed in Cartesian
#               coordinates, relative to the body-fixed target frame designated
#               by `fixref'.
#
#               [3,1] = size(spoint); double = class(spoint)
#
#               `spoint' need not be visible from the observer's
#               location at the epoch ET.
#
#               The components of `spoint' have units of km.
#
#   the call:
#
#      [trgepc, srfvec, phase, solar, emissn] = ilumin( method,  ...
#                                              target, et,     fixref,  ...
#                                              abcorr, obsrvr, spoint)
#
#   returns:
#
#      trgepc   "surface point epoch." 'trgepc' is defined as follows: letting
#               'lt' be the one-way light time between the observer and the
#               input surface point 'spoint', 'trgepc' is either the epoch
#               et-lt or 'et' depending on whether the requested aberration
#               correction is, respectively, for received radiation or omitted.
#               'lt' is computed using the method indicated by 'abcorr'.
#
#               [1,1] = size(trgepc); double = class(trgepc)
#
#               'trgepc' is expressed as seconds past J2000 TDB.
#
#
#      srfvec   the position vector from the observer at 'et' to 'spoint'.
#               'srfvec' is expressed in the target body-fixed  reference frame
#               designated by 'fixref', evaluated at  'trgepc'.
#
#               [3,1] = size(srfvec); double = class(srfvec)
#
#               The components of 'srfvec' are given in units of km.
#
#               One can use the function norm to obtain the
#               distance between the observer and 'spoint':
#
#                     dist = norm( srfvec )
#
#               The observer's position 'obspos', relative to the
#               target body's center, where the center's position is
#               corrected for aberration effects as indicated by
#               'abcorr', can be computed with:
#
#                     obspos = spoint - srfvec
#
#               To transform the vector 'srfvec' from a reference frame
#               'fixref' at time 'trgepc' to a time-dependent reference
#               frame 'ref' at time 'et', the routine 'cspice_pxfrm2' should be
#               called. Let 'xform' be the 3x3 matrix representing the
#               rotation from the reference frame 'fixref' at time
#               'trgepc' to the reference frame 'ref' at time 'et'. Then
#               'srfvec' can be transformed to the result 'refvec' as
#               follows:
#
#                     xform  = cspice_pxfrm2 ( fixref, ref, trgepc, et )
#                     refvec = xform * srfvec
#
#      phase    phase angle at 'spoint', as seen from 'obsrvr' at time 'et'.
#               This is the angle between the spoint-obsrvr vector and the
#               spoint-sun vector. Units are radians. The range of 'phase' is
#               [0, pi].
#
#               [1,1] = size(phase); double = class(phase)
#
#      solar    solar incidence angle at 'spoint', as seen from 'obsrvr' at
#               time 'et'. This is the angle between the surface normal vector
#               at 'spoint' and the spoint-sun vector. Units are radians. The
#               range of 'solar' is [0, pi].
#
#               [1,1] = size(solar); double = class(solar)
#
#      emissn   emission angle at 'spoint', as seen from 'obsrvr' at time 'et'.
#               This is the angle between the surface normal vector at 'spoint'
#               and the spoint-observer vector. Units are radians. The range of
#               'emissn' is [0, pi].
#
#               [1,1] = size(emissn); double = class(emissn)
#
#-Particulars
#
#   A sister version of this routine exists named mice_subpnt that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ilumin_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # ilumin
#       (trgepc::Float64,  # Ptr{SpiceDouble}
#        srfvec::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        phase::Float64,  # Ptr{SpiceDouble}
#        solar::Float64,  # Ptr{SpiceDouble}
#        emissn::Float64) =   # Ptr{SpiceDouble}
        ilumin(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            fixref::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            spoint::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(spoint) != 3
            error("Incorrect size for parameter 7")
        end
#       allocate the output parameters
        trgepc = Array{Float64}(1);  # Ptr{SpiceDouble}
        trgepc_ptr = pointer(trgepc)
        srfvec = Array{Float64,1}(3);  # Array_3_SpiceDouble
        srfvec_ptr = pointer(srfvec)
        phase = Array{Float64}(1);  # Ptr{SpiceDouble}
        phase_ptr = pointer(phase)
        solar = Array{Float64}(1);  # Ptr{SpiceDouble}
        solar_ptr = pointer(solar)
        emissn = Array{Float64}(1);  # Ptr{SpiceDouble}
        emissn_ptr = pointer(emissn)
        
#       make transposed copies of all input arrays and their pointers
        spoint_t = spoint'
        spoint_ptr = pointer(spoint_t)
        
#       ccall((:ilumin_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_ConstSpiceDouble,Ptr{SpiceDouble},Array_3_SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),method,target,et,fixref,abcorr,obsrvr,spoint,trgepc,srfvec,phase,solar,emissn)
        ccall((:ilumin_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            method,target,et,fixref,abcorr,obsrvr,spoint_ptr,trgepc_ptr,srfvec_ptr,phase_ptr,solar_ptr,emissn_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return trgepc[1], srfvec, phase[1], solar[1], emissn[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Find the phase, solar incidence, and emission angles at the
#      sub-solar and sub-spacecraft points on Mars as seen from the Mars
#      Global Surveyor spacecraft at a user-specified UTC time. Use
#      light time and stellar aberration corrections.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name:  standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'naif0009.tls'
#                                'de421.bsp'
#                                'pck00009.tpc'
#                      )
#
#         \begintext
#
#      %
#      % Load kernel files.
#      %
#      cspice_furnsh( 'standard.tm' )
#      cspice_furnsh( 'mgs_ext13_ipng_mgs95j.bsp' )
#
#      %
#      % Convert the UTC request time to ET (seconds past J2000 TDB).
#      %
#      utc = '2004 JAN 1 12:00:00';
#
#      et = cspice_str2et( utc );
#
#      %
#      % Assign observer and target names. The acronym MGS
#      % indicates Mars Global Surveyor. See NAIF_IDS for a
#      % list of names recognized by SPICE. Also set the
#      % aberration correction flag.
#      %
#      target = 'Mars';
#      obsrvr = 'MGS';
#      abcorr = 'CN+S';
#
#      %
#      % Find the sub-solar point on the Earth as seen from
#      % the MGS spacecraft at et. Use the 'near point'
#      % style of sub-point definition.
#      %
#      [ssolpt, trgepc, srfvec] = ...
#                     cspice_subslr( 'near point: ellipsoid', ...
#                                    target, et, 'iau_mars',  ...
#                                    abcorr, obsrvr );
#
#      %
#      % Now find the sub-spacecraft point.
#      %
#      [sscpt, trgepc, srfvec] = ...
#                     cspice_subpnt( 'near point: ellipsoid', ...
#                                     target, et, 'iau_mars', ...
#                                     abcorr, obsrvr );
#
#      %
#      % Find the phase, solar incidence, and emission
#      % angles at the sub-solar point on the Earth as seen
#      % from MGS at time et.
#      %
#      [ trgepc, srfvec, sslphs, sslsol, sslemi ] = ...
#                     ilumin( 'Ellipsoid',   ...
#                                     target,  et, 'IAU_MARS', ...
#                                     abcorr,  obsrvr,  ssolpt );
#
#      %
#      % Do the same for the sub-spacecraft point.
#      %
#      [ trgepc, srfvec, sscphs, sscsol, sscemi] = ...
#                      ilumin( 'Ellipsoid', ...
#                                      target,  et, 'IAU_MARS', ...
#                                      abcorr, obsrvr, sscpt );
#
#      %
#      % Convert the angles to degrees and write them out.
#      %
#      sslphs = sslphs * cspice_dpr;
#      sslsol = sslsol * cspice_dpr;
#      sslemi = sslemi * cspice_dpr;
#      sscphs = sscphs * cspice_dpr;
#      sscsol = sscsol * cspice_dpr;
#      sscemi = sscemi * cspice_dpr;
#
#      fprintf( [ '\n'                                            ...
#                  'UTC epoch is %s\n'                            ...
#                  '\n'                                           ...
#                  'Illumination angles at the sub-solar point:\n'...
#                  '\n'                                           ...
#                  'Phase angle             (deg):  %f\n'         ...
#                  'Solar incidence angle   (deg):  %f\n'         ...
#                  'Emission angle          (deg):  %f\n'         ...
#                  '\n'                                           ...
#                  'The solar incidence angle should be 0.\n'     ...
#                  'The emission and phase angles should be '     ...
#                  'equal.\n'                                     ...
#                  '\n'                                           ...
#                  '\n'                                           ...
#                  'Illumination angles at the sub-s/c point:\n'  ...
#                  '\n'                                           ...
#                  'Phase angle             (deg):  %f\n'         ...
#                  'Solar incidence angle   (deg):  %f\n'         ...
#                  'Emission angle          (deg):  %f\n'         ...
#                  '\n'                                           ...
#                  'The emission angle should be 0.\n'            ...
#                  'The solar incidence and phase angles '        ...
#                  'should be equal.\n'                           ...
#                  '\n' ], ...
#                  utc,    ...
#                  sslphs, ...
#                  sslsol, ...
#                  sslemi, ...
#                  sscphs, ...
#                  sscsol, ...
#                  sscemi );
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      UTC epoch is 2004 JAN 1 12:00:00
#
#      Illumination angles at the sub-solar point:
#
#      Phase angle             (deg):  115.542001
#      Solar incidence angle   (deg):  0.000000
#      Emission angle          (deg):  115.542001
#
#      The solar incidence angle should be 0.
#      The emission and phase angles should be equal.
#
#
#      Illumination angles at the sub-s/c point:
#
#      Phase angle             (deg):  62.084003
#      Solar incidence angle   (deg):  62.084003
#      Emission angle          (deg):  0.000000
#
#      The emission angle should be 0.
#      The solar incidence and phase angles should be equal.
#
#-Version
#
#   -Mice Version 1.0.4, 12-MAR-2012, SCK (JPL), EDW (JPL)
#
#       References to the new 'cspice_pxfrm2' routine were added to the
#       'I/O returns' section. A problem description was added to the
#       'Examples' section.
#
#       Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.3, 29-APR-2011, EDW (JPL)
#
#       Corrected minor typo in header and another in the usage string.
#
#   -Mice Version 1.0.2, 12-MAY-2009, EDW (JPL)
#
#       Edited I/O section; added 'fixref' description.
#
#   -Mice Version 1.0.1, 30-DEC-2008, EDW (JPL)
#
#       Added typography markers to usage string descriptor.
#
#       Minor edit to Example comments.
#
#       Corrected misspellings.
#
#   -Mice Version 1.0.0, 14-FEB-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#       #    #       #       #    #  #    #
#       #    #       #       #    #  ##  ##
#       #    #       #       #    #  # ## #
#       #    #       #       #    #  #    #
#       #    #       #       #    #  #    #
#       #    ######  ######   ####   #    #
#
#   DEPRECATED illumination angles
#   DEPRECATED lighting angles
#   DEPRECATED phase angle
#   DEPRECATED emission angle
#   DEPRECATED solar incidence angle
#
################################################################################
#-Abstract
#
#   illum calculates the illumination angles at a specified
#   surface point of a target body.
#
#   Deprecated: This routine has been superseded by the routine
#   cspice_ilumin. This routine is supported for purposes of
#   backward compatibility only.
#
#-I/O
#
#   Given:
#
#      target   the scalar string name of the target body. 'target' is
#               case-insensitive, and leading and trailing blanks in
#               'target' are not significant. Optionally, you may supply
#               a string containing the integer ID code for the object.
#               For example both 'MOON' and '301' are legitimate strings
#               that indicate the moon is the target body.
#
#               The target and observer define a state vector whose
#               position component points from the observer to the target.
#
#      et       the double precision scalar or 1xN array of epochs,
#               specified in ephemeris seconds past J2000, at which the
#               apparent illumination angles at the specified surface
#               point on the target body, as seen from the observing
#               body, are to be computed.
#
#      abcorr   the aberration correction to be used in computing the
#               location and orientation of the target body and the location
#               of the Sun.
#
#      obsrvr   the scalar string name of the observing body, typically a
#               spacecraft, the earth, or a surface point on the earth. 'obsrvr'
#               is case-insensitive, and leading and trailing blanks in 'obsrvr'
#               are not significant. Optionally, you may supply a string
#               containing the integer ID code for the object.  For example
#               both "EARTH" and "399" are legitimate strings that indicate
#               the earth is the observer.
#
#      spoint   a double precision 3x1 or 3xN array representing a surface
#               point or points on the target body, expressed in
#               rectangular body-fixed (body equator and prime meridian)
#               coordinates. Each 'spoint' element (spoint(:,i))
#               corresponds to the same element index in 'et' (et(i)) and need
#               not be visible from the observer's location at time 'et'.
#
#               Note: The design of illum supposes the input 'spoint'
#               originates as the output of another Mice routine. Still, in
#               the event the user requires an 'spoint' constant over a vector
#               of 'et', such as a constant station location at (x,y,z),
#               construct 'spoint' with the MATLAB code:
#
#                  N            = numel(et);
#                  spoint       = eye(3, N);
#                  spoint(1,:)  = x;
#                  spoint(2,:)  = y;
#                  spoint(3,:)  = z;
#
#   the call:
#
#      [phase, solar, emissn] = illum( target, et, abcorr, ...
#                                             obsrvr, spoint)
#
#   returns:
#
#      phase    the double precision scalar or 1xN array of phase angles at
#               'spoint', as seen from 'obsrvr' at time 'et'.  This is the
#               angle between the  'spoint'-'obsrvr' vector and the
#               'spoint'-sun vector. Units are radians.  The range of
#               'phase' is [0, pi].
#
#      solar    the double precision, scalar or 1xN array of solar incidence
#               angles at `spoint', as seen from 'obsrvr' at time 'et'.
#               This is the angle between the surface normal vector at
#               'spoint' and the 'spoint'-sun vector.  Units are radians.
#               The range of 'solar' is [0, pi].
#
#      emissn   the double precision, scalar or 1xN array of emission angles
#               at 'spoint', as seen from  'obsrvr' at time 'et'.  This is the
#               angle between the surface normal vector at 'spoint' and the
#               'spoint'-observer vector.  Units are radians.  The range of
#               'emissn' is [0, pi].
#
#               'phase', 'solar', 'emissn' return with the same
#               vectorization measure (N) as 'et'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine illum_c.
#
#   MICE.REQ
#   KERNEL.REQ
#   NAIF_IDS.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # illum
#       (phase::Float64,  # Ptr{SpiceDouble}
#        solar::Float64,  # Ptr{SpiceDouble}
#        emissn::Float64) =   # Ptr{SpiceDouble}
        illum(
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            spoint::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(spoint) != 3
            error("Incorrect size for parameter 5")
        end
#       allocate the output parameters
        phase = Array{Float64}(1);  # Ptr{SpiceDouble}
        phase_ptr = pointer(phase)
        solar = Array{Float64}(1);  # Ptr{SpiceDouble}
        solar_ptr = pointer(solar)
        emissn = Array{Float64}(1);  # Ptr{SpiceDouble}
        emissn_ptr = pointer(emissn)
        
#       make transposed copies of all input arrays and their pointers
        spoint_t = spoint'
        spoint_ptr = pointer(spoint_t)
        
#       ccall((:illum_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_ConstSpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),target,et,abcorr,obsrvr,spoint,phase,solar,emissn)
        ccall((:illum_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            target,et,abcorr,obsrvr,spoint_ptr,phase_ptr,solar_ptr,emissn_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return phase[1], solar[1], emissn[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      % Compute the time evolution of the phase, solar, and
#      % emission angles for the intercept sub-point of the
#      % MGS orbiter from Feb 1, 2003 to April 1, 2003.
#      %
#      TARGET   = 'MARS';
#      OBSERVER = 'MGS';
#      CORRECT  = 'LT+S';
#
#      %
#      % Assign the MGS SPK kernel path-name to a string variable.
#      %
#      MGS = '/kernels/MGS/spk/spk_m_030102-030403_021004.bsp';
#
#      %
#      % Define the start and stop time for the computations.
#      %
#      START_TIME = '1 Feb 2003';
#      STOP_TIME  = '1 APR 2003';
#
#      %
#      % Number of steps?
#      %
#      STEP = 75;
#
#      %
#      % Load the standard leapseconds and PCK kernels, and the MGS SPK
#      % kernel.
#      %
#      cspice_furnsh( 'standard.tm' )
#      cspice_furnsh( MGS )
#
#      %
#      % Convert the strings to ephemeris time J2000.
#      %
#      et_start = cspice_str2et( START_TIME );
#      et_stop = cspice_str2et( STOP_TIME );
#
#      %
#      % Length of a step in seconds for STEP steps.
#      %
#      space = (et_stop - et_start)/STEP;
#
#      %
#      % Create a vector of ephemeris times.
#      %
#      et = [0:(STEP-1)]*space + et_start;
#
#      %
#      % Start at 'et_start', take STEP steps
#      % of space 'length'. At each time, calculate the
#      % intercept sub-point of the observer, then calculate
#      % the illumination angles at the sub-point.
#      %
#      [pos, alt] = cspice_subpt( 'Intercept', TARGET, et, CORRECT, OBSERVER );
#
#      [ phase, solar, emissn] = illum( TARGET, et, CORRECT, ...
#                                               OBSERVER, pos );
#
#      %
#      % Convert the et value to UTC for human comprehension.
#      %
#      utc    = cspice_et2utc( et, 'C', 3 );
#      phase  = phase  * cspice_dpr;
#      solar  = solar  * cspice_dpr;
#      emissn = emissn * cspice_dpr;
#
#      for i = 1:STEP
#
#         %
#         % Output the times and lighting angles in degrees.
#         %
#         txt = sprintf( 'UTC           : %s', utc(i,:) );
#         disp( txt )
#
#         txt = sprintf( 'Emission angle: %14.6f', emissn(i) );
#         disp( txt )
#
#         txt = sprintf( 'Solar angle   : %14.6f', solar(i)  );
#         disp( txt )
#
#         txt = sprintf( 'Phase angle   : %14.6f', phase(i)  );
#         disp( txt )
#
#         disp( ' ' )
#      end
#
#   MATLAB outputs:
#
#      UTC           : 2003 FEB 01 00:00:00.000
#      Emission angle:     0.128603
#      Solar angle   :    49.308223
#      Phase angle   :    49.230858
#
#      UTC           : 2003 FEB 01 18:52:48.000
#      Emission angle:     0.301783
#      Solar angle   :   143.954297
#      Phase angle   :   144.017336
#
#                   ...
#
#      UTC           : 2003 MAR 30 10:14:24.000
#      Emission angle:       0.160300
#      Solar angle   :     139.575312
#      Phase angle   :     139.585791
#
#      UTC           : 2003 MAR 31 05:07:12.000
#      Emission angle:       0.291396
#      Solar angle   :      58.922414
#      Phase angle   :      58.711270
#
#-Version
#
#   -Mice Version 1.0.2, 18-MAY-2010, BVS (JPL)
#
#      Index lines now state that this routine is deprecated.
#
#   -Mice Version 1.0.1, 30-DEC-2008, EDW (JPL)
#
#      Edits to header; Abstract now states that this routine is
#      deprecated.
#
#      Corrected misspellings.
#
#    -Mice Version 1.0.0, 15-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#       #    #    #  ######  #####   #####   #
#       #    ##   #  #       #    #  #    #  #
#       #    # #  #  #####   #    #  #    #  #
#       #    #  # #  #       #    #  #####   #
#       #    #   ##  #       #    #  #       #
#       #    #    #  ######  #####   #       ######
#
#   intersection of ellipsoid and plane
#
################################################################################
#-Abstract
#
#   inedpl calculates the intercept of a triaxial ellipsoid
#   and a plane.
#
#-I/O
#
#   Given:
#
#      a       [1,1] = size(a); double = class(a)
#
#      b       [1,1] = size(b); double = class(b)
#
#      c       [1,1] = size(c); double = class(c)
#
#              are the lengths of the semi-axes of a triaxial ellipsoid.
#              The ellipsoid is centered at the origin and oriented so that
#              its axes lie on the x, y and z axes. 'a', 'b', and 'c' are
#              the lengths of the semi-axes that respectively point in the
#              x, y, and z directions.
#
#      plane   a structure describing a SPICE plane. The intersection of
#              'plane' and the ellipsoid is sought.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      [ ellipse, found ] = inedpl( a, b, c, plane )
#
#   returns:
#
#      ellipse   a structure describing a SPICE ellipse that defines the
#                intersection of 'plane' and the ellipsoid.
#
#                [1,1] = size(ellipse); struct = class(ellipse)
#
#                The structure has the fields:
#
#                  center:    [3,1] = size(center); double = class(center)
#                  semiMajor: [3,1] = size(semiMajor); double = class(semiMajor)
#
#      found     the boolean indicating whether 'plane'
#                intersects the ellipsoid (true) or not (false).
#
#                [1,1] = size(found); logical = class(found)
#
#-Particulars
#
#   An ellipsoid and a plane can intersect in an ellipse, a single point, or
#   the empty set.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine inedpl_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#   PLANES.REQ
#
    function # inedpl
#       (ellipse::NasaSpice.Ellipse,  # Ptr{SpiceEllipse}
#        found::Int32) =   # Ptr{SpiceBoolean}
        inedpl(
            a::Float64, # SpiceDouble
            b::Float64, # SpiceDouble
            c::Float64, # SpiceDouble
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
#       allocate the output parameters
        ellipse = Ellipse()
        ioellipse = IOBuffer()
        StrPack.pack( ioellipse, ellipse)
        ellipse_ptr = convert( Ptr{Ptr{SpiceEllipse}}, convert( Ptr{Void}, pointer(ioellipse.data) ) )
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:inedpl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{ConstSpicePlane},Ptr{SpiceEllipse},Ptr{SpiceBoolean}),a,b,c,plane,ellipse,found)
        ccall((:inedpl_c,libNasaSpice),Void,
            (Float64,Float64,Float64,NasaSpice.Plane,Ptr{Ptr{SpiceEllipse}},Ptr{Int32}),
            a,b,c,plane,ellipse_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(ioellipse,0)
        ellipse = StrPack.unpack( ioellipse, Ellipse )
        return ellipse, convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( '/kernels/gen/lsk/naif0009.tls'
#                                '/kernels/gen/spk/de421.bsp'
#                                '/kernels/gen/pck/pck00009.tpc'
#                      )
#
#         \begintext
#
#      %
#      % Give a position relative to an ellipsoid, calculate
#      % the terminator on the ellipsoid as seen from the position.
#      % As an example, use the view of Earth from the sun.
#      %
#
#      %
#      % Standard SPK, LSK, PCK files.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define the time to calculate the  terminator, the reference
#      % frame, and the light time correction.
#      %
#      TIME  = 'Oct 31 2002, 12:55:00 PST';
#      FRAME = 'J2000';
#      CORR  = 'LT+S';
#
#      %
#      % Convert the date string to ephemeris time.
#      %
#      et = cspice_str2et( TIME );
#
#      %
#      % calculate the position of Earth wrt the Sun.
#      %
#      [pos, ltime] = cspice_spkpos( 'EARTH', et, FRAME, CORR, 'SUN' );
#
#      %
#      % retrieve the triaxial radii of Earth.
#      %
#      radii = cspice_bodvrd( 'EARTH', 'RADII', 3 );
#
#      %
#      % Normalize the position to factors of the radii.
#      %
#      pos = [ pos(1)/radii(1)^2,
#              pos(2)/radii(2)^2,
#              pos(3)/radii(3)^2 ];
#
#      %
#      % Create the SPICE plane.
#      %
#      plane = cspice_nvc2pl( pos, 1. );
#
#      %
#      % Calculate the intercept.
#      %
#      [term, found] = inedpl( radii(1), radii(2), radii(3), plane );
#
#      %
#      % Show the ellipse.
#      %
#      center = term.center
#
#      smaj = term.semiMajor
#
#      smin = term.semiMinor
#
#      %
#      % What's the length measure of the semimajor axis.
#      %
#      smaj_norm = norm( term.semiMajor )
#
#      %
#      % What's the length measure of the semiminor axis?
#      %
#      smin_norm = norm( term.semiMinor )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      center =
#
#           2.151203091605303e-01
#           1.554452696107440e-01
#           6.739164295284016e-02
#
#
#      smaj =
#
#          -3.735613602474674e+03
#           5.169706064912584e+03
#          -1.359546017505989e-11
#
#
#      smin =
#
#          -1.276335287715053e+03
#          -9.222759286967922e+02
#           6.159971549668506e+03
#
#
#      smaj_norm =
#
#           6.378139994119584e+03
#
#
#      smin_norm =
#
#           6.358055846565489e+03
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#       #    #    #  ######  #       #####   #
#       #    ##   #  #       #       #    #  #
#       #    # #  #  #####   #       #    #  #
#       #    #  # #  #       #       #####   #
#       #    #   ##  #       #       #       #
#       #    #    #  ######  ######  #       ######
#
#   intersection of ellipse and plane
#
################################################################################
#-Abstract
#
#   inelpl finds the intersection of an ellipse and a plane.
#
#-I/O
#
#   Given:
#
#      ellipse   a structure describing a SPICE ellipse. The ellipse is
#                allowed to be degenerate: one or both semi-axes may
#                have zero length.
#
#                [1,1] = size(ellipse); struct = class(ellipse)
#
#                The structure has the fields:
#
#                  center:    [3,1] = size(center); double = class(center)
#                  semiMajor: [3,1] = size(semiMajor); double = class(semiMajor)
#                  semiMinor: [3,1] = size(semiMinor); double = class(semiMinor)
#
#      plane     a structure describing a SPICE plane. The intersection of
#                'plane' and 'ellipse' is sought.
#
#                [1,1] = size(plane); struct = class(plane)
#
#                The structure has the fields:
#
#                   normal:     [3,1] = size(normal); double = class(normal)
#                   constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      [ nxpts, xpt1, xpt2] = inelpl( ellipse, plane )
#
#   returns:
#
#      nxpts   the number of points of intersection of the geometric plane
#              and ellipse represented by `plane' and `ellips'. `nxpts' may
#              take the values 0, 1, 2 or -1. The value -1 indicates the
#              ellipse lies in the plane, so the number of intersection
#              points is infinite.
#
#              -1 also signals for the degenerate case where the ellipse
#              structure defines a single point and that point lies
#              in the plane of interest. In this case, -1 means not an
#              infinite number of intersections, rather that the
#              ellipse is a subset of the plane, that subset having
#              measure one.
#
#              [1,1] = size(nxpts); int32 = class(nxpts)
#
#      xpt1,
#      xpt2    the points of intersection of the input plane and ellipse.
#              If there is only one intersection point, both 'xpt1' and
#              'xpt2' contain that point. If the number of intersection
#              points is zero or infinite, the contents of 'xpt1' and
#              'xpt2' are undefined.
#
#              [3,1] = size(xpt1); double = class(xpt1)
#              [3,1] = size(xpt2); double = class(xpt2)
#
#-Particulars
#
#   This routine computes the intersection set of a non-degenerate
#   plane with a possibly degenerate ellipse. The ellipse is allowed
#   to consist of a line segment or a point.
#
#   A plane may intersect an ellipse in 0, 1, 2, or infinitely many
#   points. For there to be an infinite set of intersection points,
#   the ellipse must lie in the plane and consist of more than one
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine inelpl_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#   PLANES.REQ
#
    function # inelpl
#       (nxpts::Int32,  # Ptr{SpiceInt}
#        xpt1::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        xpt2::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        inelpl(
            ellips::NasaSpice.Ellipse, # Ptr{ConstSpiceEllipse}
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
#       allocate the output parameters
        nxpts = Array{Int32}(1);  # Ptr{SpiceInt}
        nxpts_ptr = pointer(nxpts)
        xpt1 = Array{Float64,1}(3);  # Array_3_SpiceDouble
        xpt1_ptr = pointer(xpt1)
        xpt2 = Array{Float64,1}(3);  # Array_3_SpiceDouble
        xpt2_ptr = pointer(xpt2)
        
#       make transposed copies of all input arrays and their pointers
        ioellips = IOBuffer()
        StrPack.pack( ioellips, ellips)
        ellips_ptr = convert( Ptr{Ptr{ConstSpiceEllipse}}, convert( Ptr{Void}, pointer(ioellips.data) ) )
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:inelpl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceEllipse},Ptr{ConstSpicePlane},Ptr{SpiceInt},Array_3_SpiceDouble,Array_3_SpiceDouble),ellips,plane,nxpts,xpt1,xpt2)
        ccall((:inelpl_c,libNasaSpice),Void,
            (NasaSpice.Ellipse,NasaSpice.Plane,Ptr{Int32},Ptr{Float64},Ptr{Float64}),
            ellips,plane,nxpts_ptr,xpt1_ptr,xpt2_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return nxpts[1], xpt1, xpt2
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( '/kernels/gen/lsk/naif0009.tls'
#                                '/kernels/gen/spk/de421.bsp'
#                                '/kernels/gen/pck/pck00009.tpc'
#                      )
#
#         \begintext
#
#
#      %
#      % Standard SPK, LSK, PCK files.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Retrieve the triaxial radii of Saturn (699)
#      %
#      radii = cspice_bodvrd( 'SATURN', 'RADII', 3 );
#
#      %
#      % Define a position in the body frame at one hundred equatorial
#      % radii out along the x axis, one hundred radii above the
#      % equatorial plane.
#      %
#      vertex = [ 100.0 * radii(1), 0.0, radii(1) *100.0 ]';
#
#      %
#      % Find the limb of the ellipsoid as seen from the
#      % point 'vertex'. 'limb' returns as a CSPICE_ELLIPSE.
#      %
#      limb = cspice_edlimb( radii(1), radii(2), radii(3), vertex );
#
#      %
#      % Define the equatorial plane as a SPICE plane. The Z
#      % axis is normal to the plane, the origin lies in the
#      % plane.
#      %
#      normal = [ 0., 0., 1.]';
#      point  = [ 0., 0., 0.]';
#      plane  = cspice_nvp2pl( normal, point);
#
#      %
#      % Calculate the intersection of the 'limb' and 'plane'.
#      %
#      [ nxpts, xpt1, xpt2] = inelpl( limb, plane );
#
#      fprintf(                                                             ...
#         'Observer at (100, 0, 100) radii, no. intersection points: %d\n', ...
#          nxpts )
#      fprintf( '   Intersection points\n' )
#      fprintf( '%.12g  %.12g  %.12g\n',   xpt1   )
#      fprintf( '%.12g  %.12g  %.12g\n\n', xpt2   )
#
#      %
#      % One hundred radii along the Z pole vector (positive)
#      %
#      vertex = [ 0.0 * radii(1), 0.0, radii(1) *100.0 ]';
#
#      %
#      % The resulting limb ellipse should lie parallel to, but
#      % not in the same plane as the equatorial plane. No
#      % intersection should exist.
#      %
#      limb = cspice_edlimb( radii(1), radii(2), radii(3), vertex );
#      [ nxpts, xpt1, xpt2] = inelpl( limb, plane );
#
#      fprintf(                                                            ...
#         'Ellipse/plane parallel case, no. intersection points: %d\n\n',  ...
#         nxpts )
#
#      %
#      % One radii along the X axis, i.e. on the surface, a very
#      % degenerate case.
#      %
#      vertex = [ radii(1), 0.0, 0.0 ]';
#
#      %
#      % In this case the limb ellipse exists as a point at (x, 0, 0).
#      %
#      limb = cspice_edlimb( radii(1), radii(2), radii(3), vertex );
#
#      %
#      % Calculate the intersection of the plane and the degenerate ellipse.
#      %
#      [ nxpts, xpt1, xpt2 ] = inelpl( limb, plane );
#
#      %
#      % As the point (x, 0, 0) exists in 'plane' and that point represents
#      % the complete ellipse, the routine should return -1 for infinite
#      % number of intersections - though in this case the intersection
#      % contains only one element.
#      %
#      fprintf( 'Degenerate case, no. intersection points: %d\n', nxpts )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs for the first example::
#
#      Observer at (100, 0, 100) radii, no. intersection points: 2
#         Intersection points
#      602.68   60264.9865247   3.18323145621e-12
#      602.68  -60264.9865247  -9.37916411203e-12
#
#   MATLAB outputs for the second example, we expect no intersection:
#
#      Ellipse/plane parallel case, no. intersection points: 0
#
#   MATLAB outputs for the degenerate case:
#
#      Degenerate case, no. intersection points: 1
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#       #    #    #  #####    #   #  #####   #
#       #    ##   #  #    #    # #   #    #  #
#       #    # #  #  #    #     #    #    #  #
#       #    #  # #  #####      #    #####   #
#       #    #   ##  #   #      #    #       #
#       #    #    #  #    #     #    #       ######
#
#   intersection of ray and plane
#
################################################################################
#-Abstract
#
#   inrypl finds the intersection of a ray and a plane.
#
#-I/O
#
#   Given:
#
#      vertex   the position of a ray vertex.
#
#               [3,1] = size(normal); double = class(normal)
#
#      dir      the direction of a ray from 'vertex'.
#
#               [3,1] = size(normal); double = class(normal)
#
#      plane    a structure describing a SPICE plane.
#
#               [1,1] = size(plane); struct = class(plane)
#
#               The structure has the fields:
#
#                  normal:     [3,1] = size(normal); double = class(normal)
#                  constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      [ nxpts, xpt ] = inrypl( vertex, dir, plane )
#
#   returns:
#
#      nxpts   the number of points of intersection of the
#              input ray and plane. Values and meanings of nxpts are:
#
#                 0     No intersection.
#
#                 1     One point of intersection.  Note that
#                       this case may occur when the ray's
#                       vertex is in the plane.
#
#                 -1    An infinite number of points of
#                       intersection; the ray lies in the plane.
#
#              [1,1] = size(nxpts); int32 = class(nxpts)
#
#      xpt     the point of intersection of the input ray and plane, when
#              there is exactly one point of intersection.
#
#              If the ray lies in the plane, 'xpt' is set equal to
#              vertex.
#
#              If there is no intersection, 'xpt' is the zero vector.
#
#              [3,1] = size(xpt); double = class(xpt)
#
#-Particulars
#
#   The intersection of a ray and plane in three-dimensional space
#   can be a the empty set, a single point, or the ray itself.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine inrypl_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # inrypl
#       (nxpts::Int32,  # Ptr{SpiceInt}
#        xpt::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        inrypl(
            vertex::Array{Float64,1}, # Array_3_ConstSpiceDouble
            dir::Array{Float64,1}, # Array_3_ConstSpiceDouble
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
        if length(vertex) != 3
            error("Incorrect size for parameter 1")
        end
        if length(dir) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        nxpts = Array{Int32}(1);  # Ptr{SpiceInt}
        nxpts_ptr = pointer(nxpts)
        xpt = Array{Float64,1}(3);  # Array_3_SpiceDouble
        xpt_ptr = pointer(xpt)
        
#       make transposed copies of all input arrays and their pointers
        vertex_t = vertex'
        vertex_ptr = pointer(vertex_t)
        dir_t = dir'
        dir_ptr = pointer(dir_t)
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:inrypl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Ptr{ConstSpicePlane},Ptr{SpiceInt},Array_3_SpiceDouble),vertex,dir,plane,nxpts,xpt)
        ccall((:inrypl_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},NasaSpice.Plane,Ptr{Int32},Ptr{Float64}),
            vertex_ptr,dir_ptr,plane,nxpts_ptr,xpt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return nxpts[1], xpt
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( '/kernels/gen/lsk/naif0009.tls'
#                                '/kernels/gen/spk/de421.bsp'
#                                '/kernels/gen/pck/pck00009.tpc'
#                      )
#
#         \begintext
#
#
#      %
#      % Determine the intersection between the Saturn ring plane and
#      % a look direction as seen from a position in the Saturn
#      % body-fixed frame. For this extremely simplistic example,
#      % we take the equatorial plane as the ring plane.
#      %
#
#      %
#      % Load the standard kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Retrieve the triaxial radii of Saturn (699)
#      %
#      radii = cspice_bodvrd( 'SATURN', 'RADII', 3 );
#
#      %
#      % Define a position in the IAU_SATURN frame at three equatorial
#      % radius out along the x axis, a half radius above the
#      % equatorial plane. For this example, we'll assume 'vertex'
#      % represents the light-time corrected position of a vehicle
#      % to the Saturn ring plane.
#      %
#      vertex = [ 3.0 * radii(1), 0.0, radii(3) *.50 ]';
#
#      %
#      % Define a look vector in the y-z plane from 'vertex'.
#      %
#      %   'vertex'
#      %      *______ y
#      %     /|\
#      %    / | \  30 degrees
#      %   /  |  \
#      %  x  -z  'dir'
#      %
#      dir = [ 0.,
#              cos( 30. *cspice_rpd() ),
#             -sin( 30. *cspice_rpd() )
#            ];
#
#      %
#      % Define the equatorial plane as a SPICE plane. The Z
#      % axis is normal to the plane, the origin lies in the
#      % plane.
#      %
#      normal = [ 0., 0., 1.]';
#      point  = [ 0., 0., 0.]';
#      plane  = cspice_nvp2pl( normal, point );
#
#      %
#      % Determine the intersection point of 'dir' and 'plane', if
#      % such an intersection exists.
#      %
#      [ nxpts, xpt ] =inrypl( vertex, dir, plane );
#
#
#      %
#      % Do we have an intersection?
#      %
#      if ( nxpts == 1 )
#         fprintf( 'Vector intersects plane at: %12.9g %12.9g %12.9g\n', ...
#                  xpt(:) )
#      end
#
#      %
#      % No intersection
#      %
#      if ( nxpts == 0 )
#         fprintf( 'No intersection between vector and plane.\n' )
#      end
#
#      %
#      % No intersection
#      %
#      if ( nxpts == -1 )
#         fprintf( 'Vector lies in plane, degenerate case.\n' )
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Vector intersects plane at:       180804   47080.6051            0
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#       #    #    #  #    #   ####   #####    #####
#       #    ##   #  #    #  #    #  #    #     #
#       #    # #  #  #    #  #    #  #    #     #
#       #    #  # #  #    #  #    #  #####      #
#       #    #   ##   #  #   #    #  #   #      #
#       #    #    #    ##     ####   #    #     #
#
#   Transpose a matrix and invert the lengths of the rows
#   Invert a pseudo orthogonal matrix
#
################################################################################
#-Abstract
#
#   invort returns the inverse of a 3x3 matrix with orthogonal
#   columns and non-zero norms using a numerical stable algorithm.
#
#-I/O
#
#   Given:
#
#      m     a 3x3 matrix.
#
#            [3,3] = size(m); double = class(m)
#
#   the call:
#
#      mit = invort(m)
#
#   returns:
#
#      mit   the matrix obtained by transposing 'm' and dividing the rows by
#            squares of their norms.
#
#            [3,3] = size(mit); double = class(mit)
#
#-Particulars
#
#   Suppose that m is the matrix
#
#           -                      -
#          |   A*u    B*v     C*w   |
#          |      1      1       1  |
#          |                        |
#          |   A*u    B*v     C*w   |
#          |      2      2       2  |
#          |                        |
#          |   A*u    B*v     C*w   |
#          |      3      3       3  |
#           -                      -
#
#   where the vectors (u , u , u ),  (v , v , v ),  and (w , w , w )
#                       1   2   3      1   2   3          1   2   3
#
#   are unit vectors. This routine produces the matrix:
#
#
#           -                      -
#          |   a*u    a*u     a*u   |
#          |      1      2       3  |
#          |                        |
#          |   b*v    b*v     b*v   |
#          |      1      2       3  |
#          |                        |
#          |   c*w    c*w     c*w   |
#          |      1      2       3  |
#           -                      -
#
#   where a = 1/A, b = 1/B, and c = 1/C.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine invort_c.
#
#   MICE.REQ
#
    function # invort
#       (mit::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        invort(
            m::Array{Float64,2}) # Array_3_Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if size(m) != (3,3)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        mit = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        mit_ptr = pointer(mit)
        
#       make transposed copies of all input arrays and their pointers
        m_t = m'
        m_ptr = pointer(m_t)
        
#       ccall((:invort_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_Array_3_ConstSpiceDouble,Array_3_Array_3_SpiceDouble),m,mit)
        ccall((:invort_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64}),
            m_ptr,mit_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return mit'
    end
#-Examples
#
#   Suppose that you have a matrix 'm' whose columns are orthogonal
#   and have non-zero norm (but not necessarily norm 1).  Then the
#   routine invort can be used to construct the inverse of 'm':
#
#        invers = invort( m )
#
#-Version
#
#   -Mice Version 1.0.0, 14-NOV-2013, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#              #     #####    ###     ###
#         #   ##    #     #  #   #   #   #
#         #  # #    #     # # #   # # #   #
#         #    #     ###### #  #  # #  #  #
#         #    #          # #   # # #   # #
#    #    #    #    #     #  #   #   #   #
#     ####   #####   #####    ###     ###
#
#   julian date of 1900.0 jan 0.5
#
################################################################################
#-Abstract
#
#   j1900 returns the value for the Julian Date of
#   1899 DEC 31 12:00:00 (1900 JAN 0.5).
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      j1900 = j1900
#
#   returns:
#
#      j1900   the value 2415020.0, the Julian Date corresponding to
#              1899 DEC 31 12:00:00 (1900 JAN 0.5).
#
#              [1,1] = size(j1900); double = class(j1900)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine j1900_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # j1900
        j1900()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:j1900_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:j1900_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> j1900 = j1900
#
#      j1900 =
#
#           2415020
#
#      >> sprintf( 'J1900 epoch: %10.3f', j1900 )
#
#      ans =
#
#      J1900 epoch: 2415020.000
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#              #     #####  #######   ###
#         #   ##    #     # #        #   #
#         #  # #    #     # #       # #   #
#         #    #     ######  #####  #  #  #
#         #    #          #       # #   # #
#    #    #    #    #     # #     #  #   #
#     ####   #####   #####   #####    ###
#
#   julian date of 1950.0 jan 1.0
#
################################################################################
#-Abstract
#
#   j1950 returns the value for the Julian Date of
#   1950 JAN 01 00:00:00 (1950 JAN 1.0).
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      j1950 = j1950
#
#   returns:
#
#      j1950   the value 2433282.5, the Julian Date corresponding to
#              1950 JAN 01 00:00:00 (1950 JAN 1.0).
#
#              [1,1] = size(j1950); double = class(j1950)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine j1950_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # j1950
        j1950()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:j1950_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:j1950_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> j1950 = j1950
#
#      j1950 =
#
#         2.4333e+06
#
#      >> sprintf( 'J1950 epoch: %10.3f', j1950 )
#
#      ans =
#
#      J1950 epoch: 2433282.500
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#            #####    ###     ###     ###
#         # #     #  #   #   #   #   #   #
#         #       # # #   # # #   # # #   #
#         #  #####  #  #  # #  #  # #  #  #
#         # #       #   # # #   # # #   # #
#    #    # #        #   #   #   #   #   #
#     ####  #######   ###     ###     ###
#
#   julian date of 2000 jan 1.5
#
################################################################################
#-Abstract
#
#   j2000 returns the value for the Julian Date of
#   2000 JAN 01 12:00:00 (2000 JAN 1.5).
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      [j2000] = j2000
#
#   returns:
#
#      j2000   the value 2451545.0, the Julian Date corresponding to
#              2000 JAN 01 12:00:00 (2000 JAN 1.5).
#
#              [1,1] = size(j2000); double = class(j2000)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine j2000_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # j2000
        j2000()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:j2000_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:j2000_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> j2000 = j2000
#
#      j2000 =
#
#           2451545
#
#      >> sprintf( 'J2000 epoch: %10.3f', j2000 )
#
#      ans =
#
#      J2000 epoch: 2451545.000
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#            #####     #      ###     ###
#         # #     #   ##     #   #   #   #
#         #       #  # #    # #   # # #   #
#         #  #####     #    #  #  # #  #  #
#         # #          #    #   # # #   # #
#    #    # #          #     #   #   #   #
#     ####  #######  #####    ###     ###
#
#   julian date of 2100 jan 1.5
#
################################################################################
#-Abstract
#
#   j2100 returns the value for the Julian Date of
#   2100 JAN 01 12:00:00 (2100 JAN 1.5).
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      j2100 = j2100
#
#   returns:
#
#      j2100   the value 2488070.0, the Julian Date corresponding to
#              2100 JAN 01 12:00:00 (2100 JAN 1.5).
#
#              [1,1] = size(j2100); double = class(j2100)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine j2100_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # j2100
        j2100()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:j2100_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:j2100_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> j2100 = j2100
#
#      j2100 =
#
#           2488070
#
#      >> sprintf( 'J2100 epoch: %10.3f', j2100 )
#
#      ans =
#
#      J2100 epoch: 2488070.000
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#         #   #   #  ######    ##    #####
#         #    # #   #        #  #   #    #
#         #     #    #####   #    #  #    #
#         #     #    #       ######  #####
#    #    #     #    #       #    #  #   #
#     ####      #    ######  #    #  #    #
#
#   Number of seconds per julian year
#
################################################################################
#-Abstract
#
#   jyear returns the value for the number of seconds in a
#   Julian year.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      jyear = jyear
#
#   returns:
#
#      jyear   the number of seconds per Julian year as a double precision
#              scalar.
#
#              [1,1] = size(jyear); double = class(jyear)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine jyear_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # jyear
        jyear()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:jyear_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:jyear_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> jyear = jyear
#
#      jyear =
#
#          31557600
#
#      >> sprintf( 'JYEAR value: %11.3f', jyear )
#
#      ans =
#
#      JYEAR value: 31557600.000
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #   ####   #       ######    ##    #####
#    #   #   #    #  #       #        #  #   #    #
#    ####    #       #       #####   #    #  #    #
#    #  #    #       #       #       ######  #####
#    #   #   #    #  #       #       #    #  #   #
#    #    #   ####   ######  ######  #    #  #    #
#
#   Re-initialize the keeper system
#   Clear the keeper system
#   Unload all kernels
#
################################################################################
#-Abstract
#
#   kclear clears the KEEPER system: unload all kernels, clears
#   the kernel pool, and re-initialize the system.
#
#-I/O
#
#   The call:
#
#      kclear
#
#      Re-initialize the KEEPER system.
#
#-Particulars
#
#   This routine allows you re-initialize the KEEPER system with
#   a single call.  The KEEPER system is the kernel management system
#   underlying the set of Mice APIs
#
#      cspice_furnsh
#      cspice_ktotal
#      cspice_kdata
#      cspice_kinfo
#      kclear
#      cspice_unload
#
#   This routine unloads all kernels from their kernel-type-specific
#   kernel management subsystems (SPKBSR, CKBSR, etc.), clears the
#   kernel pool, clears KEEPER's internal file database, and re-sets
#   the watch status for the kernel variables used to load kernels
#   via meta-kernels.
#
#   This capability, though implemented in Fortran, is particularly
#   relevant to SPICE implementations such as Mice, for which the
#   state of the KEEPER system persists after any Mice-based MATLAB
#   script is run. Successive runs of Mice-based scripts may perform
#   in unexpected ways when scripts access data loaded during runs of
#   previous scripts.
#
#   Cleaning up after such programs using explicit unload_c commands is
#   tedious and error-prone.  One call to this routine sets the
#   KEEPER system to its initial state, preventing unintentional
#   interaction between scripts via KEEPER's state.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine kclear_c.
#
#   MICE.REQ
#   KERNEL.REQ
#
    function # kclear
        kclear()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:kclear_c,"/home/don/.julia/v0.3/cspice.so"),Void,())
        ccall((:kclear_c,libNasaSpice),Void,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        return 
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#     %
#     % Load the standard meta kernel, retrieve the number of
#     % loaded kernels.
#     %
#     cspice_furnsh( 'standard.tm' )
#
#     n   = cspice_ktotal( 'ALL' );
#     txt = sprintf('Count of loaded kernels before kclear call: %d', n);
#     disp( txt )
#
#   MATLAB outputs:
#
#     Count of loaded kernels before kclear call: 4
#
#   The expected result counting standard.tm and the three kernels
#   named in the meta kernel.
#
#     %
#     % Clear the KEEPER system, retrieve the number of loaded
#     % after the clear.
#     %
#     kclear
#
#     n   = cspice_ktotal( 'ALL' );
#     txt = sprintf('Count of loaded kernels after kclear call: %d', n);
#     disp( txt )
#
#   MATLAB outputs:
#
#     Count of loaded kernels after kclear call: 0
#
#-Version
#
#   -Mice Version 1.0.0, 01-DEC-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #   #####   ####    #####    ##    #
#    #   #      #    #    #     #     #  #   #
#    ####       #    #    #     #    #    #  #
#    #  #       #    #    #     #    ######  #
#    #   #      #    #    #     #    #    #  #
#    #    #     #     ####      #    #    #  ######
#
#   Number of loaded kernels of a given type
#
################################################################################
#-Abstract
#
#   ktotal returns the current number of kernels loaded
#   via the KEEPER interface that are of a specified type.
#
#-I/O
#
#   Given:
#
#     kind   a scalar string list of types of kernels to count when
#            checking the loaded kernels. 'kind' should consist of a list of
#            words of kernels to examine.  Recognized types are
#
#                 SPK  --- All SPK files are counted in the total.
#                 CK   --- All CK files are counted in the total.
#                 PCK  --- All binary PCK files are counted in the
#                          total.
#                 EK   --- All EK files are counted in the total.
#                 TEXT --- All text kernels that are not meta-text.
#                          kernels are included in the total.
#                 META --- All meta-text kernels are counted in the
#                          total.
#                 ALL  --- Every type of kernel is counted in the
#                          total.
#
#            'kind' lacks case sensitivity. The ktotal algorithm ignores
#            words in 'kind' if not one of those listed above.
#
#            See the Examples section for illustrations of the
#            use of kind.
#
#   the call:
#
#      count = ktotal( kind )
#
#   returns:
#
#      count   a double precision scalar describing the number of kernels
#              loaded through cspice_furnsh belonging to the list
#              specified by 'kind'
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ktotal_c.
#
#   MICE.REQ
#
    function # ktotal
#       (count::Int32) =   # Ptr{SpiceInt}
        ktotal(
            kind::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        count = Array{Int32}(1);  # Ptr{SpiceInt}
        count_ptr = pointer(count)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ktotal_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceInt}),kind,count)
        ccall((:ktotal_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32}),
            kind,count_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return count[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#     %
#     % Load the standard meta kernel, retrieve the number of
#     % loaded kernels.
#     %
#     cspice_furnsh( 'standard.tm' )
#
#     n   = ktotal( 'ALL' );
#     txt = sprintf('Count of loaded kernels before cspice_kclear call: %d', n);
#     disp( txt )
#
#   MATLAB outputs:
#
#     Count of loaded kernels before cspice_kclear call: 4
#
#   The expected result counting standard.tm and the three kernels
#   named in the meta kernel.
#
#     %
#     % Clear the KEEPER system, retrieve the number of loaded
#     % after the clear.
#     %
#     cspice_kclear
#
#     n   = ktotal( 'ALL' );
#     txt = sprintf('Count of loaded kernels after cspice_kclear call: %d', n);
#     disp( txt )
#
#   MATLAB outputs:
#
#     Count of loaded kernels after cspice_kclear call: 0
#
#-Version
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 01-DEC-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #         ##     #####   ####    #   #  #
#    #        #  #      #    #    #    # #   #
#    #       #    #     #    #          #    #
#    #       ######     #    #          #    #
#    #       #    #     #    #    #     #    #
#    ######  #    #     #     ####      #    ######
#
#   latitudinal to cylindrical coordinates
#
################################################################################
#-Abstract
#
#   latcyl converts from latitudinal coordinates to
#   cylindrical coordinates.
#
#-I/O
#
#   Given:
#
#      radius   a double precision scalar or double precision 1xN array
#               the distance of the position from origin
#
#      lon      a double precision scalar or double precision 1xN array
#               the angle of the position from the XZ plane
#               measured in radians
#
#      lat      a double precision scalar or double precision 1xN array
#               the angle of the position from the XY plane
#               measured in radians
#
#   the call:
#
#      [ r, lonc, z] = latcyl( radius, lon, lat)
#
#   returns:
#
#      r      a double precision scalar or double precision 1xN array
#             describing the distance of the point of interest from z axis
#
#      lonc   a double precision scalar or double precision 1xN array
#             describing the cylindrical angle of the point of interest
#             from the XZ plane measured in radians
#
#      z      a double precision scalar or double precision 1xN array
#             describing the height of the point above the XY plane
#
#             The arguments 'r' and 'z' return in the same units associated
#             with 'radius'.
#
#             'r', 'lonc', and 'z' return with the same vectorization
#             measure (N) as the 'radius', 'lon', and 'lat'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine latcyl_c.
#
#   MICE.REQ
#
    function # latcyl
#       (r::Float64,  # Ptr{SpiceDouble}
#        lonc::Float64,  # Ptr{SpiceDouble}
#        z::Float64) =   # Ptr{SpiceDouble}
        latcyl(
            radius::Float64, # SpiceDouble
            lon::Float64, # SpiceDouble
            lat::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        r = Array{Float64}(1);  # Ptr{SpiceDouble}
        r_ptr = pointer(r)
        lonc = Array{Float64}(1);  # Ptr{SpiceDouble}
        lonc_ptr = pointer(lonc)
        z = Array{Float64}(1);  # Ptr{SpiceDouble}
        z_ptr = pointer(z)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:latcyl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),radius,lon,lat,r,lonc,z)
        ccall((:latcyl_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            radius,lon,lat,r_ptr,lonc_ptr,z_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r[1], lonc[1], z[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to latitudinal
#      % coordinates.
#      %
#      [radius, longitude, latitude] = cspice_reclat(pos);
#
#      %
#      % Convert the latitudinal coords to cylindrical.
#      %
#      [r, lonc, z ] = latcyl( radius, longitude, latitude);
#
#      %
#      % Convert the cylindrical to rectangular.
#      %
#      [rectan] = cspice_cylrec( r, lonc, z);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#                     0  -0.03701547067225   0.63783453323816
#      0.02182376758148   0.01641520435413  -0.01531271963894
#      0.01912147275010   0.01213804257114   0.02039513446643
#
#      The relative error between the original array of position vectors
#      and those that resulted from the various coordinate conversion
#      has magnitude on the order of 10^(-14).  A numerical
#      demonstration of equality.
#
#   Example (2):
#
#      %
#      % Define six sets of latitudinal coordinates, 'lon' and 'lat'
#      % expressed in degrees - converted to radians by use
#      % of cspice_rpd.
#      %
#      rad = [ 1.,  1., sqrt(2.), sqrt(2.),   1.,  0. ];
#      lon = [ 0., 90.,     180.,     180., 180., 33. ] * cspice_rpd;
#      lat = [ 0.,  0.,      45.,     -45.,  90.,  0. ] * cspice_rpd;
#
#      %
#      % ...convert the latitudinal coordinates to cylindrical coordinates
#      %
#      [r, lonc, z] = latcyl(rad, lon, lat);
#
#      %
#      % ...convert angular measure to degrees.
#      %
#      lonc = lonc * cspice_dpr;
#      lon  = lon  * cspice_dpr;
#      lat  = lat  * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r         lonc        z        radius      lon        lat   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [  r; lonc; z; rad; lon; lat ];
#
#      txt = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r         lonc        z        radius      lon        lat
#     --------   --------   --------   --------   --------   --------
#       1.0000     0.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     1.0000    90.0000     0.0000
#       1.0000   180.0000     1.0000     1.4142   180.0000    45.0000
#       1.0000   180.0000    -1.0000     1.4142   180.0000   -45.0000
#       0.0000   180.0000     1.0000     1.0000   180.0000    90.0000
#       0.0000    33.0000     0.0000     0.0000    33.0000     0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 09-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #         ##     #####  #####   ######   ####
#    #        #  #      #    #    #  #       #    #
#    #       #    #     #    #    #  #####   #
#    #       ######     #    #####   #       #
#    #       #    #     #    #   #   #       #    #
#    ######  #    #     #    #    #  ######   ####
#
#   latitudinal to rectangular coordinates
#
################################################################################
#-Abstract
#
#   latrec converts latitudinal coordinates to rectangular
#   (Cartesian) coordinates.
#
#-I/O
#
#   Given:
#
#      radius      a double precision scalar or double precision 1xN array
#                  describing the distance of the position from origin
#
#      longitude   a double precision scalar or double precision 1xN array
#                  describing the angle of the position from the XZ plane
#                  measured in radians
#
#      latitude    a double precision scalar or double precision 1xN array
#                  describing the angle of the position from the XY plane
#                  measured in radians
#
#   the call:
#
#      rectan = latrec( radius, longitude, latitude)
#
#   returns:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#               'rectan' returns with the same units associated with 'radius'.
#
#               'rectan' returns with the vectorization measure (N) as
#               'radius', 'longitude', and 'latitude'
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine latrec_c.
#
#   MICE.REQ
#
    function # latrec
#       (rectan::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        latrec(
            radius::Float64, # SpiceDouble
            longitude::Float64, # SpiceDouble
            latitude::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rectan = Array{Float64,1}(3);  # Array_3_SpiceDouble
        rectan_ptr = pointer(rectan)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:latrec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble),radius,longitude,latitude,rectan)
        ccall((:latrec_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            radius,longitude,latitude,rectan_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rectan
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to latitudinal
#      % coordinates.
#      %
#      [radius, longitude, latitude] = cspice_reclat(pos);
#
#      %
#      % Convert the latitudinal to rectangular.
#      %
#      [rectan] = latrec(radius, longitude, latitude);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#     -0.01996090072080  -0.05552320600838   0.63783453323816
#      0.02182376758148                  0  -0.01531271963894
#      0.01912147275010   0.01213804257114   0.02039513446643
#
#   Example (2):
#
#      %
#      % Define eleven sets of latitudinal coordinates.
#      %
#      r         = [ 0., 1., 1., 1., 1., 1., 1., ...
#                                     sqrt(2), sqrt(2), sqrt(2), sqrt(3) ];
#      longitude = [ 0., 0., 90., 0. 180., -90., ...
#                                     0., 45., 0., 90., 45. ];
#      latitude  = [ 0., 0., 0., 90., 0., 0.,    ...
#                                     -90., 0., 45., 45., 35.2643 ];
#
#      %
#      % ...convert the latitudinal coordinates to rectangular coordinates
#      %
#      longitude = longitude * cspice_rpd;
#      latitude  = latitude  * cspice_rpd;
#
#      rectan = latrec(r, longitude, latitude);
#
#      %
#      % Loop over each set of coordinates for output, convert 'longitude'
#      % and 'latitude' to degrees...
#      %
#      longitude = longitude * cspice_dpr;
#      latitude  = latitude  * cspice_dpr;
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; longitude; latitude; rectan ];
#
#      %
#      % Output banner.
#      %
#      disp('     r       longitude  latitude       x         y           z   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      txt = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r       longitude  latitude       x         y           z
#     --------   --------   --------   --------   --------   --------
#       0.0000     0.0000     0.0000     0.0000     0.0000     0.0000
#       1.0000     0.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     0.0000     1.0000     0.0000
#       1.0000     0.0000    90.0000     0.0000     0.0000     1.0000
#       1.0000   180.0000     0.0000    -1.0000     0.0000     0.0000
#       1.0000   -90.0000     0.0000     0.0000    -1.0000     0.0000
#       1.0000     0.0000   -90.0000     0.0000     0.0000    -1.0000
#       1.4142    45.0000     0.0000     1.0000     1.0000     0.0000
#       1.4142     0.0000    45.0000     1.0000     0.0000     1.0000
#       1.4142    90.0000    45.0000     0.0000     1.0000     1.0000
#       1.7321    45.0000    35.2643     1.0000     1.0000     1.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #         ##     #####   ####   #####   #    #
#    #        #  #      #    #       #    #  #    #
#    #       #    #     #     ####   #    #  ######
#    #       ######     #         #  #####   #    #
#    #       #    #     #    #    #  #       #    #
#    ######  #    #     #     ####   #       #    #
#
#   latitudinal to spherical coordinates
#
################################################################################
#-Abstract
#
#   latsph converts latitudinal coordinates to spherical
#   coordinates.
#
#-I/O
#
#   Given:
#
#      radius   a double precision scalar or double precision 1xN array
#               describing the distance of the position from origin
#
#      lon      a double precision scalar or double precision 1xN array
#               the angle of the position from the XZ plane
#               measured in radians
#
#      lat      a double precision scalar or double precision 1xN array
#               the angle of the position from the XY plane
#               measured in radians
#
#   the call:
#
#      [rho, colat, lons] = latsph( radius, lon, lat)
#
#   returns:
#
#      rho     a double precision scalar or double precision 1XN
#              array describing the distance of the position from origin
#
#      colat   a double precision scalar or double precision 1XN
#              array describing the angle between the point and the
#              positive z-axis, measured in radians (also referred to
#              as the polar angle)
#
#      lons    a double precision scalar or double precision 1XN array
#              describing the angle of the projection of the point to the XY
#              plane from the positive X-axis, measured in radians,
#              with range:
#
#                  -pi < lons <= pi
#
#              The positive Y-axis is at longitude PI/2 radians.
#
#              The argument 'rho' returns in the same units associated
#              with 'radius'.
#
#              'rho', 'colat', and 'lons' return with the same vectorization
#              measure (N) as 'radius', 'lon', and 'lat'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine latsph_c.
#
#   MICE.REQ
#
    function # latsph
#       (rho::Float64,  # Ptr{SpiceDouble}
#        colat::Float64,  # Ptr{SpiceDouble}
#        lons::Float64) =   # Ptr{SpiceDouble}
        latsph(
            radius::Float64, # SpiceDouble
            lon::Float64, # SpiceDouble
            lat::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rho = Array{Float64}(1);  # Ptr{SpiceDouble}
        rho_ptr = pointer(rho)
        colat = Array{Float64}(1);  # Ptr{SpiceDouble}
        colat_ptr = pointer(colat)
        lons = Array{Float64}(1);  # Ptr{SpiceDouble}
        lons_ptr = pointer(lons)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:latsph_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),radius,lon,lat,rho,colat,lons)
        ccall((:latsph_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            radius,lon,lat,rho_ptr,colat_ptr,lons_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rho[1], colat[1], lons[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#    Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to latitudinal
#      % coordinates.
#      %
#      [radius, longitude, latitude] = cspice_reclat(pos);
#
#      %
#      % Convert the latitudinal coords to spherical.
#      %
#      [rho, colat, lon] = latsph( radius, longitude, latitude);
#
#      %
#      % Convert the spherical to rectangular.
#      %
#      [rectan] = cspice_sphrec(radius, colat, lon);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#                     0  -0.03701547067225   0.63783453323816
#      0.02182376758148   0.01641520435413  -0.01531271963894
#     -0.01912147275010  -0.04855217028457   0.02039513446643
#
#      The relative error between the original array of position vectors
#      and those that resulted from the various coordinate conversion
#      has magnitude on the order of 10^(-14).
#
#    Example (2):
#
#      %
#      % Define six sets of latitudinal coordinates, 'lon' and 'lat'
#      % expressed in degrees - converted to radians by use
#      % of cspice_rpd.
#      %
#      rad = [ 1.,  1., sqrt(2.), sqrt(2.),   1.,  0. ];
#      lon = [ 0., 90.,     180.,     180., 180., 33. ] * cspice_rpd;
#      lat = [ 0.,  0.,      45.,      -45., 90.,  0. ] * cspice_rpd;
#
#      %
#      % ...convert the latitudinal coordinates to spherical coordinates
#      %
#      [rho, colat, slon] = latsph(rad, lon, lat);
#
#      %
#      % ...convert angular measure to degrees.
#      %
#      colat = colat * cspice_dpr;
#      lon   = lon   * cspice_dpr;
#      slon  = slon  * cspice_dpr;
#      lat   = lat   * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('    rho       colat       slon       rad        lon        lat   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ rho; colat; slon; rad; lon; lat];
#      txt    = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', ...
#                        output );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#          rho       colat       slon       rad        lon        lat
#        --------   --------   --------   --------   --------   --------
#          1.0000    90.0000     0.0000     1.0000     0.0000     0.0000
#          1.0000    90.0000    90.0000     1.0000    90.0000     0.0000
#          1.4142    45.0000   180.0000     1.4142   180.0000    45.0000
#          1.4142   135.0000   180.0000     1.4142   180.0000   -45.0000
#          1.0000     0.0000   180.0000     1.0000   180.0000    90.0000
#          0.0000    90.0000    33.0000     0.0000    33.0000     0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #        #####     #    #    #  ######
#    #          #       #    ##  ##  #
#    #          #       #    # ## #  #####
#    #          #       #    #    #  #
#    #          #       #    #    #  #
#    ######     #       #    #    #  ######
#
#   Compute uplink and downlink light time
#
################################################################################
#-Abstract
#
#   ltime computes the transmit (or receive) time of
#   a signal at a specified target, given the receive (or transmit)
#   time at a specified observer. The elapsed time between transmit
#   and receive is also returned.
#
#-I/O
#
#   Given:
#
#      etobs   a double precision scalar or 1xN vector defining the
#              epoch in ephemeris seconds (TDB) of a signal at some
#              observer
#
#      obs     the scalar integer NAIF ID code of the observer
#
#      dir     a character string pictograph defining the
#              direction the signal travels, to target from
#              observer "->", or from the target to the
#              observer "<-"
#
#      targ    the scalar integer NAIF ID code of the target
#
#   the call:
#
#      [ettarg, elapsd] = ltime(etobs, obs, dir, targ)
#
#   returns:
#
#      ettarg   the double precision scalar or 1XN vector defining the
#               epoch at which the electromagnetic signal is "at" the
#               target body, expressed in ephemeris seconds (TDB)
#
#                  Note 'ettarg' is computed using only Newtonian
#                  assumptions about the propagation of light.
#
#      elapsd   the double precision scalar or 1XN vector defining the
#               measure of ephemeris seconds (TDB) between transmission
#               and receipt of the signal
#
#                  elapsd = abs( etobs - ettarg )
#
#               'ettarg' and 'elapsd' return with the same
#               vectorization measure (N) as 'etobs'.
#
#-Particulars
#
#     None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine ltime_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # ltime
#       (ettarg::Float64,  # Ptr{SpiceDouble}
#        elapsd::Float64) =   # Ptr{SpiceDouble}
        ltime(
            etobs::Float64, # SpiceDouble
            obs::Int32, # SpiceInt
            dir::AbstractString, # Ptr{ConstSpiceChar}
            targ::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        ettarg = Array{Float64}(1);  # Ptr{SpiceDouble}
        ettarg_ptr = pointer(ettarg)
        elapsd = Array{Float64}(1);  # Ptr{SpiceDouble}
        elapsd_ptr = pointer(elapsd)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:ltime_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceInt,Ptr{ConstSpiceChar},SpiceInt,Ptr{SpiceDouble},Ptr{SpiceDouble}),etobs,obs,dir,targ,ettarg,elapsd)
        ccall((:ltime_c,libNasaSpice),Void,
            (Float64,Int32,Ptr{UInt8},Int32,Ptr{Float64},Ptr{Float64}),
            etobs,obs,dir,targ,ettarg_ptr,elapsd_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return ettarg[1], elapsd[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load an SPK, PCK, and leapseconds kernel
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Suppose a signal originates from Earth towards the
#      % the Jupiter system barycenter. Define the NAIF IDs
#      % for the observer, Earth (399), the target, Jupiter
#      % barycenter (5), and time of interest.
#      %
#      OBS      = 399;
#      TARGET   = 5;
#      TIME_STR = 'July 4, 2004';
#
#      %
#      %  Convert the transmission time to ET.
#      %
#      et = cspice_str2et( TIME_STR);
#
#      %
#      %  Determine the arrival time and the time for propagation.
#      %
#      [arrive, ltime] = ltime( et, OBS, '->', TARGET);
#
#      %
#      %  Convert the arrival time (ET) to UTC.
#      %
#      arrive_utc = cspice_et2utc( arrive, 'C', 3 );
#
#      %
#      %  Output the results.
#      %
#      txt = sprintf( 'Transmission at (UTC)       : %s', TIME_STR );
#      disp(txt)
#
#      txt = sprintf( 'The signal arrived at (UTC) : %s', arrive_utc );
#      disp(txt)
#
#      txt = sprintf( 'Time for propagation (secs) : %16.4f', ltime );
#      disp(txt)
#      disp( ' ' )
#
#      %
#      % Now assume the signal originated at Jupiter barycenter,
#      % received by Earth at TIME_STR. Determine the transmission
#      % time and the time for propagation.
#      %
#      [receive, ltime] = ltime( et, OBS, '<-', TARGET);
#
#      %
#      % Convert the reception time (ET) to UTC.
#      %
#      receive_utc = cspice_et2utc( receive, 'C', 3 );
#
#      %
#      %  Output the results.
#      %
#      txt = sprintf( 'Reception at (UTC)          : %s', TIME_STR );
#      disp(txt)
#
#      txt = sprintf( 'The signal sent at (UTC)    : %s', receive_utc );
#      disp(txt)
#
#      txt = sprintf( 'Time for propagation (secs) : %16.4f', ltime );
#      disp(txt)
#
#   MATLAB outputs:
#
#      Transmission at (UTC)       : July 4, 2004
#      The signal arrived at (UTC) : 2004 JUL 04 00:48:38.717
#      Time for propagation (secs) :        2918.7170
#
#      Reception at (UTC)          : July 4, 2004
#      The signal sent at (UTC)    : 2004 JUL 03 23:11:21.248
#      Time for propagation (secs) :        2918.7524
#
#-Version
#
#   -Mice Version 1.0.0, 22-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#            #####
#    #    # #     #  ######  #    #  #
#    ##  ##       #  #       #    #  #
#    # ## #  #####   #####   #    #  #
#    #    # #        #       #    #  #
#    #    # #        #       #    #  #
#    #    # #######  ######   ####   ######
#
#   matrix to euler angles
#
################################################################################
#-Abstract
#
#   m2eul factors a rotation matrix into a product of
#   three rotations about specified coordinate axes.
#
#-I/O
#
#   Given:
#
#      r       is a 3x3 or 3x3xN array of rotation matrices to factor as
#              a product of three rotations about a specified
#              coordinate axes.  The angles of these rotations are
#              called "Euler angles".
#
#      axis3
#      axis2
#      axis1   are the scalar integer indices of the rotation axes of the
#              "factor" rotations, whose product is 'r'. 'r' is
#              factored as
#
#                 r = [ angle3 ]     [ angle2 ]     [ angle1 ]
#                               axis3          axis2          axis1
#
#              The axis numbers must belong to the set {1, 2, 3}.
#              The second axis number MUST differ from the first
#              and third axis numbers.
#
#   the call:
#
#      [angle3, angle2, angle1] = m2eul( r, axis3, axis2, axis1 )
#
#   returns:
#
#      angle3
#      angle2
#      angle1   the scalar or 1xN arrays of double precision
#               Euler angles measured where the angle satisfy
#
#                   r = [ angle3 ]     [ angle2 ]     [ angle1 ]
#                                axis3           axis2          axis1
#
#                  The range of 'angle3' and 'angle1' is (-pi, pi].
#
#                  The range of 'angle2' depends on the exact set of
#                  axes used for the factorization.  For
#                  factorizations in which the first and third axes
#                  are the same,
#
#                     r = [R]  [S]  [T]
#                            a    b    a
#
#                  the range of 'angle2' is [0, pi].
#
#                  For factorizations in which the first and third
#                  axes are different,
#
#                     r = [R]  [S]  [T] ,
#                            a    b    c
#
#                  the range of angle2 is [-pi/2, pi/2].
#
#                  For rotations such that 'angle3' and 'angle1' are not
#                  uniquely determined, 'angle3' will always be set to
#                  zero; 'angle1' is then uniquely determined.
#
#               'angle3', 'angle2', and 'angle1' return with the same
#               vectorization measure (N) as 'r'.
#
#      Note, the call sequence:
#
#         [angle3, angle2, angle1] = m2eul(r, axis3, axis2, axis1)
#         r = cspice_eul2m(angle3, angle2, angle1, axis3, axis2, axis1)
#
#      preserves 'r' to round-off error.
#
#      Yet, the call sequence:
#
#         r = cspice_eul2m(angle3, angle2, angle1, axis3, axis2, axis1)
#        [angle3, angle2, angle1] = m2eul(r, axis3, axis2, axis1)
#
#      preserves 'angle3', 'angle2', and 'angle1' only if the initial
#      values of the angle existed within the range of m2eul's
#      output.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine m2eul_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # m2eul
#       (angle3::Float64,  # Ptr{SpiceDouble}
#        angle2::Float64,  # Ptr{SpiceDouble}
#        angle1::Float64) =   # Ptr{SpiceDouble}
        m2eul(
            r::Array{Float64,2}, # Array_3_Array_3_ConstSpiceDouble
            axis3::Int32, # SpiceInt
            axis2::Int32, # SpiceInt
            axis1::Int32) # SpiceInt
        
#       enforce input array sizes
        if size(r) != (3,3)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        angle3 = Array{Float64}(1);  # Ptr{SpiceDouble}
        angle3_ptr = pointer(angle3)
        angle2 = Array{Float64}(1);  # Ptr{SpiceDouble}
        angle2_ptr = pointer(angle2)
        angle1 = Array{Float64}(1);  # Ptr{SpiceDouble}
        angle1_ptr = pointer(angle1)
        
#       make transposed copies of all input arrays and their pointers
        r_t = r'
        r_ptr = pointer(r_t)
        
#       ccall((:m2eul_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_Array_3_ConstSpiceDouble,SpiceInt,SpiceInt,SpiceInt,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),r,axis3,axis2,axis1,angle3,angle2,angle1)
        ccall((:m2eul_c,libNasaSpice),Void,
            (Ptr{Float64},Int32,Int32,Int32,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            r_ptr,axis3,axis2,axis1,angle3_ptr,angle2_ptr,angle1_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return angle3[1], angle2[1], angle1[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Example(1):
#
#      %
#      % Scalar example, conversion of instrument pointing from a matrix
#      % representation to Euler angles:
#      %
#      % Suppose we want to find camera pointing in 'alpha', 'delta', and
#      % 'kappa', given the inertial-to-camera coordinate transformation
#      %
#      ticam = [                                                            ...
#         [ 0.49127379678135830  0.50872620321864170  0.70699908539882417 ]
#         [ -0.50872620321864193 -0.49127379678135802  0.70699908539882428]
#         [  0.70699908539882406 -0.70699908539882439  0.01745240643728360] ];
#
#      %
#      % We want to find angles alpha, delta, kappa such that
#      %
#      %
#      %   ticam  =  [ kappa ]  [ pi/2 - delta ]  [ pi/2 + alpha ] .
#      %                      3                 1                 3
#      %
#      %
#      % Factor the matrix to the Euler angles corresponding to a
#      % 3-1-3 rotation.
#      %
#      [ kappa, ang2, ang1  ] = m2eul( ticam, 3, 1, 3 );
#
#      alpha  =  ang1          - cspice_halfpi;
#      delta  =  cspice_halfpi - ang2;
#
#      %
#      %  calculates the desired angles.  If we wish to make sure that
#      % alpha, delta, and kappa are in the ranges [0, 2pi),
#      % [-pi/2, pi/2], and [0, 2pi) respectively, we may add the code
#      %
#
#      if ( alpha < 0. )
#       alpha = alpha + cspice_twopi;
#      end
#
#      if ( kappa < 0. )
#         kappa = kappa + cspice_twopi;
#      end
#
#      %
#      % Output the 3-1-3 Euler rotation angles corresponding to 'ticam'.
#      %
#      fprintf( '%12.5f   %12.5f   %12.5f\n', ...
#               [ alpha, delta, kappa ] *cspice_dpr)
#
#   MATLAB outputs:
#
#         315.00000        1.00000       45.00000
#
#      Example(2):
#
#      %
#      % Vectorized example, input an array of ephemeris times, calculate
#      % the corresponding J2000 to IAU_MOON transformation matrices.
#      %
#      cspice_furnsh('standard.tm')
#
#      et0 = cspice_str2et( 'Jan 1 2000 12:00:00 TDB' );
#      et1 = cspice_str2et( 'Jan 1 2010 12:00:00 TDB' );
#
#      n     = 10;
#      times = et0 + (1:n)* (et1 - et0)/n;
#      quot   = cspice_pxform( 'J2000', 'IAU_MOON', times );
#
#      %
#      % Factor the matrices to the Euler angles corresponding to a
#      % 3-2-1 rotation set.
#      %
#      [a3,a2,a1] = m2eul( quot, 1,2,3);
#
#      %
#      % Output the 3-2-1 Euler rotation angles corresponding to 'quot'.
#      %
#      fprintf( '%12.5f   %12.5f   %12.5f\n', [a1; a2; a3] * cspice_dpr )
#
#      cspice_kclear
#
#   MATLAB outputs:
#
#         -52.93007       18.11962       15.07397
#          77.30266      -22.59555        3.51974
#        -150.68645       12.42680      -18.79120
#         -14.28248        4.91714       21.55874
#         120.06957      -19.09792      -11.00536
#        -109.73801       20.66329       -7.52692
#          23.54335       -8.43440       20.49467
#         160.13917       -9.11890      -20.58629
#         -66.71201       21.70068        7.52880
#
#-Version
#
#   -Mice Version 1.0.1, 30-DEC-2008, EDW (JPL)
#
#      Corrected misspellings.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#            #####
#    #    # #     #   ####
#    ##  ##       #  #    #
#    # ## #  #####   #    #
#    #    # #        #  # #
#    #    # #        #   #
#    #    # #######   ### #
#
#   matrix to quaternion
#
################################################################################
#-Abstract
#
#   m2q calculates a unit quaternion corresponding to a
#   specified 3x3 double precision, rotation matrix.
#
#-I/O
#
#   Given:
#
#      r   a double precision 3x3 or 3x3xN array of rotation
#          matrices
#
#   the call:
#
#      q = m2q(r)
#
#   returns:
#
#      q   a double precision 4-vector or 4xN array, the quaternion
#          representation of the matrix 'r'
#
#          Note that multiple styles of quaternions are in use.
#          This routine returns a quaternion that conforms to
#          the SPICE convention. See the Particulars section
#          for details.
#
#          'q' returns with the same vectorization measure (N)
#          as 'r' .
#
#-Particulars
#
#   About SPICE quaternions
#   =======================
#
#   There are (at least) two popular "styles" of quaternions; these
#   differ in the layout of the quaternion elements, the definition
#   of the multiplication operation, and the mapping between the set
#   of unit quaternions and corresponding rotation matrices.
#
#   SPICE-style quaternions have the scalar part in the first
#   component and the vector part in the subsequent components. The
#   SPICE convention, along with the multiplication rules for SPICE
#   quaternions, are those used by William Rowan Hamilton, the
#   inventor of quaternions.
#
#   Another common quaternion style places the scalar component
#   last.  This style is often used in engineering applications.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine m2q_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # m2q
#       (q::Array{Float64,1}(4)) =   # Array_4_SpiceDouble
        m2q(
            r::Array{Float64,2}) # Array_3_Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if size(r) != (3,3)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        q = Array{Float64,1}(4);  # Array_4_SpiceDouble
        q_ptr = pointer(q)
        
#       make transposed copies of all input arrays and their pointers
        r_t = r'
        r_ptr = pointer(r_t)
        
#       ccall((:m2q_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_Array_3_ConstSpiceDouble,Array_4_SpiceDouble),r,q)
        ccall((:m2q_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64}),
            r_ptr,q_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return q
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Create a rotation matrix of 90 degrees about the Z axis.
#      %
#      r = cspice_rotate( cspice_halfpi, 3)
#
#   MATLAB outputs:
#
#      r =
#
#         0.00000000000000   1.00000000000000                  0
#        -1.00000000000000   0.00000000000000                  0
#                        0                  0   1.00000000000000
#
#      q = m2q( r )
#
#   MATLAB outputs:
#
#      q =
#
#         0.70710678118655
#                        0
#                        0
#        -0.70710678118655
#
#      %            _
#      % Confirm || q || = 1.
#      %
#      q'  * q
#
#   MATLAB outputs:
#
#      ans =
#
#           1
#
#-Version
#
#    -Mice Version 1.0.0, 10-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #    ##    #    #  ######  #####   #    #
#    ##   #   #  #   ##  ##  #       #    #  ##  ##
#    # #  #  #    #  # ## #  #####   #    #  # ## #
#    #  # #  ######  #    #  #       #####   #    #
#    #   ##  #    #  #    #  #       #   #   #    #
#    #    #  #    #  #    #  #       #    #  #    #
#
#   frame name to frame ID code translation
#
################################################################################
#-Abstract
#
#   namfrm retrieves the SPICE frame ID code associated
#   with a frame name.
#
#-I/O
#
#   Given:
#
#      frname   the name of some reference frame (either inertial or
#               non-inertial).
#
#               [n,m] = size(frname); char = class(frname)
#
#                  of
#
#               [1,n] = size(frname); cell = class(frname)
#
#               Leading blanks in 'frname' are ignored as is character case.
#
#               Note that all legitimate frame names contain 32 or fewer
#               characters.
#
#   the call:
#
#      frcode = namfrm(frname)
#
#   returns:
#
#      frcode   the SPICE code(s) used for internal representation of the named
#               reference frame.
#
#               [1,n] = size(frcode); int32 = class(frcode)
#
#               If the name input through frname is not recognized, 'frcode'
#               will be returned with a value of zero.
#
#              'frcode' returns with the same vectorization measure (N)
#               as 'frname'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine namfrm_c.
#
#   MICE.REQ
#   FRAMES.REQ
#
    function # namfrm
#       (frcode::Int32) =   # Ptr{SpiceInt}
        namfrm(
            frname::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        frcode = Array{Int32}(1);  # Ptr{SpiceInt}
        frcode_ptr = pointer(frcode)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:namfrm_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceInt}),frname,frcode)
        ccall((:namfrm_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Int32}),
            frname,frcode_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return frcode[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Retrieve frame information for a single frame.
#      %
#      disp('Scalar' )
#      name = 'ITRF93';
#
#      %
#      % Output the frame name corresponding to 'name'.
#      %
#      frcode = namfrm( name )
#
#
#      %
#      % Retrieve frame information for a vector of names.
#      % Create a vector of frame IDs, 1 to 5.
#      %
#      disp('Vector' )
#      codes = [1:5];
#
#      %
#      % Convert 'codes' to the corresponding frame name.
#      % 
#      names = cspice_frmnam( codes );
#
#      %
#      % Output the frame IDs corresponding to 'names'.
#      % The result should match the 'codes' vector'.
#      %
#      frcode = namfrm( names )
#
#  MATLAB outputs:
#
#      Scalar
#
#      frcode =
#
#             13000
#
#      Vector
#
#      frcode =
#
#                 1           2           3           4           5
#
#-Version
#
#   -Mice Version 1.0.0, 14-NOV-2014, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  ######    ##    #####   #####    #####
#    ##   #  #        #  #   #    #  #    #     #
#    # #  #  #####   #    #  #    #  #    #     #
#    #  # #  #       ######  #####   #####      #
#    #   ##  #       #    #  #   #   #          #
#    #    #  ######  #    #  #    #  #          #
#
#   distance from point to ellipsoid
#   nearest point on an ellipsoid
#
################################################################################
#-Abstract
#
#   nearpt calculates the point on the surface of an
#   ellipsoid nearest to a specified off-ellipsoid position.
#   The routine also returns the altitude of the position
#   above the ellipsoid
#
#-I/O
#
#   Given:
#
#      positn   a double precision position 3-vector or 3XN array defining the
#               position of a point with respect to the center of an
#               ellipsoid. The vector is expressed in a body-fixed reference
#               frame. The semi-axes of the ellipsoid are aligned with the
#               x, y, and z-axes of the body-fixed frame.
#
#      a,       the scalar double precision values of the ellipsoid's
#      b,       triaxial radii ellipsoid, where:
#      c
#                  'a' is length in kilometers of the semi-axis of the ellipsoid
#                   parallel to the x-axis of the body-fixed reference frame
#
#                  'b' is length in kilometers of the semi-axis of the ellipsoid
#                   parallel to the y-axis of the body-fixed reference frame
#
#                  'c' is length in kilometers of the semi-axis of the ellipsoid
#                   parallel to the z-axis of the body-fixed reference frame
#
#   the call:
#
#      [ npoint, alt ] = nearpt( positn, a, b, c )
#
#   returns:
#
#      npoint   the double precision 3-vector or 3xN array defining the
#               location on the ellipsoid closest to 'positn'
#
#      alt      the double precision scalar or 1xN array of altitudes of
#              'positn' above the ellipsoid.  If 'positn' is inside the
#               ellipsoid, 'alt' will be negative and have magnitude
#               equal to the distance between 'pos' and 'positn'.
#
#               'npoint' and 'alt' return with the same vectorization
#               measure (N) as 'positn'
#
#-Particulars
#
#   A sister version of this routine exists named mice_nearpt that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine nearpt_c.
#
#   MICE.REQ
#
    function # nearpt
#       (npoint::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        alt::Float64) =   # Ptr{SpiceDouble}
        nearpt(
            positn::Array{Float64,1}, # Array_3_ConstSpiceDouble
            a::Float64, # SpiceDouble
            b::Float64, # SpiceDouble
            c::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(positn) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        npoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        npoint_ptr = pointer(npoint)
        alt = Array{Float64}(1);  # Ptr{SpiceDouble}
        alt_ptr = pointer(alt)
        
#       make transposed copies of all input arrays and their pointers
        positn_t = positn'
        positn_ptr = pointer(positn_t)
        
#       ccall((:nearpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble}),positn,a,b,c,npoint,alt)
        ccall((:nearpt_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Float64,Float64,Ptr{Float64},Ptr{Float64}),
            positn_ptr,a,b,c,npoint_ptr,alt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return npoint, alt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Example(1):
#
#      %
#      % Define the radii of an ellipsoid.
#      %
#      a  =  1.;
#      b  =  2.;
#      c  =  3.;
#
#      %
#      % Use point on the X axis, outside the ellipsoid.
#      %
#      point        = [ 3.5; 0.; 0. ];
#      [pnear, alt] = nearpt( point, a, b, c)
#
#   MATLAB outputs:
#
#      pnear =
#
#           1
#           0
#           0
#
#      alt =
#
#         2.50000000000000
#
#      Example(2):
#
#      %
#      % Load a meta kernel containing SPK and leapseconds kernels.
#      %
#      cspice_furnsh( 'standard.tm')
#
#      %
#      % Retrieve the position of the Moon wrt the Earth at
#      % ephemeris time 0.d (Jan 1 2000 12:00 TDB) in the Earth-fixed
#      % reference frame.
#      %
#      epoch       = 0.;
#      abcorr      = 'LT+S';
#      [pos,ltime] = cspice_spkpos( 'moon', epoch, 'IAU_EARTH', ...
#                                    abcorr, 'earth');
#
#      %
#      % Retrieve the triaxial radii for Earth (body ID 399).
#      %
#      radii = cspice_bodvrd( 'EARTH', 'RADII', 3);
#
#      %
#      % Now calculate the point on the Earth nearest to the Moon
#      % given LT+S aberration correction at the epoch time.
#      %
#      [npoint,alt]= nearpt( pos, radii(1), radii(2), radii(3) )
#
#
#   MATLAB outputs:
#
#      npoint =
#
#         1.0e+03 *
#
#         3.34708386495926
#        -5.29453888129091
#        -1.19828126398311
#
#      alt =
#
#         3.960372197033597e+05
#
#-Version
#
#   -Mice Version 1.0.0, 21-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   ######  #####   #       #    #
#    ##   #  #    #  #       #    #  #       ##   #
#    # #  #  #    #  #####   #    #  #       # #  #
#    #  # #  #####   #       #    #  #       #  # #
#    #   ##  #       #       #    #  #       #   ##
#    #    #  #       ######  #####   ######  #    #
#
#   distance between line and ellipsoid
#   distance between line of sight and body
#   nearest point on ellipsoid to line
#
################################################################################
#-Abstract
#
#   npedln calculates the nearest point on a triaxial
#   ellipsoid to a specified line, and the distance from the
#   ellipsoid point to the line.
#
#-I/O
#
#   Given:
#
#      a        
#      b        
#      c        [1,1] = size(a); double = class(a)
#               [1,1] = size(b); double = class(b)
#               [1,1] = size(c); double = class(c)
#
#               are the lengths of the semi-axes of a triaxial ellipsoid.
#               The ellipsoid is centered at the origin and oriented so that
#               its axes lie on the x, y and z axes. 'a', 'b', and 'c' are
#               the lengths of the semi-axes that respectively point in the
#               x, y, and z directions.
#
#      linept   
#      linedr   [3,n] = size(linept); double = class(linept)
#               [3,n] = size(linedr); double = class(linedr)
#
#               are, respectively, a point and a direction vector that define a
#               line.  The line is the set of vectors
#
#                     linept   +   t * linedr
#
#               where t is any real number.
#
#   the call:
#
#      [ pnear, dist ] = npedln( a, b, c, linept, linedr )
#
#   returns:
#
#      pnear   the point on the ellipsoid closest to the line, if the line
#              doesn't intersect the ellipsoid.
#
#              [3,n] = size(pnear); double = class(pnear)
#
#              If the line intersects the ellipsoid, pnear will be a point
#              of intersection.  If linept is outside of the ellipsoid, 'pnear'
#              will be the closest point of intersection.  If linept is inside
#              ellipsoid, pnear will not necessarily be the  the closest point
#              of intersection.
#
#      dist    , the distance of the line from the ellipsoid. This is the
#              minimum distance between any point on the line and any point on
#              the ellipsoid.
#
#              [1,n] = size(dist); double = class(dist)
#
#              If the line intersects the ellipsoid, 'dist' is zero.
#
#-Particulars
#
#   For any ellipsoid and line, if the line does not intersect the
#   ellipsoid, there is a unique point on the ellipsoid that is
#   closest to the line.  Therefore, the distance dist between
#   ellipsoid and line is well-defined.  The unique line segment of
#   length dist that connects the line and ellipsoid is normal to
#   both of these objects at its endpoints.
#
#   If the line intersects the ellipsoid, the distance between the
#   line and ellipsoid is zero.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine npedln_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # npedln
#       (pnear::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        dist::Float64) =   # Ptr{SpiceDouble}
        npedln(
            a::Float64, # SpiceDouble
            b::Float64, # SpiceDouble
            c::Float64, # SpiceDouble
            linept::Array{Float64,1}, # Array_3_ConstSpiceDouble
            linedr::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(linept) != 3
            error("Incorrect size for parameter 4")
        end
        if length(linedr) != 3
            error("Incorrect size for parameter 5")
        end
#       allocate the output parameters
        pnear = Array{Float64,1}(3);  # Array_3_SpiceDouble
        pnear_ptr = pointer(pnear)
        dist = Array{Float64}(1);  # Ptr{SpiceDouble}
        dist_ptr = pointer(dist)
        
#       make transposed copies of all input arrays and their pointers
        linept_t = linept'
        linept_ptr = pointer(linept_t)
        linedr_t = linedr'
        linedr_ptr = pointer(linedr_t)
        
#       ccall((:npedln_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble}),a,b,c,linept,linedr,pnear,dist)
        ccall((:npedln_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            a,b,c,linept_ptr,linedr_ptr,pnear_ptr,dist_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return pnear, dist[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % We can find the distance between an instrument optic axis ray
#      % and the surface of a body modeled as a tri-axial ellipsoid
#      % using this routine.  If the instrument position and pointing
#      % unit vector in body-fixed coordinates are:
#      %
#      linept = [ 1.0e6,  2.0e6,  3.0e6 ]';
#      linedr = [ -4.472091234e-1, -8.944182469e-1, -4.472091234e-3 ]';
#
#      %
#      % The body semi-axes lengths:
#      %
#      a = 7.0e5;
#      b = 7.0e5;
#      c = 6.0e5;
#
#      %
#      % The call to npedln yields a value for 'pnear', the nearest
#      % point on the body to the optic axis ray and a value for 'dist',
#      % the distance to the ray.
#      %
#      [ pnear, dist ] = npedln( a, b, c, linept, linedr )
#
#   MATLAB outputs:
#
#      pnear =
#
#          -1.633311079234085e+03
#          -3.266622215782081e+03
#           5.999918335000672e+05
#
#      dist =
#
#           2.389967933829971e+06
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   ######  #       #####    #####
#    ##   #  #    #  #       #       #    #     #
#    # #  #  #    #  #####   #       #    #     #
#    #  # #  #####   #       #       #####      #
#    #   ##  #       #       #       #          #
#    #    #  #       ######  ######  #          #
#
#   nearest point on ellipse to point
#
################################################################################
#-Abstract
#
#   npelpt calculates the location on an ellipse closest
#   to a specified point, both in three-dimensional space,
#   and the distance between the ellipse and the point.
#
#-I/O
#
#   Given:
#
#      point     a 3-vector defining a location in 3-dimensional space.
#
#                [3,1] = size(point); double = class(point)
#
#      ellipse   a SPICE ellipse.
#
#                [1,1] = size(ellipse); struct = class(ellipse)
#
#                The structure has the fields:
#
#                center:    [3,1] = size(center); double = class(center)
#                semiMinor: [3,1] = size(semiMinor); double = class(semiMinor)
#                semiMajor: [3,1] = size(semiMajor); double = class(semiMajor)
#
#   the call:
#
#      [ pnear, dist ] = npelpt( point, ellipse )
#
#   returns:
#
#      pnear   the 3-vector defining the location on the ellipse nearest
#              to 'point'.
#
#              [3,1] = size(point); double = class(point)
#
#      dist    the distance between the calculated point 'pnear' 
#              and 'point'.
#
#              dist = || pnear - point ||
#
#              [1,1] = size(dist); double = class(dist)
#
#-Particulars
#
#   Given an ellipse and a point in 3-dimensional space, if the
#   orthogonal projection of the point onto the plane of the ellipse
#   is on or outside of the ellipse, then there is a unique point on
#   the ellipse closest to the original point.  This routine finds
#   that nearest point on the ellipse.  If the projection falls inside
#   the ellipse, there may be multiple points on the ellipse that are
#   at the minimum distance from the original point.  In this case,
#   one such closest point will be returned.
#
#   This routine returns a distance, rather than an altitude, in
#   contrast to the Icy routine cspice_nearpt.  Because our ellipse is
#   situated in 3-space and not 2-space, the input point is not
#   `inside' or `outside' the ellipse, so the notion of altitude does
#   not apply to the problem solved by this routine.  In the case of
#   cspice_nearpt, the input point is on, inside, or outside the ellipsoid,
#   so it makes sense to speak of its altitude.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine npelpt_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # npelpt
#       (pnear::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        dist::Float64) =   # Ptr{SpiceDouble}
        npelpt(
            point::Array{Float64,1}, # Array_3_ConstSpiceDouble
            ellips::NasaSpice.Ellipse) # Ptr{ConstSpiceEllipse}
        
#       enforce input array sizes
        if length(point) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        pnear = Array{Float64,1}(3);  # Array_3_SpiceDouble
        pnear_ptr = pointer(pnear)
        dist = Array{Float64}(1);  # Ptr{SpiceDouble}
        dist_ptr = pointer(dist)
        
#       make transposed copies of all input arrays and their pointers
        point_t = point'
        point_ptr = pointer(point_t)
        ioellips = IOBuffer()
        StrPack.pack( ioellips, ellips)
        ellips_ptr = convert( Ptr{Ptr{ConstSpiceEllipse}}, convert( Ptr{Void}, pointer(ioellips.data) ) )
        
#       ccall((:npelpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{ConstSpiceEllipse},Array_3_SpiceDouble,Ptr{SpiceDouble}),point,ellips,pnear,dist)
        ccall((:npelpt_c,libNasaSpice),Void,
            (Ptr{Float64},NasaSpice.Ellipse,Ptr{Float64},Ptr{Float64}),
            point_ptr,ellips,pnear_ptr,dist_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return pnear, dist[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#-Version
#
#   -Mice Version 1.0.0, 14-NOV-2014, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   #       #    #  #####    #####
#    ##   #  #    #  #       ##   #  #    #     #
#    # #  #  #    #  #       # #  #  #    #     #
#    #  # #  #####   #       #  # #  #####      #
#    #   ##  #       #       #   ##  #          #
#    #    #  #       ######  #    #  #          #
#
#   distance between point and line
#   nearest point on line to point
#
################################################################################
#-Abstract
#
#   nplnpt calculates the location on a defined line
#   nearest to a specified point, then determines the distance
#   between the two points.
#
#-I/O
#
#   Given:
#
#      linpt    [3,1] = size(linpt); double = class(linpt)
#
#      lindir   [3,1] = size(lindir); double = class(lindir)
#
#               are, respectively, a point and a direction vector that define
#               a line.  The line is the set of vectors
#
#                     linept   +   t * linedr
#
#               where t is any real number.
#
#      point    a point in 3-dimensional space.
#
#               [3,n] = size(point); double = class(point)
#
#   the call:
#
#      [ pnear, dist ] = nplnpt( linpt, lindir, point )
#
#   returns:
#
#      pnear   the nearest point on the input line to the input 'point'.
#
#              [3,1] = size(pnear); double = class(pnear)
#
#      dist    distance between the input line and input point.
#
#              [1,n] = size(dist); double = class(dist)
#
#-Particulars
#
#   For every line L and point P, there is a unique closest point
#   on L to P.  Call this closest point C.  It is always true that
#   P - C  is perpendicular to L, and the length of P - C is called
#   the "distance" between P and L.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine nplnpt_c.
#
#   MICE.REQ
#
    function # nplnpt
#       (pnear::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        dist::Float64) =   # Ptr{SpiceDouble}
        nplnpt(
            linpt::Array{Float64,1}, # Array_3_ConstSpiceDouble
            lindir::Array{Float64,1}, # Array_3_ConstSpiceDouble
            point::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(linpt) != 3
            error("Incorrect size for parameter 1")
        end
        if length(lindir) != 3
            error("Incorrect size for parameter 2")
        end
        if length(point) != 3
            error("Incorrect size for parameter 3")
        end
#       allocate the output parameters
        pnear = Array{Float64,1}(3);  # Array_3_SpiceDouble
        pnear_ptr = pointer(pnear)
        dist = Array{Float64}(1);  # Ptr{SpiceDouble}
        dist_ptr = pointer(dist)
        
#       make transposed copies of all input arrays and their pointers
        linpt_t = linpt'
        linpt_ptr = pointer(linpt_t)
        lindir_t = lindir'
        lindir_ptr = pointer(lindir_t)
        point_t = point'
        point_ptr = pointer(point_t)
        
#       ccall((:nplnpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble}),linpt,lindir,point,pnear,dist)
        ccall((:nplnpt_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            linpt_ptr,lindir_ptr,point_ptr,pnear_ptr,dist_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return pnear, dist[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define a point on a line, a direction for the line, and
#      % an arbitrary point in space.
#      %
#      linept = [  1, 2,  3 ]';
#      linedr = [  0, 1,  1 ]';
#      point  = [ -6, 9, 10 ]';
#
#      %
#      % Calculate the location on the line nearest the point
#      % and the distance between the location and the defined
#      % point.
#      %
#      [ pnear, dist ] = nplnpt( linept, linedr, point )
#
#   MATLAB outputs:
#
#      pnear =
#
#           1
#           9
#          10
#
#
#      dist =
#
#           7
#
#-Version
#
#   -Mice Version 1.0.0, 14-NOV-2013, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#    #    #  #    #   ####  #     #  #####   #
#    ##   #  #    #  #    #       #  #    #  #
#    # #  #  #    #  #       #####   #    #  #
#    #  # #  #    #  #      #        #####   #
#    #   ##   #  #   #    # #        #       #
#    #    #    ##     ####  #######  #       ######
#
#   normal vector and constant to plane
#
################################################################################
#-Abstract
#
#   nvc2pl constructs a SPICE plane from a normal vector
#   and a constant.
#
#-I/O
#
#   Given:
#
#      normal     [3,1] = size(normal); double = class(normal)
#
#      constant   [1,1] = size(constant); double = class(constant)
#
#                 are, respectively, a normal vector and constant
#                 defining a plane. 'normal' need not be a unit
#                 vector.  Let the symbol < a, b > indicate the
#                 inner product of vectors a and b; then the
#                 then the geometric plane is the set of vectors x
#                 in three-dimensional space that satisfy
#
#                    < x,  normal >  =  constant.
#
#   the call:
#
#      plane = nvc2pl( normal, constant )
#
#   returns:
#
#      plane   a structure describing a SPICE plane defined by
#              'normal' and 'constant'
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#-Particulars
#
#   Mice geometry routines that deal with planes use the `plane'
#   data type to represent input and output planes.  This data type
#   makes the subroutine interfaces simpler and more uniform.
#
#   The Mice routines that produce SPICE planes from data that
#   define a plane are:
#
#      nvc2pl ( Normal vector and constant to plane )
#      cspice_nvp2pl ( Normal vector and point to plane    )
#      cspice_psv2pl ( Point and spanning vectors to plane )
#
#   The Mice routines that convert SPICE planes to data that
#   define a plane are:
#
#      cspice_pl2nvc ( Plane to normal vector and constant )
#      cspice_pl2nvp ( Plane to normal vector and point    )
#      cspice_pl2psv ( Plane to point and spanning vectors )
#
#   Any of these last three routines may be used to convert this
#   routine's output, 'plane', to another representation of a
#   geometric plane.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine nvc2pl_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # nvc2pl
#       (plane::NasaSpice.Plane) =   # Ptr{SpicePlane}
        nvc2pl(
            normal::Array{Float64,1}, # Array_3_ConstSpiceDouble
            constant::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(normal) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        plane = Plane()
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{SpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       make transposed copies of all input arrays and their pointers
        normal_t = normal'
        normal_ptr = pointer(normal_t)
        
#       ccall((:nvc2pl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,SpiceDouble,Ptr{SpicePlane}),normal,constant,plane)
        ccall((:nvc2pl_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Ptr{Ptr{SpicePlane}}),
            normal_ptr,constant,plane_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(ioplane,0)
        plane = StrPack.unpack( ioplane, Plane )
        return plane
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define an arbitrary normal and constant...
#      %
#      normal    = [ 1.; 1.; 1. ];
#      constant  = 23.;
#
#      %
#      % ...then construct the plane.
#      %
#      plane = nvc2pl( normal, constant );
#
#      plane.constant
#      plane.normal
#
#   Matlab outputs:
#
#      For plane.constant:
#
#      ans =
#
#         13.2791
#
#
#      For plane.normal:
#
#      ans =
#
#          0.5774
#          0.5774
#          0.5774
#
#-Version
#
#   -Mice Version 1.0.1, 27-AUG-2012, EDW (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 30-DEC-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#    #    #  #    #  #####  #     #  #####   #
#    ##   #  #    #  #    #       #  #    #  #
#    # #  #  #    #  #    #  #####   #    #  #
#    #  # #  #    #  #####  #        #####   #
#    #   ##   #  #   #      #        #       #
#    #    #    ##    #      #######  #       ######
#
#   normal vector and point to plane
#
################################################################################
#-Abstract
#
#   CSPICE_NVC2PL constructs a SPICE plane from a normal vector and a point
#   on the plane.
#
#-I/O
#
#   Given:
#
#      normal   [3,1] = size(normal); double = class(normal)
#
#      point    [3,1] = size(point); double = class(point)
#
#               are, respectively, a normal vector and point that
#               define a plane in three-dimensional space.  normal
#               need not be a unit vector. Let the symbol < a, b >
#               indicate the inner product of vectors a and b;
#               then the geometric plane is the set of vectors x
#               in three-dimensional space that satisfy
#
#                  < x - point, normal >  =  0.
#
#   the call:
#
#      plane = nvp2pl( normal, point )
#
#   returns:
#
#      plane   a structure describing a SPICE plane defined by
#              'normal' and 'point'
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#-Particulars
#
#   Mice geometry routines that deal with planes use the `plane'
#   data type to represent input and output planes.  This data type
#   makes the subroutine interfaces simpler and more uniform.
#
#   The Mice routines that produce SPICE planes from data that
#   define a plane are:
#
#      cspice_nvc2pl ( Normal vector and constant to plane )
#      nvp2pl ( Normal vector and point to plane    )
#      cspice_psv2pl ( Point and spanning vectors to plane )
#
#   The Mice routines that convert SPICE planes to data that
#   define a plane are:
#
#      cspice_pl2nvc ( Plane to normal vector and constant )
#      cspice_pl2nvp ( Plane to normal vector and point    )
#      cspice_pl2psv ( Plane to point and spanning vectors )
#
#   Any of these last three routines may be used to convert this
#   routine's output, 'plane', to another representation of a
#   geometric plane.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine nvp2pl_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # nvp2pl
#       (plane::NasaSpice.Plane) =   # Ptr{SpicePlane}
        nvp2pl(
            normal::Array{Float64,1}, # Array_3_ConstSpiceDouble
            point::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(normal) != 3
            error("Incorrect size for parameter 1")
        end
        if length(point) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        plane = Plane()
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{SpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       make transposed copies of all input arrays and their pointers
        normal_t = normal'
        normal_ptr = pointer(normal_t)
        point_t = point'
        point_ptr = pointer(point_t)
        
#       ccall((:nvp2pl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Ptr{SpicePlane}),normal,point,plane)
        ccall((:nvp2pl_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Ptr{SpicePlane}}),
            normal_ptr,point_ptr,plane_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(ioplane,0)
        plane = StrPack.unpack( ioplane, Plane )
        return plane
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define a normal vector from a plane and a
#      % point in a plane.
#      %
#      normal = [ -1.;  5.;   -3.5 ];
#      point  = [  9.; -0.65; -12. ];
#
#      %
#      % Create a plane from the vectors.
#      %
#      plane = nvp2pl( normal, point );
#
#      %
#      % Calculate a point in the plane, and
#      % two spanning vectors in the plane such that
#      % the point and spanning are mutually orthogonal.
#      %
#      [point, span1, span2] = cspice_pl2psv( plane )
#
#      %
#      % Test point, span1, and span2 orthogonality. The dot
#      % products of any two vectors should equal zero to
#      % within round-off.
#      %
#      fprintf( ' point . span1 : %18.15e\n', dot( point, span1) )
#      fprintf( ' point . span2 : %18.15e\n', dot( point, span2) )
#      fprintf( ' span1 . span2 : %18.15e\n', dot( span1, span2) )
#
#    Matlab outputs:
#
#        point =
#
#            -7.777777777777776e-01
#             3.888888888888888e+00
#            -2.722222222222222e+00
#
#
#        span1 =
#
#                                 0
#             5.734623443633283e-01
#             8.192319205190405e-01
#
#
#        span2 =
#
#             9.868415319342446e-01
#             1.324619505952006e-01
#            -9.272336541664042e-02
#
#        dot( point, span1) = 0.000000000000000e+00
#        dot( point, span2) = 5.551115123125783e-17
#        dot( span1, span2) = 0.000000000000000e+00
#
#-Version
#
#   -Mice Version 1.0.1, 27-AUG-2012, EDW (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 30-DEC-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    ####    ####   #    #  #        #####
#    #    #  #    #  #    #  #    #  #          #
#    #    #  #       #       #    #  #          #
#    #    #  #       #       #    #  #          #
#    #    #  #    #  #    #  #    #  #          #
#     ####    ####    ####    ####   ######     #
#
#   occultation type at a specified time
#
################################################################################
#-Abstract
#
#   occult determines the occultation condition (not occulted,
#   partially, etc.) of one target relative to another target as seen
#   by an observer at a given time.
#
#-I/O
#
#   Given:
#
#       target1   is the name of the first target body. Both object
#                 names and NAIF IDs are accepted. For example, both
#                 'Moon' and '301' are accepted.
#
#                 [1,a] = size(target1), char = class(target1)
#
#       shape1    is a string indicating the geometric model used to
#                 represent the shape of the first target body.
#
#                 [1,b] = size(shape1), char = class(shape1)
#
#                 The supported options are:
#
#                    'ELLIPSOID'     Use a triaxial ellipsoid model
#                                    with radius values provided via the
#                                    kernel pool. A kernel variable
#                                    having a name of the form
#
#                                       'BODYnnn_RADII'
#
#                                    where nnn represents the NAIF
#                                    integer code associated with the
#                                    body, must be present in the kernel
#                                    pool. This variable must be
#                                    associated with three numeric
#                                    values giving the lengths of the
#                                    ellipsoid's X, Y, and Z semi-axes.
#
#                    'POINT'         Treat the body as a single point.
#                                    When a point target is specified,
#                                    the occultation type must be
#                                    set to 'ANY'.
#
#                 At least one of the target bodies 'target1' or 'target2'
#                 must be modeled as an ellipsoid.
#
#                 Case and leading or trailing blanks are not
#                 significant in the string.
#
#       frame1    is the name of the body-fixed, body-centered reference
#                 frame associated with the first target body. Examples
#                 of such names are 'IAU_SATURN' (for Saturn) and
#                 'ITRF93' (for the Earth).
#
#                 [1,c] = size(frame1), char = class(frame1)
#
#                 If the first target body is modeled as a point, 'frame1'
#                 should be left blank (Ex: ' ').
#
#                 Case and leading or trailing blanks bracketing a
#                 non-blank frame name are not significant in the string.
#
#       target2   is the name of the second target body. See the description
#                 of 'target1' above for more details.
#
#                 [1,d] = size(target2), char = class(target2)
#
#       shape2    is the shape specification for the body designated
#                 by 'target2'. See the description of 'shape1' above for
#                 details.
#
#                 [1,e] = size(shape2), char = class(shape2)
#
#       frame2    is the name of the body-fixed, body-centered reference
#                 frame associated with the second target body. See the
#                 description of 'frame1' above for more details.
#
#                 [1,f] = size(frame2), char = class(frame2)
#
#       abcorr    indicates the aberration corrections to be applied to
#                 the state of each target body to account for one-way
#                 light time. Stellar aberration corrections are
#                 ignored if specified, since these corrections don't
#                 improve the accuracy of the occultation determination.
#
#                 [1,g] = size(abcorr), char = class(abcorr)
#
#                 See the header of the SPICE routine spkezr_c for a
#                 detailed description of the aberration correction
#                 options. For convenience, the options supported by
#                 this routine are listed below:
#
#                    'NONE'     Apply no correction.
#
#                    'LT'       "Reception" case: correct for
#                               one-way light time using a Newtonian
#                               formulation.
#
#                    'CN'       "Reception" case: converged
#                               Newtonian light time correction.
#
#                    'XLT'      "Transmission" case: correct for
#                               one-way light time using a Newtonian
#                               formulation.
#
#                    'XCN'      "Transmission" case: converged
#                               Newtonian light time correction.
#
#                 Case and blanks are not significant in the string
#                 'abcorr'.
#
#       observer  is the name of the body from which the occultation
#                 is observed. See the description of 'target1' for more
#                 details.
#
#                 [1,h] = size(observer), char = class(observer)
#
#       time      is the observation time in seconds past the J2000
#                 epoch.
#
#                 [1,n] = size(time), double = class(time)
#
#   the call:
#
#       occult_code = occult ( target1, shape1,   frame1, ...
#                                     target2, shape2,   frame2, ...
#                                     abcorr,  observer, time )
#
#   returns:
#
#       occult_code   is an integer occultation code indicating the geometric
#                     relationship of the three bodies.
#
#                     [1,n] = size(occult_code), double = class(occult_code)
#
#                     The meaning of the sign of 'occult_code' is given below.
#
#                        Code sign          Meaning
#                        ---------          ------------------------------
#                           > 0             The second ellipsoid is
#                                           partially or fully occulted
#                                           by the first.
#
#                           < 0             The first ellipsoid is
#                                           partially of fully
#                                           occulted by the second.
#
#                           = 0             No occultation.
#
#                     Possible 'occult_code' values and meanings are given
#                     below. The variable names indicate the type of
#                     occultation and which target is in the back. For example,
#                     MICE_OCCULT_TOTAL1_BACK represents a total occultation in
#                     which the first target is in the back (or occulted by)
#                     the second target. The variable names can be used in a
#                     program by calling 'MiceUser' as shown in the
#                     example program below.
#
#                        Name                    Code   Meaning
#                        ------                  -----  -----------------------
#                        MICE_OCCULT_TOTAL1_BACK  -3    Total occultation of
#                                                       first target by second.
#
#                        MICE_OCCULT_ANNLR1_BACK  -2    Annular occultation of
#                                                       first target by second.
#                                                       The second target does
#                                                       not block the limb of
#                                                       the first.
#
#                        MICE_OCCULT_PARTL1_BACK  -1    Partial occultation of
#                                                       first target by second
#                                                       target.
#
#                        MICE_OCCULT_NOOCC         0    No occultation or
#                                                       transit: both objects
#                                                       are completely visible
#                                                       to the observer.
#
#                        MICE_OCCULT_PARTL2_BACK   1    Partial occultation of
#                                                       second target by first
#                                                       target.
#
#                        MICE_OCCULT_ANNLR2_BACK   2    Annular occultation of
#                                                       second target by first.
#
#                        MICE_OCCULT_TOTAL2_BACK   3    Total occultation of
#                                                       second target by first.
#
#-Particulars
#
#   For many purposes, modeling extended bodies as triaxial
#   ellipsoids is adequate for determining whether one body is
#   occulted by another as seen from a specified observer.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine occult_c.
#
    function # occult
        occult(
            target1::AbstractString, # Ptr{ConstSpiceChar}
            shape1::AbstractString, # Ptr{ConstSpiceChar}
            frame1::AbstractString, # Ptr{ConstSpiceChar}
            target2::AbstractString, # Ptr{ConstSpiceChar}
            shape2::AbstractString, # Ptr{ConstSpiceChar}
            frame2::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            observer::AbstractString, # Ptr{ConstSpiceChar}
            time::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:occult_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{SpiceInt}),target1,shape1,frame1,target2,shape2,frame2,abcorr,observer,time,occult_code)
        ccall((:occult_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Float64),
            target1,shape1,frame1,target2,shape2,frame2,abcorr,observer,time)
    
#       unpack any structures and transpose back any returned arrays
        return 
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example(1):
#
#      Find whether MRO is occulted by Mars as seen by
#      the DSS-13 ground station at a few specific
#      times.
#
#         KPL/MK
#
#         File: mro_ex_occult.tm
#
#         This is the meta-kernel file for the example problem for
#         the subroutine occult_c. These kernel files can be found in
#         the NAIF archives.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#               File name                       Contents
#               ---------                       --------
#               de421.bsp                       Planetary ephemeris
#               earthstns_itrf93_050714.bsp     DSN station ephemeris
#               pck00010.tpc                    Planet orientation and
#                                               radii
#               earth_000101_120409_120117.bpc  High precision Earth
#                                               orientation
#               mro_psp_rec.bsp                 MRO ephemeris
#               naif0010.tls                    Leapseconds
#               earth_topo_050714.tf            Topocentric reference
#                                               frames for
#                                               DSN stations
#
#         \begindata
#
#         KERNELS_TO_LOAD = ( 'de421.bsp',
#                             'earthstns_itrf93_050714.bsp',
#                             'pck00010.tpc',
#                             'earth_000101_120409_120117.bpc',
#                             'mro_psp_rec.bsp',
#                             'naif0010.tls',
#                             'earth_topo_050714.tf' )
#         \begintext
#
#         End of meta-kernel
#
#      Example program starts here.
#
#         %
#         %   MiceUser is a file that makes occultation-specific
#         %   variables global. You must call MiceUser to have access to
#         %   these variable names. These variables are defined so you don't
#         %   need to remember what the integer codes mean that the
#         %   occultation routine returns. For more information, please see
#         %   MiceUser.m and MiceOccult.m.
#         %
#         MiceUser;
#
#         target1  = 'MRO';
#         shape1   = 'point';
#         target2  = 'Mars';
#         shape2   = 'ellipsoid';
#         observer = 'DSS-13';
#         dt = 1000;
#         out_form = '%s %s %s %s wrt %s\n';
#         out_char = ['totally occulted by  ';
#                     'transited by         ';
#                     'partially occulted by';
#                     'not occulted by      '];
#
#         %
#         %   Load the meta kernel.
#         %
#         cspice_furnsh ( 'mro_ex_occult.tm' );
#
#         et_start = cspice_str2et ( '2012-jan-5 1:15:00 UTC' );
#         et_stop  = cspice_str2et ( '2012-jan-5 2:50:00 UTC' );
#
#         for et = et_start : dt : et_stop
#
#             %
#             %   Calculate the type of occultation that
#             %   corresponds to time ET.
#             %
#             occult_code = occult ( target1, shape1, ' ', ...
#                                           target2, shape2, 'iau_mars', ...
#                                           'cn', observer, et );
#             %
#             %   Output the results.
#             %
#             time = cspice_timout ( et, 'YYYY-MM-DD HR:MN ::UTC-8');
#
#             %
#             %   Remember: You must call 'MiceUser' before
#             %   using the parameters like 'MICE_OCCULT_TOTAL1_BACK' in
#             %   the case statements below.
#             %
#             switch occult_code
#                 case MICE_OCCULT_TOTAL1_BACK
#                     fprintf (out_form, time, target1, out_char(1,:), ...
#                              target2,  observer )
#                 case MICE_OCCULT_ANNLR1_BACK
#                     fprintf (out_form, time, target1, out_char(2,:), ...
#                              target2,  observer )
#                 case MICE_OCCULT_PARTL1_BACK
#                     fprintf (out_form, time, target1, out_char(3,:), ...
#                              target2,  observer )
#                 case MICE_OCCULT_NOOCC
#                     fprintf (out_form, time, target1, out_char(4,:), ...
#                              target2,  observer )
#                 case MICE_OCCULT_PARTL2_BACK
#                     fprintf (out_form, time, target2, out_char(3,:), ...
#                              target1,  observer )
#                 case MICE_OCCULT_ANNLR2_BACK
#                     fprintf (out_form, time, target2, out_char(2,:), ...
#                              target1,  observer )
#                 case MICE_OCCULT_TOTAL2_BACK
#                     fprintf (out_form, time, target2, out_char(1,:), ...
#                              target1,  observer )
#                 otherwise
#                     fprintf ( 'Bad occultation code: %d\n', occult_code )
#             end
#
#         end
#
#         %
#         %   Unload kernels
#         %
#         cspice_kclear
#
#   MATLAB outputs:
#
#         2012-01-04 17:15 Mars transited by          MRO wrt DSS-13
#         2012-01-04 17:31 MRO not occulted by       Mars wrt DSS-13
#         2012-01-04 17:48 MRO totally occulted by   Mars wrt DSS-13
#         2012-01-04 18:04 MRO totally occulted by   Mars wrt DSS-13
#         2012-01-04 18:21 MRO not occulted by       Mars wrt DSS-13
#         2012-01-04 18:38 Mars transited by          MRO wrt DSS-13
#
#-Version
#
#   -Mice Version 1.0.0, 14-NOV-2013, SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
#   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
#   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
#   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
#   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
#   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
#   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
#   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
#   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
#   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
#   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
#   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    ####    ####   ######  #        #####
#    #    #  #       #    #  #       #          #
#    #    #   ####   #       #####   #          #
#    #    #       #  #       #       #          #
#    #    #  #    #  #    #  #       #          #
#     ####    ####    ####   ######  ######     #
#
#   conic elements from state
#   osculating elements from state
#   convert state to osculating elements
#
################################################################################
#-Abstract
#
#   oscelt calculates the set of osculating conic
#   orbital elements corresponding to the state 6-vector
#   (position, velocity) of a body at an epoch.
#
#-I/O
#
#   Given:
#
#      state  a double precision 6-vector or 6xN array of
#             states of the body at some epoch. Components
#             are x, y, z, dx/dt, dy/dt, dz/dt. `state' must be
#             expressed relative to an inertial reference frame.
#             Units are km and km/sec.
#
#      et     the double precision scalar or 1XN-vector of ephemeris
#             time epochs corresponding to each 'state' in ephemeris
#             seconds past J2000
#
#      mu     the gravitational parameter of the primary
#             body for 'state'
#
#   the call:
#
#      elts = oscelt( state, et, mu )
#
#   returns:
#
#      elts   a double precision 8-vector or 8xN array containing
#             the equivalent conic elements describing the orbit
#             of the body around its primary. The elements are,
#             in order:
#
#                 elts(1)  contains rp, perifocal distance.
#                 elts(2)  contains ecc, eccentricity.
#                 elts(3)  contains inc, inclination.
#                 elts(4)  contains lnode, longitude of the ascending node.
#                 elts(5)  contains argp, argument of periapsis.
#                 elts(6)  contains m0, mean anomaly at epoch.
#                 elts(7)  contains t0, epoch.
#                 elts(8)  contains mu, gravitational parameter.
#
#             The epoch of the elements is the epoch of the input
#             state. Units are km, rad, rad/sec. The same elements
#             are used to describe all three types (elliptic,
#             hyperbolic, and parabolic) of conic orbit
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine oscelt_c.
#
#   MICE.REQ
#
    function # oscelt
#       (elts::Array{Float64,1}(8)) =   # Array_8_SpiceDouble
        oscelt(
            state::Array{Float64,1}, # Array_6_ConstSpiceDouble
            et::Float64, # SpiceDouble
            mu::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(state) != 6
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        elts = Array{Float64,1}(8);  # Array_8_SpiceDouble
        elts_ptr = pointer(elts)
        
#       make transposed copies of all input arrays and their pointers
        state_t = state'
        state_ptr = pointer(state_t)
        
#       ccall((:oscelt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,SpiceDouble,SpiceDouble,Array_8_SpiceDouble),state,et,mu,elts)
        ccall((:oscelt_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Float64,Ptr{Float64}),
            state_ptr,et,mu,elts_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return elts
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#      Example(1):
#
#      %
#      % Determine the osculating elements of the moon wrt the
#      % Earth at some arbitrary time in the J2000 inertial frame.
#      %
#      % Load the meta kernel listing the needed SPK, PCK, LSK
#      % kernels.
#      %
#      cspice_furnsh('standard.tm' )
#
#      %
#      % Convert the time string to ephemeris time
#      %
#      et = cspice_str2et( 'Dec 25, 2007' );
#
#      %
#      % Make the cspice_spkezr call to retrieve the state of the
#      % moon wrt the Earth in J2000.
#      %
#      [state, ltime] = cspice_spkezr( 'Moon', et, 'J2000', 'LT+S', 'EARTH' );
#
#      %
#      % oscelt requires body mass information, so load a
#      % mass PCK kernel.
#      %
#      cspice_furnsh( '/kernels/gen/pck/masses3.tpc' )
#
#      %
#      % Read the gravitational parameter for Earth.
#      %
#      mu = cspice_bodvrd( 'EARTH', 'GM', 1 );
#
#      %
#      % make the oscelt call to convert the state 6-vector
#      % to the elts 8-vector. Note: the  cspice_bodvrd returns
#      % data as arrays, so to access the gravitational parameter
#      % (the only value in the array), we use mu(1).
#      %
#      elts = oscelt( state, et, mu(1) );
#
#      %
#      % Output the elts vector in a column format.
#      %
#      txt = sprintf( '%24.8f\n', elts );
#      disp( txt)
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#         360956.91440370
#              0.07820299
#              0.48717811
#              6.18584105
#              1.28603872
#              0.55386000
#      251812864.18370920
#         398600.44800000
#
#      Example(2):
#
#      %
#      % Calculate the history of the Moon's orbit plane
#      % inclination with respect to the Earth in the
#      % J2000 frame at intervals of one month for a
#      % time interval of 14 years.
#      %
#      % Load the needed SPK , PCK and LSK kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % oscelt also requires mass information, so load
#      % a mass PCK.
#      %
#      cspice_furnsh( '/kernels/gen/pck/masses3.tpc' )
#      mu = cspice_bodvrd( 'EARTH', 'GM', 1 );
#
#      %
#      % The start epoch.
#      %
#      et0 = cspice_str2et( 'Jan 1, 2000 12:00:00' );
#
#      %
#      % A step of one month - in seconds.
#      %
#      step = 30. * cspice_spd;
#
#      %
#      % Define an array of ephemeris times, covering,
#      % 14 years of months in steps of one month starting
#      % approximately Feb 1, 2000.
#      %
#      et = [0: (14*12) - 1]*step + et0;
#
#      % Retrieve the state; convert to osculating elements.
#      %
#      [state,ltime] = cspice_spkezr( 'Moon', et, 'J2000', 'LT+S', 'EARTH');
#      elts          = oscelt( state, et, mu(1) );
#
#      elts(3,:) = [ elts(3,:) * cspice_dpr ];
#
#      %
#      % Convert the ephemeris time of the state lookup to
#      % calendar UTC, then print the calendar string and the
#      % inclination in degrees of the Moon wrt Earth at the
#      % time.
#      %
#      utcstr = cspice_et2utc( et, 'C', 3, );
#
#      %
#      % Convert the angular measures to degrees.
#      %
#
#      %
#      % Output the epoch and corresponding inclination.
#      %
#      for n=1:14*12
#         fprintf( '%s %12.6f\n', utcstr(n,:), elts(3,n) );
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      ... a partial output ...
#
#      2012 NOV 23 12:00:00.001    20.903479
#      2012 DEC 23 12:00:00.000    20.902973
#      2013 JAN 22 11:59:59.999    20.802204
#      2013 FEB 21 11:59:59.999    20.565404
#      2013 MAR 23 11:59:59.998    20.309740
#      2013 APR 22 11:59:59.998    20.171117
#      2013 MAY 22 11:59:59.999    20.162453
#      2013 JUN 21 12:00:00.000    20.173366
#      2013 JUL 21 12:00:00.000    20.082464
#      2013 AUG 20 12:00:00.001    19.867300
#      2013 SEP 19 12:00:00.002    19.628911
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####   #####   #####   ######   ####
#    #    #  #    #  #    #  #    #  #       #    #
#    #    #  #       #    #  #    #  #####   #
#    #####   #  ###  #####   #####   #       #
#    #       #    #  #   #   #   #   #       #    #
#    #        ####   #    #  #    #  ######   ####
#
#   convert planetographic to rectangular coordinates
#
################################################################################
#-Abstract
#
#   pgrrec converts planetographic coordinates to
#   rectangular coordinates.
#
#-I/O
#
#   Given:
#
#      body   name of the body with which the planetographic coordinate system
#             is associated, optionally, you may supply the integer ID code for
#             the object as an integer string, i.e. both 'MOON' and '301' are
#             legitimate strings that indicate the Moon is the target body.
#
#             [1,m] = size(body); char = class(body)
#
#       lon    the planetographic longitude of the input point. This is the
#             angle between the prime meridian and the meridian containing the
#             input point. For bodies having prograde (aka direct) rotation,
#             the direction of increasing longitude is positive west:  from the
#             +X axis of the rectangular coordinate system toward the -Y axis.
#             For bodies having retrograde rotation, the direction of
#             increasing longitude is positive east: from the +X axis toward
#             the +Y axis.
#
#             [1,n] = size(lon); double = class(lon)
#
#             The earth, moon, and sun are exceptions: planetographic
#             longitude is measured positive east for these bodies.
#
#             The default interpretation of longitude by this
#             and the other planetographic coordinate conversion
#             routines can be overridden; see the discussion in
#             Particulars below for details.
#
#             'lon' is measured in radians. On input, the range
#             of longitude is unrestricted.
#
#       lat    the planetographic latitude of the input point.  For a point P
#             on the reference spheroid, this is the angle between the XY plane
#             and the outward normal vector at P. For a point P not on the
#             reference spheroid, the planetographic latitude is that of the
#             closest point to P on the spheroid.
#
#             [1,n] = size(lat); double = class(lat)
#
#             'lat' is measured in radians.  On input, the
#             range of latitude is unrestricted.
#
#       alt    the altitude above the reference spheroid.
#
#             [1,n] = size(alt); double = class(alt)
#
#             Units of 'alt' must match those of  're'.
#
#       re    equatorial radius of the body of interest.
#
#             [1,1] = size(re); double = class(re)
#
#       f     flattening coefficient of the body, a dimensionless value defined
#             as:
#
#                    equatorial_radius - polar_radius
#                    --------------------------------
#                           equatorial_radius
#
#             [1,1] = size(f); double = class(f)
#
#   the call:
#
#      rectan = pgrrec( body, lon, lat, alt, re, f)
#
#   returns:
#
#      rectan   the rectangular body-fixed coordinates of the position or set
#               of positions.
#
#               [3,n] = size(rectan); double = class(rectan)
#
#               'rectan' returns with the same units associated with
#               'alt' and 're'.
#
#               'rectan' returns with the same vectorization measure
#                (N) as 'lon', 'lat', and 'alt'.
#
#-Particulars
#
#   Given the planetographic coordinates of a point, this routine
#   returns the body-fixed rectangular coordinates of the point.  The
#   body-fixed rectangular frame is that having the X-axis pass
#   through the 0 degree latitude 0 degree longitude direction, the
#   Z-axis pass through the 90 degree latitude direction, and the
#   Y-axis equal to the cross product of the unit Z-axis and X-axis
#   vectors.
#
#   The planetographic definition of latitude is identical to the
#   planetodetic (also called "geodetic" in SPICE documentation)
#   definition. In the planetographic coordinate system, latitude is
#   defined using a reference spheroid.  The spheroid is
#   characterized by an equatorial radius and a polar radius. For a
#   point P on the spheroid, latitude is defined as the angle between
#   the X-Y plane and the outward surface normal at P.  For a point P
#   off the spheroid, latitude is defined as the latitude of the
#   nearest point to P on the spheroid.  Note if P is an interior
#   point, for example, if P is at the center of the spheroid, there
#   may not be a unique nearest point to P.
#
#   In the planetographic coordinate system, longitude is defined
#   using the spin sense of the body.  Longitude is positive to the
#   west if the spin is prograde and positive to the east if the spin
#   is retrograde.  The spin sense is given by the sign of the first
#   degree term of the time-dependent polynomial for the body's prime
#   meridian Euler angle "W":  the spin is retrograde if this term is
#   negative and prograde otherwise.  For the sun, planets, most
#   natural satellites, and selected asteroids, the polynomial
#   expression for W may be found in a SPICE PCK kernel.
#
#   The earth, moon, and sun are exceptions: planetographic longitude
#   is measured positive east for these bodies.
#
#   If you wish to override the default sense of positive longitude
#   for a particular body, you can do so by defining the kernel
#   variable
#
#      BODY<body ID>_PGR_POSITIVE_LON
#
#   where <body ID> represents the NAIF ID code of the body. This
#   variable may be assigned either of the values
#
#      'WEST'
#      'EAST'
#
#   For example, you can have this routine treat the longitude
#   of the earth as increasing to the west using the kernel
#   variable assignment
#
#      BODY399_PGR_POSITIVE_LON = 'WEST'
#
#   Normally such assignments are made by placing them in a text
#   kernel and loading that kernel via furnsh_c.
#
#   The definition of this kernel variable controls the behavior of
#   the CSPICE planetographic routines
#
#      pgrrec
#      cspice_recpgr
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pgrrec_c.
#
#   MICE.REQ
#
    function # pgrrec
#       (rectan::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        pgrrec(
            body::AbstractString, # Ptr{ConstSpiceChar}
            lon::Float64, # SpiceDouble
            lat::Float64, # SpiceDouble
            alt::Float64, # SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rectan = Array{Float64,1}(3);  # Array_3_SpiceDouble
        rectan_ptr = pointer(rectan)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:pgrrec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble),body,lon,lat,alt,re,f,rectan)
        ccall((:pgrrec_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Float64,Float64,Float64,Float64,Ptr{Float64}),
            body,lon,lat,alt,re,f,rectan_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rectan
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load a PCK file containing a triaxial
#      % ellipsoidal shape model and orientation
#      % data for Mars.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Example 1: convert a single set of planetographic
#      %            coordinates to rectangular bodyfixed
#      %            coordinates.
#      %
#      % Look up the radii for Mars.  Although we
#      % omit it here, we could check the kernel pool
#      % to make sure the variable BODY499_RADII
#      % has three elements and numeric data type.
#      % If the variable is not present in the kernel
#      % pool, cspice_bodvrd will signal an error.
#      %
#      body = 'MARS';
#      radii = cspice_bodvrd( body, 'RADII', 3 );
#
#      %
#      %
#      % Calculate the flatness coefficient. Set a bodyfixed
#      % position vector, 'x'.
#      %
#      re   = radii(1);
#      rp   = radii(3);
#      flat = ( re - rp ) / re;
#
#      % Set a longitude, latitude, altitude position.
#      % Note that we must provide longitude and
#      % latitude in radians.
#      %
#      lon  = 90. * cspice_rpd;
#      lat  = 45.  * cspice_rpd;
#      alt  = 3.d2;
#
#      %
#      % Do the conversion.
#      %
#      x = pgrrec( body, lon, lat, alt, re, flat );
#
#      %
#      % Output.
#      %
#      disp( 'Scalar:' )
#      disp(' ')
#
#      disp( 'Rectangular coordinates in km (x, y, z)' )
#      fprintf( '%9.3f   %9.3f   %9.3f\n', x' )
#
#      disp( 'Planetographic coordinates in degs and km (lon, lat, alt)' )
#      fprintf( '%9.3f   %9.3f   %9.3f\n', lon *cspice_dpr() ...
#                                        , lat *cspice_dpr() ...
#                                        , alt               )
#      disp(' ')
#
#
#      %
#      % Example 2: convert a vectorized set of planetographic coordinates
#      %            to rectangular bodyfixed coordinates.
#      %
#      % Define 1xN arrays of longitudes, latitudes, and altitudes.
#      %
#      lon = [ 0.,   ...
#              180., ...
#              180., ...
#              180., ...
#              90.,  ...
#              270., ...
#              0.,   ...
#              0.,   ...
#              0. ];
#
#      lat = [ 0.,  ...
#              0.,  ...
#              0.,  ...
#              0.,  ...
#              0.,  ...
#              0.,  ...
#              90., ...
#             -90., ...
#              90. ];
#
#      alt = [ 0., ...
#              0., ...
#              10., ...
#              10., ...
#              0., ...
#              0., ...
#              0., ...
#              0., ...
#             -3376.200 ];
#
#      %
#      % Convert angular measures to radians.
#      %
#      lon = lon*cspice_rpd;
#      lat = lat*cspice_rpd;
#
#      %
#      % Using the same Mars parameters, convert the 'lon', 'lat', 'alt'
#      % vectors to bodyfixed rectangular coordinates.
#      %
#      x = pgrrec( body, lon, lat, alt, re, flat);
#
#      disp('Vector:')
#      disp(' ')
#
#      disp( ['rectan(1)   rectan(2)   rectan(3)' ...
#             '         lon         lat         alt'] )
#      disp( ['---------------------------------' ...
#             '------------------------------------'] )
#
#      %
#      % Create an array of values for output.
#      %
#      output = [  x(1,:);         x(2,:);         x(3,:); ...
#                  lon*cspice_dpr; lat*cspice_dpr; alt ];
#
#      txt = sprintf( '%9.3f   %9.3f   %9.3f   %9.3f   %9.3f   %9.3f\n', ...
#                                                                   output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#
#      Rectangular coordinates in km (x, y, z)
#          0.000   -2620.679    2592.409
#      Planetographic coordinates in degs and km (lon, lat, alt)
#         90.000      45.000     300.000
#
#      Vector:
#
#      rectan(1)   rectan(2)   rectan(3)         lon         lat         alt
#      ---------------------------------------------------------------------
#       3396.190      -0.000       0.000       0.000       0.000       0.000
#      -3396.190      -0.000       0.000     180.000       0.000       0.000
#      -3406.190      -0.000       0.000     180.000       0.000      10.000
#      -3406.190      -0.000       0.000     180.000       0.000      10.000
#          0.000   -3396.190       0.000      90.000       0.000       0.000
#         -0.000    3396.190       0.000     270.000       0.000       0.000
#          0.000      -0.000    3376.200       0.000      90.000       0.000
#          0.000      -0.000   -3376.200       0.000     -90.000       0.000
#          0.000       0.000       0.000       0.000      90.000   -3376.200
#
#-Version
#
#   -Mice Version 1.0.1, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#      Corrected misspellings.
#
#   -Mice Version 1.0.0, 22-JAN-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #    ##     ####   ######   ####
#    #    #  #    #   #  #   #       #       #    #
#    #    #  ######  #    #   ####   #####   #    #
#    #####   #    #  ######       #  #       #  # #
#    #       #    #  #    #  #    #  #       #   #
#    #       #    #  #    #   ####   ######   ### #
#
#   compute the phase of two objects wrt an illumination source
#
################################################################################
#-Abstract
#
#   phaseq computes the apparent phase angle for a target, observer,
#   illuminator set of ephemeris objects.
#
#-I/O
#
#   Given:
#
#      et       the epochs, specified in ephemeris seconds past J2000, at which
#               to compute the phase angle.
#
#               [1,n] = size(et), double = class(et)
#
#      target   the string naming of the target body.
#
#               Optionally, you may supply the integer NAIF ID code
#               for the body as a string. For example both 'MOON' and
#               '301' are legitimate strings that designate the Moon.
#
#               Case and leading or trailing blanks are not significant
#               in the string 'target'.
#
#               [1,c1] = size(target), char = class(target)
#
#      illumn    the string naming the illuminating body.
#
#               Optionally, you may supply the integer NAIF ID code
#               for the body as a string. For example both 'MOON' and
#               '301' are legitimate strings that designate the Moon.
#
#               Case and leading or trailing blanks are not significant
#               in the string 'illumn'.
#
#               In most cases, 'illumn' is the sun.
#
#               [1,c2] = size(target), char = class(target)
#
#      obsrvr   the string naming the observing body, typically a
#               spacecraft, the earth, or a surface point on the earth.
#
#               Optionally, you may supply the integer NAIF ID code
#               for the body as a string. For example both 'MOON' and
#               '301' are legitimate strings that designate the Moon.
#
#               Case and leading or trailing blanks are not significant
#               in the string 'obsrvr'.
#
#               [1,c3] = size(obsrvr), char = class(obsrvr)
#
#      abcorr   the string naming the aberration corrections to apply
#               to the state evaluations to account for one-way light time and
#               stellar aberration.
#
#               This routine accepts only reception mode aberration
#               corrections. See the header of cspice_spkezr for a detailed
#               description of the aberration correction options.
#               For convenience, the appropriate aberration options are
#               listed below:
#
#                  'NONE'     Apply no correction. Returns the "true"
#                             geometric state.
#
#                  'LT'       "Reception" case:  correct for
#                             one-way light time using a Newtonian
#                             formulation.
#
#                  'LT+S'     "Reception" case:  correct for
#                             one-way light time and stellar
#                             aberration using a Newtonian
#                             formulation.
#
#                  'CN'       "Reception" case:  converged
#                             Newtonian light time correction.
#
#                  'CN+S'     "Reception" case:  converged
#                             Newtonian light time and stellar
#                             aberration corrections.
#
#               Case and leading or trailing blanks are not significant
#               in the string 'abcorr'.
#
#               [1,c4] = size(abcorr), char = class(abcorr)
#
#   the call:
#
#      phase = phaseq( et, target, illum, obsrvr, abcorr )
#
#   returns:
#
#      phase   the optionally light-time corrected phase angle between
#              'target' and 'illumn' as observed  from 'obsrvr'.
#              Units are radians.  The range of 'phase' is [0, pi].
#
#              'phase' return with the same vectorization measure (N) as 'et'.
#
#              [1,n] = size(phase), double = class(phase)
#
#-Particulars
#
#   This routine returns the phase angle using the location of the
#   bodies (if point objects) or the centers of the bodies (if finite
#   bodies).
#
#
#                       ILLUM      OBS
#       ILLUM as seen      ^       /
#       from TARG at       |      /
#       ET - LT.           |     /
#                         >|..../< phase angle
#                          |   /
#                        . |  /
#                      .   | /
#                     .    |v     TARG as seen from OBS
#               SEP   .   TARG    at ET
#                      .  /
#                        /
#                       v
#
#        PI = SEP + PHASE
#
#        so
#
#        PHASE = PI - SEP
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine phaseq_c.
#
#   MICE.REQ
#
    function # phaseq
#       (phase::Float64) =   # SpiceDouble
        phaseq(
            et::Float64, # SpiceDouble
            target::AbstractString, # Ptr{ConstSpiceChar}
            illumn::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        phase = Array{Float64}(1);  # SpiceDouble
        phase_ptr = pointer(phase)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:phaseq_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar}),et,target,illumn,obsrvr,abcorr)
        return ccall((:phaseq_c,libNasaSpice),Float64,
            (Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64}),
            et,target,illumn,obsrvr,abcorr,phase_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'naif0009.tls'
#                                'de421.bsp'
#                                'pck00009.tpc' )
#
#         \begintext
#
#   Example:
#
#      Determine the time intervals from December 1, 2006 UTC to
#      January 31, 2007 UTC for which the sun-moon-earth configuration
#      phase angle satisfies the relation conditions with respect to a
#      reference value of .57598845 radians (the phase angle at
#      January 1, 2007 00:00:00.000 UTC, 33.001707 degrees). Also
#      determine the time intervals corresponding to the local maximum and
#      minimum phase angles, and the absolute maximum and minimum phase
#      angles during the search interval. The configuration defines the
#      sun as the illuminator, the moon as the target, and the earth as
#      the observer.
#
#      MAXWIN  =  5000;
#      TIMFMT  = 'YYYY-MON-DD HR:MN:SC.###';
#
#      relate = { '=', '<', '>', ...
#                 'LOCMIN', 'ABSMIN', 'LOCMAX', 'ABSMAX' };
#
#      %
#      % Define the location for the phase angle calculation as the
#      % geometric center of the target.
#      %
#      pos = [ 0, 0, 0 ]';
#
#      %
#      % Load kernels.
#      %
#      cspice_furnsh( 'standard.tm' );
#
#      %
#      % Store the time bounds of our search interval in
#      % the cnfine confinement window.
#      %
#      et = cspice_str2et( { '2006 DEC 01', '2007 JAN 31'} );
#
#      %
#      % Search using a step size of 1 day (in units of seconds).
#      % The reference value is 0.57598845 radians. We're not using the
#      % adjustment feature, so we set 'adjust' to zero.
#      %
#      target  = 'MOON';
#      illum   = 'SUN';
#      abcorr  = 'LT+S';
#      obsrvr  = 'EARTH';
#      refval  = 0.57598845;
#      adjust  = 0.;
#      step    = cspice_spd;
#      nintvls = MAXWIN;
#      cnfine  = cspice_wninsd( et(1), et(2) );
#
#      for j=1:numel( relate )
#
#         fprintf( 'Relation condition: %s\n',  char( relate(j) ) )
#
#         %
#         % Perform the search. The SPICE window 'result' contains
#         % the set of times when the condition is met.
#         %
#         result = cspice_gfpa( target,    illum,  abcorr, obsrvr, ...
#                               relate(j), refval, adjust, step,  ...
#                               nintvls,   cnfine );
#
#         %
#         % Display the results.
#         %
#         count = cspice_wncard(result);
#
#         if ( isequal( count, 0 ) )
#
#               fprintf( 'Result window is empty.\n\n' );
#
#         else
#
#            for i=1:count
#
#               %
#               % Fetch the endpoints of the Ith interval
#               % of the result window.
#               %
#               [left, right] = cspice_wnfetd( result, i );
#
#               phase = phaseq( [left, right], target, illum, ...
#                                      obsrvr, abcorr );
#
#               output = cspice_timout( [left,right], TIMFMT );
#
#               fprintf( 'Start time = %s %16.9f\n', output(1,:), phase(1) )
#               fprintf( 'Stop time  = %s %16.9f\n', output(2,:), phase(2) )
#
#            end
#
#            disp( ' ')
#
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Relation condition: =
#      Start time = 2006-DEC-02 13:31:34.414      0.575988450
#      Stop time  = 2006-DEC-02 13:31:34.414      0.575988450
#      Start time = 2006-DEC-07 14:07:55.470      0.575988450
#      Stop time  = 2006-DEC-07 14:07:55.470      0.575988450
#      Start time = 2006-DEC-31 23:59:59.997      0.575988450
#      Stop time  = 2006-DEC-31 23:59:59.997      0.575988450
#      Start time = 2007-JAN-06 08:16:25.512      0.575988450
#      Stop time  = 2007-JAN-06 08:16:25.512      0.575988450
#      Start time = 2007-JAN-30 11:41:32.557      0.575988450
#      Stop time  = 2007-JAN-30 11:41:32.557      0.575988450
#
#      Relation condition: <
#      Start time = 2006-DEC-02 13:31:34.414      0.575988450
#      Stop time  = 2006-DEC-07 14:07:55.470      0.575988450
#      Start time = 2006-DEC-31 23:59:59.997      0.575988450
#      Stop time  = 2007-JAN-06 08:16:25.512      0.575988450
#      Start time = 2007-JAN-30 11:41:32.557      0.575988450
#      Stop time  = 2007-JAN-31 00:00:00.000      0.468279091
#
#      Relation condition: >
#      Start time = 2006-DEC-01 00:00:00.000      0.940714974
#      Stop time  = 2006-DEC-02 13:31:34.414      0.575988450
#      Start time = 2006-DEC-07 14:07:55.470      0.575988450
#      Stop time  = 2006-DEC-31 23:59:59.997      0.575988450
#      Start time = 2007-JAN-06 08:16:25.512      0.575988450
#      Stop time  = 2007-JAN-30 11:41:32.557      0.575988450
#
#      Relation condition: LOCMIN
#      Start time = 2006-DEC-05 00:16:50.317      0.086121423
#      Stop time  = 2006-DEC-05 00:16:50.317      0.086121423
#      Start time = 2007-JAN-03 14:18:31.977      0.079899769
#      Stop time  = 2007-JAN-03 14:18:31.977      0.079899769
#
#      Relation condition: ABSMIN
#      Start time = 2007-JAN-03 14:18:31.977      0.079899769
#      Stop time  = 2007-JAN-03 14:18:31.977      0.079899769
#
#      Relation condition: LOCMAX
#      Start time = 2006-DEC-20 14:09:10.392      3.055062862
#      Stop time  = 2006-DEC-20 14:09:10.392      3.055062862
#      Start time = 2007-JAN-19 04:27:54.600      3.074603891
#      Stop time  = 2007-JAN-19 04:27:54.600      3.074603891
#
#      Relation condition: ABSMAX
#      Start time = 2007-JAN-19 04:27:54.600      3.074603891
#      Stop time  = 2007-JAN-19 04:27:54.600      3.074603891
#
#-Version
#
#   -Mice Version 1.0.0, 13-MAR-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####      #
#    #    #     #
#    #    #     #
#    #####      #
#    #          #
#    #          #
#
#   value of pi
#
################################################################################
#-Abstract
#
#   pi returns the value of the constant pi.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      onepi = pi
#
#   returns:
#
#      onepi   the value of PI to machine precision.
#
#              [1,1] = size(onepi); double = class(onepi)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pi_c.
#
#   MICE.REQ
#
    function # pi
        pi()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:pi_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:pi_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> pi_double = pi
#
#      pi_double =
#
#          3.1416
#
#      >> sprintf( 'PI epoch: %2.11f', pi )
#
#      ans =
#
#      PI: 3.14159265359
#
#   The MATLAB system variable "pi" returns a double precision value
#   for PI that equates the value returned by pi, to machine
#   roundoff.
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#       Corrected minor typo in header.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####        #  ######  #       #####   #
#    #    #       #  #       #       #    #  #
#    #    #       #  #####   #       #    #  #
#    #####        #  #       #       #####   #
#    #       #    #  #       #       #       #
#    #        ####   ######  ######  #       ######
#
#   project ellipse onto plane
#
################################################################################
#-Abstract
#
#   pjelpl orthogonally projects an ellipse onto a plane.
#
#-I/O
#
#   Given:
#
#      elin    a structure describing a SPICE ellipse.
#
#              [1,1] = size(elin); struct = class(elin)
#
#              The structure has the fields:
#
#                 center:    [3x1 double]
#                 semiMajor: [3x1 double]
#                 semiMinor: [3x1 double]
#
#      plane   a structure describing a SPICE plane.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                  normal:     [3x1 double]
#                  constant:   [1x1 double]
#
#              are, respectively, a SPICE ellipse and a SPICE plane. The
#              geometric ellipse represented by 'elin' is to be orthogonally
#              projected onto the geometric plane represented by 'plane'.
#
#   the call:
#
#      elout = pjelpl( elin, plane )
#
#   returns:
#
#      elout   the SPICE ellipse that represents the geometric
#              ellipse resulting from orthogonally projecting the ellipse
#              represented by 'elin' onto the plane represented by 'plane'.
#
#              [1,1] = size(elout); struct = class(elout)
#
#-Particulars
#
#   Projecting an ellipse orthogonally onto a plane can be thought of
#   finding the points on the plane that are `under' or `over' the
#   ellipse, with the `up' direction considered to be perpendicular
#   to the plane.  More mathematically, the orthogonal projection is
#   the set of points Y in the plane such that for some point X in
#   the ellipse, the vector Y - X is perpendicular to the plane.
#   The orthogonal projection of an ellipse onto a plane yields
#   another ellipse.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pjelpl_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#   PLANES.REQ
#
    function # pjelpl
#       (elout::NasaSpice.Ellipse) =   # Ptr{SpiceEllipse}
        pjelpl(
            elin::NasaSpice.Ellipse, # Ptr{ConstSpiceEllipse}
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
#       allocate the output parameters
        elout = Ellipse()
        ioelout = IOBuffer()
        StrPack.pack( ioelout, elout)
        elout_ptr = convert( Ptr{Ptr{SpiceEllipse}}, convert( Ptr{Void}, pointer(ioelout.data) ) )
        
#       make transposed copies of all input arrays and their pointers
        ioelin = IOBuffer()
        StrPack.pack( ioelin, elin)
        elin_ptr = convert( Ptr{Ptr{ConstSpiceEllipse}}, convert( Ptr{Void}, pointer(ioelin.data) ) )
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:pjelpl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceEllipse},Ptr{ConstSpicePlane},Ptr{SpiceEllipse}),elin,plane,elout)
        ccall((:pjelpl_c,libNasaSpice),Void,
            (NasaSpice.Ellipse,NasaSpice.Plane,Ptr{Ptr{SpiceEllipse}}),
            elin,plane,elout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(ioelout,0)
        elout = StrPack.unpack( ioelout, Ellipse )
        return elout
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Assign the values for plane/ellipse definition
#      % vectors.
#      %
#      center  = [ 1,  1,  1 ]';
#      vect1   = [ 2,  0,  0 ]';
#      vect2   = [ 0,  1,  1 ]';
#      normal  = [ 0,  0,  1 ]';
#
#      %
#      % Create a plane using a constant value of 0...
#      %
#      plane = cspice_nvc2pl( normal, 0 );
#
#      %
#      % ...and an ellipse.
#      %
#      elin = cspice_cgv2el( center, vect1, vect2 );
#
#      %
#      % Project the ellipse onto the plane.
#      %
#      elout = pjelpl( elin, plane );
#
#      %
#      % Output the ellipse in the plane.
#      %
#      fprintf( 'Center    :  %f  %f  %f\n', elout.center    )
#      fprintf( 'Semi-minor:  %f  %f  %f\n', elout.semiMinor )
#      fprintf( 'Semi-major:  %f  %f  %f\n', elout.semiMajor )
#
#   MATLAB outputs:
#
#      Center    :  1.000000  1.000000  0.000000
#      Semi-minor:  0.000000  1.000000  0.000000
#      Semi-major:  2.000000  0.000000  0.000000
#
#-Version
#
#   -Mice Version 1.0.0, 11-JUN-2013, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                    #####
#    #####   #      #     #  #    #  #    #   ####
#    #    #  #            #  ##   #  #    #  #    #
#    #    #  #       #####   # #  #  #    #  #
#    #####   #      #        #  # #  #    #  #
#    #       #      #        #   ##   #  #   #    #
#    #       ###### #######  #    #    ##     ####
#
#   plane to normal vector and constant
#
################################################################################
#-Abstract
#
#   pl2nvc returns a unit normal vector and constant defining
#   a specified plane.
#
#-I/O
#
#   Given:
#
#      plane   a structure describing a SPICE plane.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      [normal, constant] = pl2nvc( plane )
#
#   returns:
#
#      normal     [3,1] = size(normal); double = class(normal)
#
#      constant   [1,1] = size(constant); double = class(constant)
#
#                 are, respectively, a unit normal vector and
#                 constant that define the geometric plane
#                 represented by 'plane'.  Let the symbol < a, b >
#                 indicate the inner product of vectors a and b; then
#                 the geometric plane is the set of vectors x in
#                 three-dimensional space that satisfy
#
#                    < x,  normal >  =  constant.
#
#                 'normal' is a unit vector. 'constant' is the distance
#                 of the plane from the origin;
#
#                    constant * normal
#
#                 is the closest point in the plane to the origin.
#
#-Particulars
#
#   Mice geometry routines that deal with planes use the `plane'
#   data type to represent input and output planes.  This data type
#   makes the subroutine interfaces simpler and more uniform.
#
#   The Mice routines that produce SPICE planes from data that
#   define a plane are:
#
#      cspice_nvc2pl ( Normal vector and constant to plane )
#      cspice_nvp2pl ( Normal vector and point to plane    )
#      cspice_psv2pl ( Point and spanning vectors to plane )
#
#   The Mice routines that convert SPICE planes to data that
#   define a plane are:
#
#      pl2nvc ( Plane to normal vector and constant )
#      cspice_pl2nvp ( Plane to normal vector and point    )
#      cspice_pl2psv ( Plane to point and spanning vectors )
#
#   Any of these last three routines may be used to convert this
#   routine's output, 'plane', to another representation of a
#   geometric plane.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pl2nvc_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # pl2nvc
#       (normal::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        constant::Float64) =   # Ptr{SpiceDouble}
        pl2nvc(
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
#       allocate the output parameters
        normal = Array{Float64,1}(3);  # Array_3_SpiceDouble
        normal_ptr = pointer(normal)
        constant = Array{Float64}(1);  # Ptr{SpiceDouble}
        constant_ptr = pointer(constant)
        
#       make transposed copies of all input arrays and their pointers
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:pl2nvc_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpicePlane},Array_3_SpiceDouble,Ptr{SpiceDouble}),plane,normal,constant)
        ccall((:pl2nvc_c,libNasaSpice),Void,
            (NasaSpice.Plane,Ptr{Float64},Ptr{Float64}),
            plane,normal_ptr,constant_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return normal, constant[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % A simple task, determine the distance of a plane
#      % from the origin.
#      %
#      % Define the plane with a vector normal to the plane
#      % and a point in the plane.
#      %
#      normal = [ -1.;  5.;    -3.5 ];
#      point  = [  9.; -0.65;  -12. ];
#
#      %
#      % create the SPICE plane from the normal and constant.
#      %
#      plane = cspice_nvp2pl( normal, point );
#
#      %
#      % Calculate the normal vector and constant defining
#      % the plane. The constant value is the distance from
#      % the origin to the plane.
#      %
#      [normal, constant ] = pl2nvc( plane )
#
#      %
#      % Confirm the results. Calculate a vector
#      % from the origin to the plane.
#      %
#      vec = constant * normal;
#
#      %
#      % Now calculate a vector in the plane from the
#      % location in the plane defined by 'vec'.
#      %
#      plane_vec = vec - point;
#
#      %
#      % These vectors should be orthogonal.
#      %
#      dot( plane_vec, vec )
#
#   MATLAB outputs:
#
#      normal =
#
#          -1.616904166908886e-01
#           8.084520834544432e-01
#          -5.659164584181102e-01
#
#
#      constant =
#
#           4.810289896553937e+00
#
#   The dot product result to check orthogonality...
#
#      ans =
#
#          -3.552713678800501e-15
#
#   Zero, to double precision round-off, so orthogonal to that
#   precision.
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                    #####
#    #####   #      #     #  #    #  #    #  #####
#    #    #  #            #  ##   #  #    #  #    #
#    #    #  #       #####   # #  #  #    #  #    #
#    #####   #      #        #  # #  #    #  #####
#    #       #      #        #   ##   #  #   #
#    #       ###### #######  #    #    ##    #
#
#   plane to normal vector and point
#
################################################################################
#-Abstract
#
#   pl2nvp returns a unit normal vector and point that define
#   a specified plane.
#
#-I/O
#
#   Given:
#
#      plane   a structure describing a SPICE plane.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      [normal, point] = pl2nvp( plane )
#
#   returns:
#
#      normal   [3,1] = size(normal); double = class(normal)
#
#      point    [3,1] = size(point); double = class(point)
#
#               are, respectively, a unit normal vector and point
#               that define the geometric plane represented by
#               plane.  Let the symbol < a, b > indicate the inner
#               product of vectors a and b; then the geometric
#               plane is the set of vectors x in three-dimensional
#               space that satisfy
#
#                  < x - point, normal >  =  0.
#
#               'point' is always the closest point in the input
#               plane to the origin. 'point' is always a
#               non-negative scalar multiple of 'normal'.
#
#-Particulars
#
#   Mice geometry routines that deal with planes use the `plane'
#   data type to represent input and output planes.  This data type
#   makes the subroutine interfaces simpler and more uniform.
#
#   The Mice routines that produce SPICE planes from data that
#   define a plane are:
#
#      cspice_nvc2pl ( Normal vector and constant to plane )
#      cspice_nvp2pl ( Normal vector and point to plane    )
#      cspice_psv2pl ( Point and spanning vectors to plane )
#
#   The Mice routines that convert SPICE planes to data that
#   define a plane are:
#
#      cspice_pl2nvc ( Plane to normal vector and constant )
#      pl2nvp ( Plane to normal vector and point    )
#      cspice_pl2psv ( Plane to point and spanning vectors )
#
#   Any of these last three routines may be used to convert this
#   routine's output, 'plane', to another representation of a
#   geometric plane.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pl2nvp_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # pl2nvp
#       (normal::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        point::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        pl2nvp(
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
#       allocate the output parameters
        normal = Array{Float64,1}(3);  # Array_3_SpiceDouble
        normal_ptr = pointer(normal)
        point = Array{Float64,1}(3);  # Array_3_SpiceDouble
        point_ptr = pointer(point)
        
#       make transposed copies of all input arrays and their pointers
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:pl2nvp_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpicePlane},Array_3_SpiceDouble,Array_3_SpiceDouble),plane,normal,point)
        ccall((:pl2nvp_c,libNasaSpice),Void,
            (NasaSpice.Plane,Ptr{Float64},Ptr{Float64}),
            plane,normal_ptr,point_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return normal, point
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % A trivial example of plane creation and
#      % decomposition. Create a plane via the definition
#      % of a plane normal and constant, determine a
#      % point in the plane.
#      %
#      plane_norm = [ 2.44; -5./3.; 11./9. ];
#      const      = cspice_pi;
#
#      %
#      % Construct the SPICE plane.
#      %
#      plane = cspice_nvc2pl( plane_norm, const );
#
#      %
#      % Convert the plane to a normal vector, point
#      % representation, 'point' lies in the plane.
#      %
#      [ norm_vec, point ] = pl2nvp( plane )
#
#   MATLAB outputs:
#
#      norm_vec =
#
#           7.630514391556131e-01
#          -5.212099994232330e-01
#           3.822206662437042e-01
#
#
#      point =
#
#           7.496657642594705e-01
#          -5.120667788657586e-01
#           3.755156378348896e-01
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                    #####
#    #####   #      #     #  #####    ####   #    #
#    #    #  #            #  #    #  #       #    #
#    #    #  #       #####   #    #   ####   #    #
#    #####   #      #        #####        #  #    #
#    #       #      #        #       #    #   #  #
#    #       ###### #######  #        ####     ##
#
#   plane to point and spanning vectors
#
################################################################################
#-Abstract
#
#   pl2psv returns a point and two orthogonal spanning vectors
#   that generate a specified plane.
#
#-I/O
#
#   Given:
#
#      plane   a structure describing a SPICE plane.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      [point, span1, span2] = pl2psv( plane )
#
#   returns:
#
#      point    [3,1] = size(point); double = class(point)
#
#      span1    [3,1] = size(span1); double = class(span1)
#
#      span2    [3,1] = size(span2); double = class(span2)
#
#               are, respectively, a point and two orthogonal
#               spanning vectors that generate the geometric plane
#               represented by plane. The geometric plane is the
#               set of vectors
#
#                  point   +   s * span1   +   t * span2
#
#               where s and t are real numbers. 'point' is the closest
#               point in the plane to the origin; this point is
#               always a multiple of the plane's normal vector.
#               'span1' and 'span2' are an orthonormal pair of
#               vectors. 'point', 'span1', and 'span2' are mutually
#               orthogonal.
#
#-Particulars
#
#   Mice geometry routines that deal with planes use the `plane'
#   data type to represent input and output planes.  This data type
#   makes the subroutine interfaces simpler and more uniform.
#
#   The Mice routines that produce SPICE planes from data that
#   define a plane are:
#
#      cspice_nvc2pl ( Normal vector and constant to plane )
#      cspice_nvp2pl ( Normal vector and point to plane    )
#      cspice_psv2pl ( Point and spanning vectors to plane )
#
#   The Mice routines that convert SPICE planes to data that
#   define a plane are:
#
#      cspice_pl2nvc ( Plane to normal vector and constant )
#      cspice_pl2nvp ( Plane to normal vector and point    )
#      pl2psv ( Plane to point and spanning vectors )
#
#   Any of these last three routines may be used to convert this
#   routine's output, 'plane', to another representation of a
#   geometric plane.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pl2psv_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # pl2psv
#       (point::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        span1::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        span2::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        pl2psv(
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
#       allocate the output parameters
        point = Array{Float64,1}(3);  # Array_3_SpiceDouble
        point_ptr = pointer(point)
        span1 = Array{Float64,1}(3);  # Array_3_SpiceDouble
        span1_ptr = pointer(span1)
        span2 = Array{Float64,1}(3);  # Array_3_SpiceDouble
        span2_ptr = pointer(span2)
        
#       make transposed copies of all input arrays and their pointers
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:pl2psv_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpicePlane},Array_3_SpiceDouble,Array_3_SpiceDouble,Array_3_SpiceDouble),plane,point,span1,span2)
        ccall((:pl2psv_c,libNasaSpice),Void,
            (NasaSpice.Plane,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            plane,point_ptr,span1_ptr,span2_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return point, span1, span2
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define a normal vector from a plane and a
#      % point in a plane.
#      %
#      normal = [ -1.;  5.;   -3.5 ];
#      point  = [  9.; -0.65; -12. ];
#
#      %
#      % Create a plane from the vectors.
#      %
#      plane = cspice_nvp2pl( normal, point );
#
#      %
#      % Calculate a point in the plane, and
#      % two spanning vectors in the plane such that
#      % the point and spanning are mutually orthogonal.
#      %
#      [point, span1, span2] = pl2psv( plane )
#
#      %
#      % Test 'point', 'span1', and 'span2' orthogonality. The dot
#      % products of any two vectors should equal zero to
#      % within round-off.
#      %
#      fprintf( ' point . span1 : %18.15e\n', dot( point, span1) )
#      fprintf( ' point . span2 : %18.15e\n', dot( point, span2) )
#      fprintf( ' span1 . span2 : %18.15e\n', dot( span1, span2) )
#
#    Matlab outputs:
#
#        point =
#
#            -7.777777777777776e-01
#             3.888888888888888e+00
#            -2.722222222222222e+00
#
#
#        span1 =
#
#                                 0
#             5.734623443633283e-01
#             8.192319205190405e-01
#
#
#        span2 =
#
#             9.868415319342446e-01
#             1.324619505952006e-01
#            -9.272336541664042e-02
#
#        dot( point, span1) =  0.000000000000000e+00
#        dot( point, span2) =  5.551115123125783e-17
#        dot( span1, span2) =  0.000000000000000e+00
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#    #####    ####   #    # #     #  #####   #
#    #    #  #       #    #       #  #    #  #
#    #    #   ####   #    #  #####   #    #  #
#    #####        #  #    # #        #####   #
#    #       #    #   #  #  #        #       #
#    #        ####     ##   #######  #       ######
#
#   plane to point and spanning vectors
#
################################################################################
#-Abstract
#
#   psv2pl returns a SPICE plane given a point and two
#   spanning vectors.
#
#-I/O
#
#   Given:
#
#      point    [3,1] = size(point); double = class(point)
#
#      span1    [3,1] = size(span1); double = class(span1)
#
#      span2    [3,1] = size(span2); double = class(span2)
#
#               are, respectively, a point and two spanning vectors
#               that define a geometric plane in three-dimensional
#               space. The plane is the set of vectors
#
#                  point   +   s * span1   +   t * span2
#
#               where 's' and 't' are real numbers.  The spanning
#               vectors 'span1' and 'span2' must be linearly
#               independent, but they need not be orthogonal or
#               unitized.
#
#   the call:
#
#      [plane] = psv2pl(point, span1, span2 )
#
#   returns:
#
#      plane   a structure describing a SPICE plane defined
#              by 'point', 'span1', and 'span2'.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#-Particulars
#
#   Mice geometry routines that deal with planes use the `plane'
#   data type to represent input and output planes.  This data type
#   makes the subroutine interfaces simpler and more uniform.
#
#   The Mice routines that produce SPICE planes from data that
#   define a plane are:
#
#      cspice_nvc2pl ( Normal vector and constant to plane )
#      cspice_nvp2pl ( Normal vector and point to plane    )
#      psv2pl ( Point and spanning vectors to plane )
#
#   The Mice routines that convert SPICE planes to data that
#   define a plane are:
#
#      cspice_pl2nvc ( Plane to normal vector and constant )
#      cspice_pl2nvp ( Plane to normal vector and point    )
#      cspice_pl2psv ( Plane to point and spanning vectors )
#
#   Any of these last three routines may be used to convert this
#   routine's output, 'plane', to another representation of a
#   geometric plane.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine psv2pl_c.
#
#   MICE.REQ
#   PLANES.REQ
#
    function # psv2pl
#       (plane::NasaSpice.Plane) =   # Ptr{SpicePlane}
        psv2pl(
            point::Array{Float64,1}, # Array_3_ConstSpiceDouble
            span1::Array{Float64,1}, # Array_3_ConstSpiceDouble
            span2::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(point) != 3
            error("Incorrect size for parameter 1")
        end
        if length(span1) != 3
            error("Incorrect size for parameter 2")
        end
        if length(span2) != 3
            error("Incorrect size for parameter 3")
        end
#       allocate the output parameters
        plane = Plane()
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{SpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       make transposed copies of all input arrays and their pointers
        point_t = point'
        point_ptr = pointer(point_t)
        span1_t = span1'
        span1_ptr = pointer(span1_t)
        span2_t = span2'
        span2_ptr = pointer(span2_t)
        
#       ccall((:psv2pl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Ptr{SpicePlane}),point,span1,span2,plane)
        ccall((:psv2pl_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Ptr{SpicePlane}}),
            point_ptr,span1_ptr,span2_ptr,plane_ptr)
    
#       unpack any structures and transpose back any returned arrays
        seek(ioplane,0)
        plane = StrPack.unpack( ioplane, Plane )
        return plane
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Calculate the inclination of the Moon's orbit plane about
#      % the Earth to the orbit plane of the Earth around the sun.
#      %
#      % We want a geometric analysis, so the calculation requires
#      % no aberration correction.
#      %
#      epoch = 'Jan 1 2005';
#      frame = 'ECLIPJ2000';
#      corr  = 'NONE';
#
#      %
#      % Load the kernels we need to retrieve state data.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Convert the time string to  ephemeris time
#      %
#      et = cspice_str2et( epoch );
#
#      %
#      % Calculate the orbit plane of the Earth about
#      % the solar system barycenter at epoch.
#      %
#      [state, ltime] = cspice_spkezr( 'EARTH', et, frame, corr, ...
#                                      'Solar System Barycenter' );
#
#      es_plane            = psv2pl( state(1:3), ...
#                                           state(1:3), ...
#                                           state(4:6) );
#      [es_norm, es_const] = cspice_pl2nvc( es_plane );
#
#      %
#      % Calculate the orbit plane of the Moon with respect to
#      % the Earth-Moon barycenter at epoch.
#      %
#      [state, ltime] = cspice_spkezr( 'MOON', et, frame, corr, ...
#                                      'EARTH BARYCENTER' );
#
#      em_plane            = psv2pl( state(1:3), ...
#                                           state(1:3), ...
#                                           state(4:6) );
#      [em_norm, em_const] = cspice_pl2nvc( em_plane );
#
#      %
#      % Calculate the inclination equals (output in degrees).
#      % Depending on the orientation of the plane normals, the
#      % cspice_vsep result may exceed 90 degrees. If, so subtract
#      % the value off 180 degrees.
#      %
#      loc_inc = cspice_vsep( es_norm, em_norm );
#
#      if ( loc_inc > cspice_halfpi )
#         loc_inc = cspice_pi - loc_inc;
#      end
#
#      fprintf( 'Moon-Earth orbit plane inclination (degrees): %f\n', ...
#             loc_inc * cspice_dpr )
#
#   Matlab outputs:
#
#      Moon-Earth orbit plane inclination (degrees): 5.042496
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #    #  ######   ####   #####   #    #
#    #    #   #  #   #       #    #  #    #  ##  ##
#    #    #    ##    #####   #    #  #    #  # ## #
#    #####     ##    #       #    #  #####   #    #
#    #        #  #   #       #    #  #   #   #    #
#    #       #    #  #        ####   #    #  #    #
#
#   Find a position transformation matrix
#
################################################################################
#-Abstract
#
#   pxform returns the matrix that transforms position
#   vectors from one specified frame to another at a specified epoch.
#
#-I/O
#
#   Given:
#
#      from   the name of a reference frame in which a position is known.
#
#             [1,m] = size(from); char = class(from)
#
#      to     the name of a reference frame in which it is desired to represent
#             the position.
#
#             [1,l] = size(to); char = class(to)
#
#      et     epoch in ephemeris seconds past the epoch of J2000 (TDB) at which
#             the position transformation matrix should be evaluated.
#
#             [1,n] = size(et); double = class(et)
#
#   the call:
#
#      rotate = pxform( from, to, et )
#
#   returns:
#
#      rotate   operator(s) that transform position vector(s) from the
#               reference frame 'from' to frame 'to' at epoch 'et'
#
#               If [1,1] = size(et) then [3,3]   = size(rotate)
#               If [1,n] = size(et) then [3,3,n] = size(rotate)
#                                         double = class(rotate)
#
#               'rotate' returns with the same vectorization measure (N)
#               as 'et'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pxform_c.
#
#   MICE.REQ
#   ROTATION.REQ
#   FRAMES.REQ
#
    function # pxform
#       (rotate::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        pxform(
            from::AbstractString, # Ptr{ConstSpiceChar}
            to::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rotate = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        rotate_ptr = pointer(rotate)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:pxform_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Array_3_Array_3_SpiceDouble),from,to,et,rotate)
        ccall((:pxform_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{Float64}),
            from,to,et,rotate_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rotate'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'naif0009.tls'
#                                'de421.bsp'
#                                'pck00009.tpc' )
#
#         \begintext
#
#      %
#      % Output the right ascension and declination of the earth's pole
#      % in the J2000 frame approximately every month for the time
#      % interval January 1, 1990 to January 1, 2010 (UTC).
#      %
#      %
#      % Load a standard kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define the time bounds for the time interval,
#      % 20 years, convert to ephemeris time J2000.
#      %
#      utc_bounds = strvcat( '1 Jan 1990', '1 Jan 2010' );
#      et_bounds  = cspice_str2et( utc_bounds );
#
#      %
#      % Step in units of a month. 20 years ~ 240 months.
#      %
#      step = (et_bounds(2) - et_bounds(1) ) / 240.;
#
#      %
#      % Create an array of 240 ephemeris times ending at
#      % ~et_bound(2) in intervals of 'step'.
#      %
#      et = [1:240]*step + et_bounds(1);
#
#      %
#      % Set the conversion constant "radians to degrees."
#      %
#      r2d = cspice_dpr;
#
#      %
#      % Convert the 240-vector of 'et' to an array of corresponding
#      % transformation matrices (dimensions (3,3,240) ).
#      %
#      mat = pxform( 'IAU_EARTH', 'J2000', et );
#
#      %
#      % Extract the pole vector from the transformation matrix,
#      % convert to RA and DEC expressed in degrees.
#      %
#
#      %
#      % The last column in each matrix is the pole vector (z = (0,0,1))
#      % of the earth in IAU expressed in J2000.
#      %
#      % Recall, MATLAB uses 1 based indexing, so (:,3,:) represents.
#      % the third column of the matrices.
#      %
#      pole = mat(:,3,:);
#
#      %
#      % 'pole' ready for use in cspice_radrec.
#      %
#      [radius, ra, dec] = cspice_recrad( pole );
#
#      %
#      % Output the ephemeris time and the corresponding
#      % angular values (in degrees). 'ra' and 'dec' return
#      % as double precision 240-vectors.
#      %
#      ra  = ra  * r2d;
#      dec = dec * r2d;
#
#      %
#      % Create an array of values for output.
#      %
#      output = [  et; ra; dec ];
#
#      fprintf( '%24.8f %16.8f %16.8f\n', output );
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      A partial output centered on et = 0:
#
#                              ...
#
#      -18408539.52023917     180.00373915      89.99675084
#      -15778739.49107254     180.00320499      89.99721501
#      -13148939.46190590     180.00267082      89.99767918
#      -10519139.43273926     180.00213665      89.99814334
#       -7889339.40357262     180.00160249      89.99860751
#       -5259539.37440598     180.00106832      89.99907168
#       -2629739.34523934     180.00053415      89.99953584
#             60.68392730     359.99999999      89.99999999
#        2629860.71309394     359.99946582      89.99953582
#        5259660.74226063     359.99893165      89.99907166
#        7889460.77142727     359.99839749      89.99860749
#       10519260.80059391     359.99786332      89.99814332
#       13149060.82976055     359.99732915      89.99767916
#       15778860.85892719     359.99679499      89.99721499
#       18408660.88809383     359.99626082      89.99675082
#
#                              ...
#
#-Version
#
#   -Mice Version 1.0.1, 09-NOV-2012, EDW (JPL), SCK (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                                            #####
#    #####   #    #  ######  #####   #    # #     #
#    #    #   #  #   #       #    #  ##  ##       #
#    #    #    ##    #####   #    #  # ## #  #####
#    #####     ##    #       #####   #    # #
#    #        #  #   #       #   #   #    # #
#    #       #    #  #       #    #  #    # #######
#
#   Position transformation matrix for different epochs
#
################################################################################
#-Abstract
#
#    pxfrm2 returns the 3x3 matrix that transforms position
#    vectors from one specified frame at a specified epoch to another
#    specified frame at another specified epoch.
#
#-I/O
#
#   Given:
#
#      from     name of a reference frame recognized by spicelib that
#               corresponds to the input 'etfrom'.
#
#               [1,m] = size(from); char = class(from)
#
#      to       name of a reference frame recognized by spicelib that
#               corresponds to the desired output at 'etto''.
#
#               [1,l] = size(to); char = class(to)
#
#      etfrom   epoch in ephemeris seconds past the epoch of J2000 (TDB)
#               corresponding to the 'from' reference frame.
#
#               [1,n] = size(etfrom); double = class(etfrom)
#
#      etto     epoch in ephemeris seconds past the epoch of J2000 (TDB) that
#               corresponds to the 'to' reference frame.
#
#               [1,n] = size(etto); double = class(etto)
#
#   the call:
#
#      result = pxfrm2( from, to, etfrom, etto)
#
#   returns:
#
#      rotate   operator(s) that transform position vector(s) from the
#               reference frame 'from' at epoch 'etfrom' to the frame 'to' at
#               epoch 'etto'.
#
#               If [1,1] = size(etfrom) then [3,3]   = size(rotate).
#               If [1,n] = size(etfrom) then [3,3,n] = size(rotate).
#               double = class(rotate)
#
#               If (x, y, z) is a position relative to the reference
#               frame 'from' at time 'etfrom' then the vector ( x', y',
#               z') is the same position relative to the frame 'to' at
#               epoch 'etto'. Here the vector ( x', y', z' ) is defined
#               by the equation:
#
#                    -   -       -        -     -  -
#                   | x'  |     |          |   | x  |
#                   | y'  |  =  |  rotate  |   | y  |
#                   | z'  |     |          |   | z  |
#                    -   -       -        -     -  -
#
#              'rotate' returns with the same vectorization measure (N)
#               as 'etfrom' and 'etto'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine pxfrm2_c.
#
#   MICE.REQ
#   FRAMES
#
    function # pxfrm2
#       (rotate::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        pxfrm2(
            from::AbstractString, # Ptr{ConstSpiceChar}
            to::AbstractString, # Ptr{ConstSpiceChar}
            etfrom::Float64, # SpiceDouble
            etto::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rotate = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        rotate_ptr = pointer(rotate)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:pxfrm2_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,SpiceDouble,Array_3_Array_3_SpiceDouble),from,to,etfrom,etto,rotate)
        ccall((:pxfrm2_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Float64,Ptr{Float64}),
            from,to,etfrom,etto,rotate_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rotate'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Suppose that MGS has taken a picture of Mars at time 'etrec' with
#      the MOC narrow angle camera. We want to know the latitude and
#      longitude associated with two pixels projected to Mars'
#      surface:  the boresight and one along the boundary of the
#      field of view (FOV). Due to light time, the photons taken in
#      the picture left Mars at time 'etemit', when Mars was at a
#      different state than at time 'etrec'.
#
#      In order to solve this problem, we could use the 'cspice_sincpt'
#      routine for both pixels, but this would be slow. Instead, we
#      will assume that the light time for each pixel is the same. We
#      will call 'cspice_sincpt' once to get the light time and surface point
#      associated with the boresight. Then, we will rotate the first
#      FOV boundary vector from the camera frame at 'etrec' to the
#      body-fixed Mars frame at 'etemit', and call the faster routine
#      'cspice_surfpt' to retrieve the surface point for the FOV boundary
#      vector.
#
#      This example problem could be extended to find the latitude
#      and longitude associated with every pixel in an instrument's
#      field of view, but this example is simplified to only solve
#      for two pixels:  the boresight and one along the boundary of
#      the field of view.
#
#      Assumptions:
#
#         1)  The light times from the surface points in the camera's
#             field of view to the camera are equal.
#
#         2)  The camera offset from the center of gravity of the
#             spacecraft is zero. If the data are more accurate
#             and precise, this assumption can be easily discarded.
#
#         3)  An ellipsoid shape model for the target body is
#             sufficient.
#
#         4)  The boundary field of view vector returned from 'cspice_getfov'
#             is associated with a boundary field of view pixel. If
#             this example were extended to include a geometric camera
#             model, this assumption would not be needed since the
#             direction vectors associated with each pixel would be
#             calculated from the geometric camera model.
#
#       Example program starts here.
#
#         % --------------------- Program Setup ---------------------
#
#         metakr = 'mgs_ex.tm';
#         camera = 'MGS_MOC_NA';
#         NCORNR = 4;
#         ABCORR = 'CN+S';
#
#         %
#         % Load kernels
#         %
#         cspice_furnsh( metakr );
#
#         %
#         % Convert the time the picture was taken from a
#         % UTC time string to seconds past J2000, TDB.
#         %
#         etrec = cspice_str2et( '2003 OCT 13 06:00:00 UTC' );
#
#         %
#         % Assume the one-way light times from different
#         % surface points on Mars to MGS within the camera's
#         % FOV are equal. This means the photons that make
#         % up different pixels were all emitted from Mars at
#         % 'etemit' and received by MGS at 'etrec'.  It would be
#         % slow to process images using 'cspice_sincpt' for every
#         % pixel.  Instead, we will use 'cspice_sincpt' on the
#         % boresight pixel and use 'cspice_surfpt' for the first FOV
#         % boundary pixel.  If this example program were extended
#         % to include all of the camera's pixels, 'cspice_surfpt' would
#         % be used for the remaining pixels.
#         %
#         % Get the MGS MOC Narrow angle camera (MGS_MOC_NA)
#         % ID code. Then look up the field of view (FOV)
#         % parameters by calling 'cspice_getfov'.
#         %
#         [camid, found] = cspice_bodn2c( camera );
#
#         if ( ~found )
#             txt = sprintf( ['SPICE(NOTRANSLATION)' ...
#                             'Could not find ID code for instrument %s.' ], ...
#                             camera );
#             error( txt )
#         end
#
#         %
#         % 'cspice_getfov' will return the name of the camera-fixed frame
#         % in the string OBSREF, the camera boresight vector in
#         % the array BSIGHT, and the FOV corner vectors in the
#         % array BOUNDS.
#         %
#         [shape, obsref, bsight, bounds] = cspice_getfov( camid, NCORNR);
#
#         fprintf( '\nObservation Reference Frame:  %s\n', obsref );
#
#         %
#         % ----------- Boresight Surface Intercept -----------
#         %
#         % Retrieve the time, surface intercept point, and vector
#         % from MGS to the boresight surface intercept point
#         % in IAU_MARS coordinates.
#         %
#         [ spoint, etemit, srfvec, found ] = ...
#                 cspice_sincpt( 'Ellipsoid', 'Mars', etrec,  'IAU_MARS', ...
#                                 ABCORR,     'MGS' , obsref,  bsight );
#
#         if ( ~found )
#             txt = sprintf( ['SPICE(NOINTERCEPT)' ...
#                             'Intercept not found for boresight vector.' ]);
#             error( txt )
#         end
#
#         %
#         % Convert the intersection point of the boresight
#         % vector and Mars from rectangular into latitudinal
#         % coordinates. Convert radians to degrees.
#         %
#         [ radius, lon, lat ] = cspice_reclat( spoint );
#
#         lon = lon * cspice_dpr;
#         lat = lat * cspice_dpr;
#
#         fprintf( ['\n'                                         ...
#                   'Boresight surface intercept coordinates:\n' ...
#                   '    Radius    (km) :  %f\n'                 ...
#                   '    Latitude  (deg):  %f\n'                 ...
#                   '    Longitude (deg):  %f\n' ],              ...
#                    radius, lat, lon );
#
#         %
#         % ------ 1st Boundary FOV Surface Intercept (cspice_surfpt) -----
#         %
#         % Now we will transform the first FOV corner vector into the
#         % IAU_MARS frame so the surface intercept point can be
#         % calculated using cspice_surfpt, which is faster than
#         % cspice_subpnt.
#         %
#         % If this example program were extended to include all
#         % of the pixels in the camera's FOV, a few steps, such as
#         % finding the rotation matrix from the camera frame to the
#         % IAU_MARS frame, looking up the semi-axis values for Mars,
#         % and finding the position of MGS with respect to Mars could
#         % be done once and used for every pixel.
#         %
#         % Find the rotation matrix from the ray's reference
#         % frame at the time the photons were received (etrec)
#         % to IAU_MARS at the time the photons were emitted
#         % (etemit).
#         %
#         [rotate] = pxfrm2( obsref, 'IAU_MARS', etrec, etemit );
#
#         %
#         % Look up the semi-axis values for Mars.
#         %
#         radii = cspice_bodvrd( 'MARS', 'RADII', 3 );
#
#         %
#         % Find the position of the center of Mars with respect
#         % to MGS.  The position of the observer with respect
#         % to Mars is required for the call to 'cspice_surfpt'.  Note:
#         % the apparent position of MGS with respect to Mars is
#         % not the same as the negative of Mars with respect to MGS.
#         %
#         pos_mgs_wrt_mars = spoint - srfvec;
#
#         %
#         % The first boundary FOV pixel must be rotated into the
#         % IAU_MARS reference frame.
#         %
#         bndvec = rotate * bounds(:,1);
#
#         %
#         % Calculate the surface point of the boundary FOV
#         % vector.
#         %
#         [surface_point, found] = cspice_surfpt ( pos_mgs_wrt_mars, ...
#                                                  bndvec, radii(1), ...
#                                                  radii(2), radii(3) );
#
#         if ( ~found )
#             txt = 'SPICE(NOTFOUND)Could not calculate surface point.';
#             error( txt )
#         end
#
#         surf_point_using_surfpt = surface_point;
#
#         %
#         % Convert the intersection point of the boundary
#         % FOV vector and Mars from rectangular into
#         % latitudinal coordinates. Convert radians
#         % to degrees.
#         %
#         [ radius, lon, lat ] = cspice_reclat( surface_point );
#
#         lon = lon * cspice_dpr;
#         lat = lat * cspice_dpr;
#
#         fprintf( ['\n'                                        ...
#                   'Boundary vector surface intercept\n'       ...
#                   'coordinates using cspice_surfpt:\n'        ...
#                   '    Radius    (km) :  %f\n'                ...
#                   '    Latitude  (deg):  %f\n'                ...
#                   '    Longitude (deg):  %f\n'                ...
#                   '    Emit time using boresight LT (s):  %10.9f\n'], ...
#                    radius, lat, lon, etemit );
#
#         %
#         % ------ 1st Boundary FOV Surface Intercept Verification ----
#         %
#         % For verification only, we will calculate the surface
#         % intercept coordinates for the first boundary vector
#         % using 'cspice_sincpt' and compare to the faster
#         % 'cspice_surfpt' method.
#         %
#         [ surface_point, etemit, srfvec, found ] = ...
#                  cspice_sincpt( 'Ellipsoid', 'Mars', etrec,  'IAU_MARS', ...
#                                  ABCORR,     'MGS' , obsref,  bounds(:,1) );
#
#         if ( ~found )
#             txt = sprintf( ['SPICE(NOTFOUND)' ...
#                             'Intercept not found for ' ...
#                             'the boundary FOV vector.' ]);
#             error( txt )
#         end
#
#         %
#         % Convert the intersection point of the first boundary
#         % vector and Mars from rectangular into latitudinal
#         % coordinates. Convert radians to degrees.
#         %
#         [ radius, lon, lat ] = cspice_reclat( surface_point );
#
#         lon = lon * cspice_dpr;
#         lat = lat * cspice_dpr;
#
#         fprintf( ['\n'                                              ...
#                   'Boundary vector surface intercept\n'             ...
#                   'coordinates using cspice_sincpt:\n'              ...
#                   '    Radius    (km) :  %f\n'                      ...
#                   '    Latitude  (deg):  %f\n'                      ...
#                   '    Longitude (deg):  %f\n'                      ...
#                   '    Emit time using boresight LT (s):  %10.9f\n\n'], ...
#                    radius, lat, lon, etemit );
#
#         distance = cspice_vdist ( surf_point_using_surfpt, surface_point );
#
#         fprintf( [ 'Distance between surface points of the first\n' ...
#                    'boundary vector using cspice_surfpt and\n'      ...
#                    'cspice_sincpt:\n'                               ...
#                    '    Distance (mm):   %f\n' ],                   ...
#                    distance*10^6 );
#
#         %
#         % It's always good form to unload kernels after use,
#         % particularly in MATLAB due to data persistence.
#         %
#         cspice_kclear
#
#   MATLAB outputs:
#
#             Observation Reference Frame:  MGS_MOC_NA
#
#             Boresight surface intercept coordinates:
#                 Radius    (km) :  3384.940410
#                 Latitude  (deg):  -48.479580
#                 Longitude (deg):  -123.436454
#
#             Boundary vector surface intercept
#             coordinates using cspice_surfpt:
#                 Radius    (km) :  3384.941136
#                 Latitude  (deg):  -48.477482
#                 Longitude (deg):  -123.474080
#                 Emit time using boresight LT (s):  119296864.181059480
#
#             Boundary vector surface intercept
#             coordinates using cspice_sincpt:
#                 Radius    (km) :  3384.941136
#                 Latitude  (deg):  -48.477482
#                 Longitude (deg):  -123.474079
#                 Emit time using boresight LT (s):  119296864.181059465
#
#             Distance between surface points of the first
#             boundary vector using cspice_surfpt and
#             cspice_sincpt:
#                 Distance (mm):   32.139880
#
#-Version
#
#   -Mice Version 1.0.0  12-MAR-2012 SCK (JPL)
#
#-Disclaimer
#
#    THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#    CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#    GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#    ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#    PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
#    TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
#    WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
#    PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#    SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#    SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#    IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
#    BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
#    LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
#    INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
#    REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
#    REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
#
#    RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
#    THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
#    CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
#    ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#            #####
#     ####  #     #  #    #
#    #    #       #  ##  ##
#    #    #  #####   # ## #
#    #  # # #        #    #
#    #   #  #        #    #
#     ### # #######  #    #
#
#   quaternion to matrix
#
################################################################################
#-Abstract
#
#   q2m calculates the 3x3 double precision, rotation matrix
#   corresponding to a specified unit quaternion.
#
#-I/O
#
#   Given:
#
#      q   a double precision, unit length 4-vector or 4xN array of
#          unit 4-vectors
#
#          Note that multiple styles of quaternions are in use.
#          This routine returns a quaternion that conforms to
#          the SPICE convention. See the Particulars section
#          for details.
#
#   the call:
#
#      r = q2m(q)
#
#   returns:
#
#      r   a double precision 3x3 or 3X3XN array of rotation
#          matrices corresponding to 'q'
#
#-Particulars
#
#   About SPICE quaternions
#   =======================
#
#   There are (at least) two popular "styles" of quaternions; these
#   differ in the layout of the quaternion elements, the definition
#   of the multiplication operation, and the mapping between the set
#   of unit quaternions and corresponding rotation matrices.
#
#   SPICE-style quaternions have the scalar part in the first
#   component and the vector part in the subsequent components. The
#   SPICE convention, along with the multiplication rules for SPICE
#   quaternions, are those used by William Rowan Hamilton, the
#   inventor of quaternions.
#
#   Another common quaternion style places the scalar component
#   last.  This style is often used in engineering applications.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine q2m_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # q2m
#       (r::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        q2m(
            q::Array{Float64,1}) # Array_4_ConstSpiceDouble
        
#       enforce input array sizes
        if length(q) != 4
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        r = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        r_ptr = pointer(r)
        
#       make transposed copies of all input arrays and their pointers
        q_t = q'
        q_ptr = pointer(q_t)
        
#       ccall((:q2m_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_4_ConstSpiceDouble,Array_3_Array_3_SpiceDouble),q,r)
        ccall((:q2m_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64}),
            q_ptr,r_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#-Version
#
#    -Mice Version 1.0.0, 10-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    #####   #####   ######   ####
#    #    #   #  #   #    #  #    #  #       #    #
#    #    #  #    #  #    #  #    #  #####   #
#    #####   ######  #    #  #####   #       #
#    #   #   #    #  #    #  #   #   #       #    #
#    #    #  #    #  #####   #    #  ######   ####
#
#   range ra and dec to rectangular coordinates
#   right_ascension and declination to rectangular
#
################################################################################
#-Abstract
#
#   radrec converts the right ascension, declination
#   coordinates of a location to rectangular (Cartesian)
#   coordinates.
#
#-I/O
#
#   Given:
#
#      range   a double precision scalar or 1XN-vector describing
#              distance of the point from the origin.
#
#      ra      a double precision scalar or 1XN-vector describing
#              right ascension of the input point:  the angular
#              distance measured toward the east from the prime meridian
#              to the meridian containing the input point. The direction
#              of increasing right ascension is from the +X axis towards
#              the +Y axis.
#
#              The range (i.e., the set of allowed values) of
#              `ra' is unrestricted.  Units are radians.
#
#      dec     a double precision scalar or 1XN-vector describing
#              declination of the point.  This is the angular
#              distance from the XY plane to the point.
#
#              The range of `dec' is unrestricted.  Units are radians.
#
#   the call:
#
#      rectan = radrec( range, ra, dec)
#
#   returns:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#               'rectan' returns with the same units associated with
#               'range'.
#
#               'rectan' returns with the same vectorization measure (N)
#                as 'range', 'ra', and 'dec'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine radrec_c.
#
#   MICE.REQ
#
    function # radrec
#       (rectan::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        radrec(
            range::Float64, # SpiceDouble
            ra::Float64, # SpiceDouble
            dec::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rectan = Array{Float64,1}(3);  # Array_3_SpiceDouble
        rectan_ptr = pointer(rectan)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:radrec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble),range,ra,dec,rectan)
        ccall((:radrec_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            range,ra,dec,rectan_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rectan
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load a standard kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define a set of 15 right ascension-declination data sets
#      % pairs (in degrees) for the earth's pole and the array of
#      % corresponding ephemeris times J2000 TDB.
#      %
#      right_ascen = [ 180.003739,
#                      180.003205,
#                      180.002671,
#                      180.002137,
#                      180.001602,
#                      180.001068,
#                      180.000534,
#                      360.000000,
#                      359.999466,
#                      359.998932,
#                      359.998397,
#                      359.997863,
#                      359.997329,
#                      359.996795,
#                      359.996261 ];
#
#       dec        = [ 89.996751,
#                      89.997215,
#                      89.997679,
#                      89.998143,
#                      89.998608,
#                      89.999072,
#                      89.999536,
#                      90.000000,
#                      89.999536,
#                      89.999072,
#                      89.998607,
#                      89.998143,
#                      89.997679,
#                      89.997215,
#                      89.996751 ];
#
#       et         = [ -18408539.52023917,
#                      -15778739.49107254,
#                      -13148939.46190590,
#                      -10519139.43273926,
#                      -7889339.40357262,
#                      -5259539.37440598,
#                      -2629739.34523934,
#                       60.68392730,
#                       2629860.71309394,
#                       5259660.74226063,
#                       7889460.77142727,
#                       10519260.80059391,
#                       13149060.82976055,
#                       15778860.85892719,
#                       18408660.88809383 ];
#
#      %
#      % Create a 1xN array of radii, the length of a
#      % unit vector (1) the same size as the above arrays.
#      %
#      n_elements  = size(dec);
#      rad         = ones( 1,  n_elements(1) );
#      z_hat       = [0; 0; 1];
#
#      %
#      % Convert the RA/DEC values to radians.
#      %
#      right_ascen = right_ascen * cspice_rpd;
#      dec         = dec * cspice_rpd;
#
#      %
#      % Convert the angular description of the unit vectors to
#      % Cartesian.
#      %
#      pole        = radrec( rad, right_ascen', dec');
#
#      %
#      % Retrieve the transformation matrix from frames J2000 to
#      % IAU_EARTH.
#      %
#      mat         = cspice_pxform( 'J2000', 'IAU_EARTH', et');
#
#      %
#      % Rotate the 'pole' vector set into IAU_FRAME. All vectors
#      % should equal (to round-off) the z direction unit vector.
#      %
#
#      disp( ['      ET                x            y '   ...
#                            '          z      Angular diff'] )
#      disp( [' ________________  __________  __________' ...
#                              '  __________ ______________'] )
#
#      for i =1:15
#         z = mat(:,:,i) * pole(:,i);
#
#         %
#         % Output the ephemeris time, the pole vector, and the angular
#         % separation between the calculated and the expected pole vectors.
#         %
#         txt = sprintf( '%18.8f %11.8f %11.8f %11.8f %11.8e', ...
#                        et(i), z, cspice_vsep(z,z_hat) );
#         disp(txt)
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#            ET                x            y           z      Angular diff
#       ________________  __________  __________  __________ ______________
#
#      -18408539.52023917  0.00000000 -0.00000000  1.00000000 2.72257100e-09
#      -15778739.49107254  0.00000000 -0.00000000  1.00000000 1.86400956e-10
#      -13148939.46190590 -0.00000000  0.00000000  1.00000000 3.09537269e-09
#      -10519139.43273926  0.00000000 -0.00000001  1.00000000 6.00434486e-09
#       -7889339.40357262  0.00000000 -0.00000001  1.00000000 8.53997578e-09
#       -5259539.37440598 -0.00000000  0.00000001  1.00000000 5.63100382e-09
#       -2629739.34523934 -0.00000000 -0.00000000  1.00000000 2.72203209e-09
#             60.68392730 -0.00000000 -0.00000000  1.00000000 1.86939958e-10
#        2629860.71309394  0.00000000  0.00000000  1.00000000 3.09591191e-09
#        5259660.74226063 -0.00000000 -0.00000001  1.00000000 6.00488364e-09
#        7889460.77142727 -0.00000000 -0.00000001  1.00000000 8.53943655e-09
#       10519260.80059391  0.00000000  0.00000000  1.00000000 5.63046483e-09
#       13149060.82976055 -0.00000000 -0.00000000  1.00000000 2.72149287e-09
#       15778860.85892719 -0.00000000 -0.00000000  1.00000000 1.87478860e-10
#       18408660.88809383  0.00000000  0.00000000  1.00000000 3.09645104e-09
#
#   The angular deviation between the calculated pole vector and the expected
#   measures as ~10**-9.
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#    #####     ##    #    # #     #  #    #  ######
#    #    #   #  #   #    #       #   #  #   #
#    #    #  #    #  #    #  #####     ##    #####
#    #####   ######  #    # #          ##    #
#    #   #   #    #   #  #  #         #  #   #
#    #    #  #    #    ##   #######  #    #  #
#
#  State transformation to rotation and angular velocity
#
################################################################################
#-Abstract
#
#   rav2xf determines the state transformation matrix
#   from a rotation matrix and the angular velocity of the
#   rotation.
#
#-I/O
#
#   Given:
#
#      rot   a double precision 3x3 array or double precision 3x3xN
#            array of rotation matrices that gives the transformation
#            from some frame "frame1" to another frame "frame2"
#
#      av    the double precision 3x1 array or double precision
#            3xN array of angular velocities of the transformation
#
#            If 'p' is the position of a fixed point in "frame2,"
#            then from the point of view of "frame1," 'p' rotates
#            (in a right handed sense) about an axis parallel to
#            'av'.  Moreover the rate of rotation in radians per unit
#            time is given by the length of 'av'.
#
#            More formally, the velocity 'v' of 'p' in "frame1" is
#            given by
#                                  t
#               v  = av x ( rot * p )
#
#            The components of 'av' are given relative to "frame1."
#
#   the call:
#
#      xform = rav2xf(rot, av)
#
#   returns:
#
#      xform   a double precision 6x6 or double precision 3x3xN
#              array of a state transformations associated
#              with 'rot' and 'av'.  If 's1' is the state of an object
#              with respect to "frame1", then the state 's2' of the
#              object with respect to "frame2" is given by
#
#                 s2  =  xform * s1
#
#              where "*" denotes matrix-vector multiplication.
#
#              'xform' returns with the same vectorization measure (N)
#              as 'rot' and 'av'.
#
#-Particulars
#
#   This routine is an inverse of the routine cspice_xf2rav.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine rav2xf_c.
#
#   MICE.REQ
#
    function # rav2xf
#       (xform::Array{Float64,2}(6,6)) =   # Array_6_Array_6_SpiceDouble
        rav2xf(
            rot::Array{Float64,2}, # Array_3_Array_3_ConstSpiceDouble
            av::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if size(rot) != (3,3)
            error("Incorrect size for parameter 1")
        end
        if length(av) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        xform = Array{Float64,2}(6,6);  # Array_6_Array_6_SpiceDouble
        xform_ptr = pointer(xform)
        
#       make transposed copies of all input arrays and their pointers
        rot_t = rot'
        rot_ptr = pointer(rot_t)
        av_t = av'
        av_ptr = pointer(av_t)
        
#       ccall((:rav2xf_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_6_Array_6_SpiceDouble),rot,av,xform)
        ccall((:rav2xf_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            rot_ptr,av_ptr,xform_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return xform'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Example(1):
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK file
#      %  and a leapseconds file. Use a meta kernel
#      %  for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define an angular velocity vector:
#      %
#      e1     =  [ 1.;   0.;  0. ];
#
#      %
#      % Rotation matrix for "elementary" frame rotations:  90 degrees
#      % about the z axes:
#      %
#      rz_90 = [[ 0.,  1.,  0. ]; ...
#               [-1.,  0.,  0. ]; ...
#               [ 0.,  0.,  1. ] ];
#
#      %
#      % The call rav2xf calculates the state transformation matrix
#      % 'strans' associated with the angular velocity vector and the
#      % rotation matrix.
#      %
#      strans = rav2xf( rz_90, e1 );
#
#      %
#      % cspice_xf2rav converts a state transformation to the associated
#      % rotation matrix and angular velocity vector - inverting
#      % the operation of rav2xf
#      %
#      [rot, av ] = cspice_xf2rav(strans);
#
#      %
#      % Calculate the maximum value of the absolute difference between the
#      % output 'av' and 'rot' vs the inputs 'e1' and 'rz-90'.
#      %
#      disp( 'Scalar:' )
#      fprintf(                                                              ...
#         'Maximum absolute difference between rotation matrices: %8.6e\n', ...
#                                              max( max( abs(rot - rz_90) ) )  )
#      fprintf(                                                              ...
#         'Maximum absolute difference between angular velocities: %8.6e\n', ...
#                                              max( max(av - e1 ) )            )
#
#   MATLAB outputs:
#
#      Maximum absolute difference between rotation matrices: 0.000000e+00
#      Maximum absolute difference between angular velocities: 0.000000e+00
#
#      Numerical equivalent as expected.
#
#      Example(2):
#
#      %
#      % Create an array of 10001 ephemeris times based at July 1 2007.
#      %
#      et    = [0: 10000]* cspice_spd + cspice_str2et( 'July 1 2007' );
#
#      %
#      % Calculate the state transformation matrices from J2000 to IAU_MOON
#      % for 'et'.
#      %
#      xform = cspice_sxform( 'J2000', 'IAU_MOON', et );
#
#      %
#      % Convert the set of 'xform' matrices to the corresponding rotation
#      % matrices and angular velocity vectors.
#      %
#      [ rot, av ] = cspice_xf2rav(xform);
#
#      %
#      % Use the converted outputs from cspice_xf2rav to recompute a set
#      % of state transformation matrices.
#      %
#      strans = rav2xf( rot, av );
#
#      %
#      % Calculate the maximum value of the absolute difference between
#      % 'xform' and 'strans'.
#      %
#      disp( 'Vector:' )
#      fprintf(                                                              ...
#         'Maximum absolute difference between rotation matrices: %8.6e\n', ...
#                                   max( max( max( abs(strans - xform) ) ) )   )
#
#      %
#      %  It's always good form to unload kernels after use,
#      %  particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Vector:
#      Maximum absolute difference between rotation matrices: 1.694066e-21
#
#      In this case, a value on the order of -21 indicates numerical
#      equivalence.
#
#-Version
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 11-APR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####     ##    #    #     #     ####     ##
#    #    #   #  #    #  #      #    #        #  #
#    #    #  #    #    ##       #     ####   #    #
#    #####   ######    ##       #         #  ######
#    #   #   #    #   #  #      #    #    #  #    #
#    #    #  #    #  #    #     #     ####   #    #
#
#   rotation axis of a matrix
#
################################################################################
#-Abstract
#
#   raxisa computes the axis of the rotation given by an input matrix
#   and the angle of the rotation about that axis.
#
#-I/O
#
#   Given:
#
#      matrix   a double precision 3x3 array defining a rotation
#
#   the call:
#
#      [axis, angle] = raxisa( matrix )
#
#   returns:
#
#      axis   a double precision 3x1 unit array pointing along the axis
#             of the rotation. In other words, 'axis' is a unit eigenvector
#             of the input matrix, corresponding to the eigenvalue 1. If
#             the input matrix is the identity matrix, 'axis' will be the
#             vector (0, 0, 1). If the input rotation is a rotation by pi
#             radians, both 'axis' and -axis may be regarded as the axis
#             of the rotation.
#
#      angle  a double precision scalar defining the angle
#             between 'v' and matrix*'v' for any non-zero vector 'v'
#             orthogonal to 'axis'.  'angle' is given in radians.
#             The angle returned will be in the range from 0 to
#             pi radians.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine raxisa_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # raxisa
#       (axis::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        angle::Float64) =   # Ptr{SpiceDouble}
        raxisa(
            matrix::Array{Float64,2}) # Array_3_Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if size(matrix) != (3,3)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        axis = Array{Float64,1}(3);  # Array_3_SpiceDouble
        axis_ptr = pointer(axis)
        angle = Array{Float64}(1);  # Ptr{SpiceDouble}
        angle_ptr = pointer(angle)
        
#       make transposed copies of all input arrays and their pointers
        matrix_t = matrix'
        matrix_ptr = pointer(matrix_t)
        
#       ccall((:raxisa_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble}),matrix,axis,angle)
        ccall((:raxisa_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            matrix_ptr,axis_ptr,angle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return axis, angle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Example:
#      %
#      % Define an axis and an angle for rotation.
#      %
#      axis = [ 1.; 2.; 3. ];
#      angle = .1 * cspice_twopi;
#
#      %
#      % Determine the rotation matrix.
#      %
#      rot_mat = cspice_axisar( axis, angle );
#
#      %
#      % Now calculate the rotation axis and angle based on the
#      % matrix as input.
#      %
#      [ axout, angout ] = raxisa( rot_mat);
#
#      %
#      % Now input the axout and angout to cspice_axisar to
#      % compare against the original rotation matrix rot_mat.
#      %
#      rot_out = cspice_axisar( axout, angout );
#      rot_mat - rot_out
#
#   MATLAB outputs:
#
#      1.0e-15 *
#
#                     0  -0.11102230246252   0.05551115123126
#      0.11102230246252                  0                  0
#     -0.05551115123126   0.02775557561563                  0
#
#   The zero matrix accurate to round-off error. A numerical
#   demonstration of equality.
#
#-Version
#
#   -Mice Version 1.0.0, 29-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######   ####    ####    #   #  #
#    #    #  #       #    #  #    #    # #   #
#    #    #  #####   #       #          #    #
#    #####   #       #       #          #    #
#    #   #   #       #    #  #    #     #    #
#    #    #  ######   ####    ####      #    ######
#
#   rectangular to cylindrical coordinates
#
################################################################################
#-Abstract
#
#   reccyl converts rectangular (Cartesian) coordinates to
#   cylindrical coordinates.
#
#-I/O
#
#   Given:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#   the call:
#
#       [r, lonc, z] = reccyl( rectan)
#
#   returns:
#
#      r      a double precision scalar or double precision 1xN array
#             describing the distance of the point of interest from z axis
#
#      lonc   a double precision scalar or double precision 1xN array
#             describing the cylindrical angle of the point of interest
#             from the XZ plane measured in radians
#
#      z      a double precision scalar or double precision 1xN array
#             describing the height of the point above the XY plane
#
#             The arguments 'r' and 'z' return in the same units associated
#             with 'rectan'.
#
#             'r', 'lonc', and 'z' return with the same vectorization
#             measure as 'rectan'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine reccyl_c.
#
#   MICE.REQ
#
    function # reccyl
#       (r::Float64,  # Ptr{SpiceDouble}
#        lon::Float64,  # Ptr{SpiceDouble}
#        z::Float64) =   # Ptr{SpiceDouble}
        reccyl(
            rectan::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(rectan) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        r = Array{Float64}(1);  # Ptr{SpiceDouble}
        r_ptr = pointer(r)
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        z = Array{Float64}(1);  # Ptr{SpiceDouble}
        z_ptr = pointer(z)
        
#       make transposed copies of all input arrays and their pointers
        rectan_t = rectan'
        rectan_ptr = pointer(rectan_t)
        
#       ccall((:reccyl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),rectan,r,lon,z)
        ccall((:reccyl_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            rectan_ptr,r_ptr,lon_ptr,z_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r[1], lon[1], z[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to cylindrical
#      % coordinates.
#      %
#      [r, lonc, z] = reccyl(pos);
#
#      %
#      % Convert the cylindrical to rectangular.
#      %
#      [rectan] = cspice_cylrec(r, lonc, z);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-13 *
#
#      0.00199609007208                  0  -0.25513381329527
#     -0.00218237675815                  0  -0.00153127196389
#                     0                  0                  0
#
#       The relative error between the original array of position vectors
#       and those that resulted from the various coordinate conversion
#       has magnitude on the order of 10^(-13).  A numerical
#       demonstration of equality.
#
#   Example (2):
#
#      %
#      % Define eleven sets of rectangular coordinates.
#      %
#      rec = [ [ 0., 1., 0., 0., -1., 0., 0., 1., 1., 0., 1. ]; ...
#              [ 0., 0., 1., 0., 0., -1., 0., 1., 0., 1., 1. ]; ...
#              [ 0., 0., 0., 1., 0., 0., -1., 0., 1., 1., 1. ]    ];
#
#      %
#      % ...convert the rectangular coordinates to cylindrical coordinates
#      %
#      [r, lonc, z] = reccyl(rec);
#
#      %
#      % Convert 'lonc' to degrees...
#      %
#      lonc = lonc * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r         lonc        z           x         y           z   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; lonc; z; rec(1,:); rec(2,:); rec(3,:) ];
#      txt    = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output);
#      disp( txt );
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#
#   MATLAB outputs:
#
#        r         lonc        z           x         y           z
#     --------   --------   --------   --------   --------   --------
#       0.0000     0.0000     0.0000     0.0000     0.0000     0.0000
#       1.0000     0.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     0.0000     1.0000     0.0000
#       0.0000     0.0000     1.0000     0.0000     0.0000     1.0000
#       1.0000   180.0000     0.0000    -1.0000     0.0000     0.0000
#       1.0000   270.0000     0.0000     0.0000    -1.0000     0.0000
#       0.0000     0.0000    -1.0000     0.0000     0.0000    -1.0000
#       1.4142    45.0000     0.0000     1.0000     1.0000     0.0000
#       1.0000     0.0000     1.0000     1.0000     0.0000     1.0000
#       1.0000    90.0000     1.0000     0.0000     1.0000     1.0000
#       1.4142    45.0000     1.0000     1.0000     1.0000     1.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######   ####    ####   ######   ####
#    #    #  #       #    #  #    #  #       #    #
#    #    #  #####   #       #       #####   #    #
#    #####   #       #       #  ###  #       #    #
#    #   #   #       #    #  #    #  #       #    #
#    #    #  ######   ####    ####   ######   ####
#
#   rectangular to geodetic
#
################################################################################
#-Abstract
#
#   recgeo converts rectangular coordinates to geodetic
#   coordinates.
#%
#-I/O
#
#   Given:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#       re      the scalar, double precision equatorial radius of
#               the body of interest
#
#       f       the scalar, double precision flattening coefficient
#               of the body, a dimensionless value defined as:
#
#                    equatorial_radius - polar_radius
#                    --------------------------------
#                           equatorial_radius
#
#   the call:
#
#      [ lon, lat, alt ] = recgeo( rectan, re, f)
#
#   returns:
#
#       lon   a double precision scalar or 1XN-vector describing
#             the geodetic longitude measured in radians.
#
#       lat   a double precision scalar or 1XN-vector describing
#             the geodetic latitude measured in radians.
#
#       alt   a double precision scalar or 1XN-vector describing
#             the altitude above the reference spheroid.
#
#             'lon', 'lat', and 'alt' return with the same vectorization
#             measure (N) as 'rectan'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine recgeo_c.
#
#   MICE.REQ
#
    function # recgeo
#       (lon::Float64,  # Ptr{SpiceDouble}
#        lat::Float64,  # Ptr{SpiceDouble}
#        alt::Float64) =   # Ptr{SpiceDouble}
        recgeo(
            rectan::Array{Float64,1}, # Array_3_ConstSpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(rectan) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        lat = Array{Float64}(1);  # Ptr{SpiceDouble}
        lat_ptr = pointer(lat)
        alt = Array{Float64}(1);  # Ptr{SpiceDouble}
        alt_ptr = pointer(alt)
        
#       make transposed copies of all input arrays and their pointers
        rectan_t = rectan'
        rectan_ptr = pointer(rectan_t)
        
#       ccall((:recgeo_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),rectan,re,f,lon,lat,alt)
        ccall((:recgeo_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            rectan_ptr,re,f,lon_ptr,lat_ptr,alt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return lon[1], lat[1], alt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the standard kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Retrieve the triaxial radii of the earth
#      %
#      radii = cspice_bodvrd( 'EARTH', 'RADII', 3 );
#
#      %
#      % Calculate the flatness coefficient. Set a bodyfixed
#      % position.
#      %
#      flat = (radii(1) - radii(3))/radii(1);
#      x    = [ -2541.748162; 4780.333036; 3360.428190];
#
#      [ lon, lat, alt] = recgeo( x, radii(1), flat );
#
#      %
#      % Output, convert the angular values to degrees.
#      %
#      lon = lon * cspice_dpr;
#      lat = lat * cspice_dpr;
#
#      disp('Scalar:')
#      txt = sprintf( '%12.8f   %12.8f   %12.8f', lon , lat , alt );
#      disp( txt )
#
#      disp(' ')
#
#      %
#      % Using the equatorial radius of the Clark66 spheroid
#      % (CLARKR = 6378.2064 km) and the Clark 66 flattening
#      % factor (CLARKF = 1.0 / 294.9787 ) convert to
#      % body fixed rectangular coordinates.
#      %
#      CLARKR = 6378.2064;
#      CLARKF = 1./294.9787;
#
#      x = [ [ 0, 1, 0, 0, -1,  0,  0, 1, 1, 0, 1];
#            [ 0, 0, 1, 0,  0, -1,  0, 1, 0, 1, 1];
#            [ 0, 0, 0, 1,  0,  0, -1, 0, 1, 1, 1] ];
#
#      [ lon, lat, alt] = recgeo(  x, CLARKR, CLARKF );
#
#      %
#      % Output, convert the angular values to degrees.
#      %
#      lon = lon * cspice_dpr;
#      lat = lat * cspice_dpr;
#
#      disp('Vector:')
#
#      %
#      % Output banner.
#      %
#    disp('    lon        lat          alt         x          y          z    ')
#    disp('  --------   --------   ----------   --------   --------   --------')
#
#      output = [ lon; lat; alt; x(1,:); x(2,:); x(3,:) ];
#      txt    = sprintf( '%10.4f %10.4f %12.6f %10.4f %10.4f %10.4f\n',output);
#      disp(txt)
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#         118.00000000    32.00000000     0.00000024
#
#      118 degrees west, 32 north, 0.24 mm altitude.
#
#   Vector:
#       lon        lat          alt         x          y          z
#     --------   --------   ----------   --------   --------   --------
#       0.0000    90.0000 -6356.583800     0.0000     0.0000     0.0000
#       0.0000    88.6772 -6356.572258     1.0000     0.0000     0.0000
#      90.0000    88.6772 -6356.572258     0.0000     1.0000     0.0000
#       0.0000    90.0000 -6355.583800     0.0000     0.0000     1.0000
#     180.0000    88.6772 -6356.572258    -1.0000     0.0000     0.0000
#     -90.0000    88.6772 -6356.572258     0.0000    -1.0000     0.0000
#       0.0000   -90.0000 -6355.583800     0.0000     0.0000    -1.0000
#      45.0000    88.1291 -6356.560715     1.0000     1.0000     0.0000
#       0.0000    88.7071 -6355.572518     1.0000     0.0000     1.0000
#      90.0000    88.7071 -6355.572518     0.0000     1.0000     1.0000
#      45.0000    88.1714 -6355.561236     1.0000     1.0000     1.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######   ####   #         ##     #####
#    #    #  #       #    #  #        #  #      #
#    #    #  #####   #       #       #    #     #
#    #####   #       #       #       ######     #
#    #   #   #       #    #  #       #    #     #
#    #    #  ######   ####   ######  #    #     #
#
#   rectangular to latitudinal coordinates
#
################################################################################
#-Abstract
#
#   reclat converts rectangular (Cartesian) coordinates to
#   latitudinal coordinates. All coordinates are expressed as
#   double precision values.
#
#-I/O
#
#   Given:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#   the call:
#
#      [radius, longitude, latitude] = reclat(rectan)
#
#   returns:
#
#      radius      a double precision scalar or double precision 1xN array
#                  describing the distance of the position from origin
#
#      longitude   a double precision scalar or double precision 1xN array
#                  describing the angle of the position from the XZ plane
#                  measured in radians
#
#      latitude    a double precision scalar or double precision 1xN array
#                  describing the angle of the position from the XY plane
#                  measured in radians
#
#                  The argument 'radius' returns in the same units associated
#                  with 'rectan'.
#
#                  'radius', 'longitude', and 'latitude' return with
#                  the same vectorization measure (N) as 'rectan'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine reclat_c.
#
#   MICE.REQ
#
    function # reclat
#       (radius::Float64,  # Ptr{SpiceDouble}
#        longitude::Float64,  # Ptr{SpiceDouble}
#        latitude::Float64) =   # Ptr{SpiceDouble}
        reclat(
            rectan::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(rectan) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        radius = Array{Float64}(1);  # Ptr{SpiceDouble}
        radius_ptr = pointer(radius)
        longitude = Array{Float64}(1);  # Ptr{SpiceDouble}
        longitude_ptr = pointer(longitude)
        latitude = Array{Float64}(1);  # Ptr{SpiceDouble}
        latitude_ptr = pointer(latitude)
        
#       make transposed copies of all input arrays and their pointers
        rectan_t = rectan'
        rectan_ptr = pointer(rectan_t)
        
#       ccall((:reclat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),rectan,radius,longitude,latitude)
        ccall((:reclat_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            rectan_ptr,radius_ptr,longitude_ptr,latitude_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return radius[1], longitude[1], latitude[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to latitudinal
#      % coordinates.
#      %
#      [radius, longitude, latitude] = reclat(pos);
#
#      %
#      % Convert the cylindrical to rectangular.
#      %
#      [rectan] = cspice_latrec(radius, longitude, latitude);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#    MATLAB outputs:
#
#      1.0e-14 *
#
#     -0.01996090072080  -0.05552320600838   0.63783453323816
#      0.02182376758148                  0  -0.01531271963894
#      0.01912147275010   0.01213804257114   0.02039513446643
#
#   Example (2):
#
#      %
#      % Define eleven sets of rectangular coordinates.
#      %
#      rec = [ [ 0., 1., 0., 0., -1., 0., 0., 1., 1., 0., 1. ]; ...
#              [ 0., 0., 1., 0., 0., -1., 0., 1., 0., 1., 1. ]; ...
#              [ 0., 0., 0., 1., 0., 0., -1., 0., 1., 1., 1. ]    ];
#
#      %
#      % ...convert the rectangular coordinates to latitudinal coordinates
#      %
#      [radius, longitude, latitude] = reclat(rec);
#
#      %
#      % Convert 'longitude' and 'latitude' to degrees.
#      %
#      longitude = longitude * cspice_dpr;
#      latitude  = latitude  * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('   radius    longitude  latitude       x         y           z   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [radius; longitude; latitude; rec(1,:); rec(2,:); rec(3,:) ];
#      txt    = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', ...
#                        output );
#
#      disp( txt );
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#    MATLAB outputs:
#
#      radius    longitude  latitude       x         y           z
#     --------   --------   --------   --------   --------   --------
#       0.0000     0.0000     0.0000     0.0000     0.0000     0.0000
#       1.0000     0.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     0.0000     1.0000     0.0000
#       1.0000     0.0000    90.0000     0.0000     0.0000     1.0000
#       1.0000   180.0000     0.0000    -1.0000     0.0000     0.0000
#       1.0000   -90.0000     0.0000     0.0000    -1.0000     0.0000
#       1.0000     0.0000   -90.0000     0.0000     0.0000    -1.0000
#       1.4142    45.0000     0.0000     1.0000     1.0000     0.0000
#       1.4142     0.0000    45.0000     1.0000     0.0000     1.0000
#       1.4142    90.0000    45.0000     0.0000     1.0000     1.0000
#       1.7321    45.0000    35.2644     1.0000     1.0000     1.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######   ####   #####    ####   #####
#    #    #  #       #    #  #    #  #    #  #    #
#    #    #  #####   #       #    #  #       #    #
#    #####   #       #       #####   #  ###  #####
#    #   #   #       #    #  #       #    #  #   #
#    #    #  ######   ####   #        ####   #    #
#
#   convert rectangular to planetographic coordinates
#
################################################################################
#-Abstract
#
#   recpgr converts rectangular coordinates to
#   planetographic coordinates.
#
#-I/O
#
#   Given:
#
#      body     the scalar string name of the body with which the
#               planetographic coordinate system is associated,
#               optionally, you may supply the integer ID code
#               for the object as an integer string, i.e. both
#               'MOON' and '301' are legitimate strings that
#               indicate the Moon is the target body
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the body-fixed rectangular
#               coordinates of the position or set of positions
#
#       re      the scalar, double precision equatorial radius of
#               the body of interest
#
#       f       the scalar, double precision flattening coefficient
#               of the body, a dimensionless value defined as:
#
#                    equatorial_radius - polar_radius
#                    --------------------------------
#                           equatorial_radius
#
#   the call:
#
#      [ lon, lat, alt ] = recpgr( body, rectan, re, f)
#
#   returns:
#
#       lon   a double precision scalar or 1XN-vector describing
#             the planetographic longitude of the input point.  This is
#             the angle between the prime meridian and the meridian
#             containing 'rectan'.  For bodies having prograde (aka
#             direct) rotation, the direction of increasing
#             longitude is positive west:  from the +X axis of the
#             rectangular coordinate system toward the -Y axis.
#             For bodies having retrograde rotation, the direction
#             of increasing longitude is positive east:  from the +X
#             axis toward the +Y axis.
#
#             The earth, moon, and sun are exceptions: planetographic
#             longitude is measured positive east for these bodies.
#
#             The default interpretation of longitude by this
#             and the other planetographic coordinate conversion
#             routines can be overridden; see the discussion in
#             Particulars below for details.
#
#             'lon' is output in radians.  The nominal range of 'lon' is
#             given by:
#
#                0  <  lon  <  2*pi
#                   -
#
#             However, round-off error could cause 'lon' to equal 2*pi.
#
#       lat   a double precision scalar or 1XN-vector describing
#             the planetographic latitude of the input point.  For a
#             point P on the reference spheroid, this is the angle
#             between the XY plane and the outward normal vector at
#             P. For a point P not on the reference spheroid, the
#             planetographic latitude is that of the closest point
#             to P on the spheroid.
#
#             'lat' is output in radians. The range of 'lat' is given
#             by:
#
#                -pi/2  <  lat  <  pi/2
#                       -       -
#
#       alt   a double precision scalar or 1XN-vector describing
#             the altitude above the reference spheroid
#
#             'lon', 'lat', and 'alt' return with the same vectorization
#             measure (N) as 'rectan'.
#
#-Particulars
#
#   Given the planetographic coordinates of a point, this routine
#   returns the body-fixed rectangular coordinates of the point.  The
#   body-fixed rectangular frame is that having the X-axis pass
#   through the 0 degree latitude 0 degree longitude direction, the
#   Z-axis pass through the 90 degree latitude direction, and the
#   Y-axis equal to the cross product of the unit Z-axis and X-axis
#   vectors.
#
#   The planetographic definition of latitude is identical to the
#   planetodetic (also called "geodetic" in SPICE documentation)
#   definition. In the planetographic coordinate system, latitude is
#   defined using a reference spheroid.  The spheroid is
#   characterized by an equatorial radius and a polar radius. For a
#   point P on the spheroid, latitude is defined as the angle between
#   the X-Y plane and the outward surface normal at P.  For a point P
#   off the spheroid, latitude is defined as the latitude of the
#   nearest point to P on the spheroid.  Note if P is an interior
#   point, for example, if P is at the center of the spheroid, there
#   may not be a unique nearest point to P.
#
#   In the planetographic coordinate system, longitude is defined
#   using the spin sense of the body.  Longitude is positive to the
#   west if the spin is prograde and positive to the east if the spin
#   is retrograde.  The spin sense is given by the sign of the first
#   degree term of the time-dependent polynomial for the body's prime
#   meridian Euler angle "W":  the spin is retrograde if this term is
#   negative and prograde otherwise.  For the sun, planets, most
#   natural satellites, and selected asteroids, the polynomial
#   expression for W may be found in a SPICE PCK kernel.
#
#   The earth, moon, and sun are exceptions: planetographic longitude
#   is measured positive east for these bodies.
#
#   If you wish to override the default sense of positive longitude
#   for a particular body, you can do so by defining the kernel
#   variable
#
#      BODY<body ID>_PGR_POSITIVE_LON
#
#   where <body ID> represents the NAIF ID code of the body. This
#   variable may be assigned either of the values
#
#      'WEST'
#      'EAST'
#
#   For example, you can have this routine treat the longitude
#   of the earth as increasing to the west using the kernel
#   variable assignment
#
#      BODY399_PGR_POSITIVE_LON = 'WEST'
#
#   Normally such assignments are made by placing them in a text
#   kernel and loading that kernel via furnsh_c.
#
#   The definition of this kernel variable controls the behavior of
#   the CSPICE planetographic routines
#
#      cspice_pgrrec
#      recpgr
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine recpgr_c.
#
#   MICE.REQ
#
    function # recpgr
#       (lon::Float64,  # Ptr{SpiceDouble}
#        lat::Float64,  # Ptr{SpiceDouble}
#        alt::Float64) =   # Ptr{SpiceDouble}
        recpgr(
            body::AbstractString, # Ptr{ConstSpiceChar}
            rectan::Array{Float64,1}, # Array_3_SpiceDouble
            re::Float64, # SpiceDouble
            f::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(rectan) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        lat = Array{Float64}(1);  # Ptr{SpiceDouble}
        lat_ptr = pointer(lat)
        alt = Array{Float64}(1);  # Ptr{SpiceDouble}
        alt_ptr = pointer(alt)
        
#       make transposed copies of all input arrays and their pointers
        rectan_t = rectan'
        rectan_ptr = pointer(rectan_t)
        
#       ccall((:recpgr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Array_3_SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),body,rectan,re,f,lon,lat,alt)
        ccall((:recpgr_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Float64},Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            body,rectan_ptr,re,f,lon_ptr,lat_ptr,alt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return lon[1], lat[1], alt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load a PCK file containing a triaxial
#      % ellipsoidal shape model and orientation
#      % data for Mars.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Example 1: convert a single set of bodyfixed
#      %           coordinates to planetographic
#      %           coordinates.
#      %
#      % Look up the radii for Mars.  Although we
#      % omit it here, we could check the kernel pool
#      % to make sure the variable BODY499_RADII
#      % has three elements and numeric data type.
#      % If the variable is not present in the kernel
#      % pool, cspice_bodvrd will signal an error.
#      %
#      body = 'MARS';
#      radii = cspice_bodvrd( body, 'RADII', 3 );
#
#      %
#      %
#      % Calculate the flatness coefficient. Set a bodyfixed
#      % position vector, 'x'.
#      %
#      re   = radii(1);
#      rp   = radii(3);
#      flat = ( re - rp ) / re;
#      x    = [ 0.0,
#              -2620.678914818178,
#               2592.408908856967 ];
#
#      %
#      % Do the conversion.
#      %
#      [lon, lat, alt] = recpgr( body, x, re, flat );
#
#      %
#      % Output.
#      %
#      disp( 'Scalar:' )
#      disp(' ')
#
#      disp( 'Rectangular coordinates in km (x, y, z)' )
#      fprintf( '%9.3f   %9.3f   %9.3f\n', x' )
#
#      disp( 'Planetographic coordinates in degs and km (lon, lat, alt)' )
#      fprintf( '%9.3f   %9.3f   %9.3f\n', lon *cspice_dpr() ...
#                                        , lat *cspice_dpr() ...
#                                        , alt               )
#      disp(' ')
#
#      %
#      % Example 2: convert a vectorized set of bodyfixed coordinates
#      %            to planetographic coordinates
#      %
#      % Define an array of body-fixed 3x1 arrays.
#      %
#      x = [ [  3396.190;  0.000   ;  0.000    ], ...
#            [ -3396.190;  0.000   ;  0.000    ], ...
#            [ -3406.190;  0.000   ;  0.000    ], ...
#            [ -3406.190;  0.000   ;  0.000    ], ...
#            [  0.000   ; -3396.190;  0.000    ], ...
#            [  0.000   ;  3396.190;  0.000    ], ...
#            [  0.000   ;  0.000   ;  3376.200 ], ...
#            [  0.000   ;  0.000   ; -3376.200 ], ...
#            [  0.000   ;  0.000   ;   0.000   ] ];
#
#      %
#      % Using the same Mars parameters, convert the 3-vectors to
#      % planetographic.
#      %
#      [ lon, lat, alt] = recpgr( body, x, re, flat );
#
#      disp('Vector:')
#      disp(' ')
#
#      disp( ['rectan(1)   rectan(2)   rectan(3)' ...
#             '         lon         lat         alt'] )
#
#      disp( ['---------------------------------' ...
#             '------------------------------------'] )
#
#      %
#      % Create an array of values for output.
#      %
#      output = [  x(1,:);         x(2,:);         x(3,:); ...
#                  lon*cspice_dpr; lat*cspice_dpr; alt ];
#
#      txt = sprintf( '%9.3f   %9.3f   %9.3f   %9.3f   %9.3f   %9.3f\n', ...
#                                                                  output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#
#      Rectangular coordinates in km (x, y, z)
#          0.000   -2620.679    2592.409
#      Planetographic coordinates in degs and km (lon, lat, alt)
#         90.000      45.000     300.000
#
#      Vector:
#
#      rectan(1)   rectan(2)   rectan(3)         lon         lat         alt
#      ---------------------------------------------------------------------
#       3396.190      -0.000       0.000       0.000       0.000       0.000
#      -3396.190      -0.000       0.000     180.000       0.000       0.000
#      -3406.190      -0.000       0.000     180.000       0.000      10.000
#      -3406.190      -0.000       0.000     180.000       0.000      10.000
#          0.000   -3396.190       0.000      90.000       0.000       0.000
#         -0.000    3396.190       0.000     270.000       0.000       0.000
#          0.000      -0.000    3376.200       0.000      90.000       0.000
#          0.000      -0.000   -3376.200       0.000     -90.000       0.000
#          0.000       0.000       0.000       0.000      90.000   -3376.200
#
#-Version
#
#   -Mice Version 1.0.1, 30-DEC-2008, EDW (JPL)
#
#      Corrected misspellings.
#
#   -Mice Version 1.0.0, 22-JAN-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######   ####   #####     ##    #####
#    #    #  #       #    #  #    #   #  #   #    #
#    #    #  #####   #       #    #  #    #  #    #
#    #####   #       #       #####   ######  #    #
#    #   #   #       #    #  #   #   #    #  #    #
#    #    #  ######   ####   #    #  #    #  #####
#
#   rectangular coordinates to ra and dec
#   rectangular to right_ascension and declination
#
################################################################################
#-Abstract
#
#   recrad converts rectangular (Cartesian) coordinates to
#   right ascension, declination coordinates.
#
#-I/O
#
#   Given:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#   the call:
#
#      [range, ra, dec] = recrad(rectan)
#
#   returns:
#
#      radius   a double precision scalar or 1XN-vector describing
#               the distance of the position from origin.
#
#      ra       a double precision scalar or 1XN-vector describing
#               the right ascension of the position as measured in
#               radians.
#
#      dec      a double precision scalar or 1XN-vector describing
#               the declination of the position as measured in radians.
#
#               'radius', 'ra', and 'dec' return with the same
#               vectorization measure (N) as 'rectan'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine recrad_c.
#
#   MICE.REQ
#
    function # recrad
#       (radius::Float64,  # Ptr{SpiceDouble}
#        ra::Float64,  # Ptr{SpiceDouble}
#        dec::Float64) =   # Ptr{SpiceDouble}
        recrad(
            rectan::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(rectan) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        radius = Array{Float64}(1);  # Ptr{SpiceDouble}
        radius_ptr = pointer(radius)
        ra = Array{Float64}(1);  # Ptr{SpiceDouble}
        ra_ptr = pointer(ra)
        dec = Array{Float64}(1);  # Ptr{SpiceDouble}
        dec_ptr = pointer(dec)
        
#       make transposed copies of all input arrays and their pointers
        rectan_t = rectan'
        rectan_ptr = pointer(rectan_t)
        
#       ccall((:recrad_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),rectan,radius,ra,dec)
        ccall((:recrad_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            rectan_ptr,radius_ptr,ra_ptr,dec_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return radius[1], ra[1], dec[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Output the right ascension and declination of the earth's pole
#      % in the J2000 frame approximately every month for the time
#      % interval January 1, 1990 to January 1, 2010 (UTC).
#      %
#      %
#      % Load a standard kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define the time bounds for the time interval,
#      % 20 years,  convert to ephemeris time J2000.
#      %
#      utc_bounds = [ '1 Jan 1990'; '1 Jan 2010' ];
#      et_bounds = cspice_str2et( utc_bounds);
#
#      %
#      % Step in units of a month. 20 years ~ 240 months.
#      %
#      step = (et_bounds(2) - et_bounds(1)) / 240.;
#
#      %
#      % Create an array of 240 ephemeris times starting at
#      % et_bounds(1) in intervals of 'step'.
#      %
#      et = [0:239]*step + et_bounds(1);
#
#      %
#      % Set the conversion constant "radians to degrees."
#      %
#      r2d = cspice_dpr;
#
#      %
#      % Convert the 240-vector of 'et' to an array of corresponding
#      % transformation matrices (dimensions (3,3,240) ).
#      %
#      mat = cspice_pxform( 'IAU_EARTH', 'J2000', et);
#
#      %
#      % Extract the pole vector from the transformation matrix,
#      % convert to RA and DEC expressed in degrees.
#      %
#      % The last column in each matrix is the pole vector (z = (0,0,1))
#      % of the earth in IAU expressed in J2000. We need to copy the
#      % set of pole vectors to a 3xN array. Use reshape to do this.
#      %
#      pole = reshape( mat(:,3,:), 3,[] );
#
#      [radius, ra, dec] = recrad(pole);
#
#      ra  = ra * r2d;
#      dec = dec * r2d;
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ et; ra; dec ];
#      txt = sprintf( '%17.8f %12.6f %12.6f\n' , output  );
#      disp(txt)
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      A partial output centered on et = 0:
#
#                         ...
#
#     -18408539.52023917   180.003739    89.996751
#     -15778739.49107254   180.003205    89.997215
#     -13148939.46190590   180.002671    89.997679
#     -10519139.43273926   180.002137    89.998143
#     -7889339.40357262   180.001602    89.998608
#     -5259539.37440598   180.001068    89.999072
#     -2629739.34523934   180.000534    89.999536
#           60.68392730   360.000000    90.000000
#      2629860.71309394   359.999466    89.999536
#      5259660.74226063   359.998932    89.999072
#      7889460.77142727   359.998397    89.998607
#     10519260.80059391   359.997863    89.998143
#     13149060.82976055   359.997329    89.997679
#     15778860.85892719   359.996795    89.997215
#     18408660.88809383   359.996261    89.996751
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   ######   ####    ####   #####   #    #
#    #    #  #       #    #  #       #    #  #    #
#    #    #  #####   #        ####   #    #  ######
#    #####   #       #            #  #####   #    #
#    #   #   #       #    #  #    #  #       #    #
#    #    #  ######   ####    ####   #       #    #
#
#   rectangular to spherical coordinates
#
################################################################################
#-Abstract
#
#   recsph converts rectangular (Cartesian) coordinates to
#   spherical coordinates. All coordinates are expressed as
#   double precision values.
#
#-I/O
#
#   Given:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#   the call:
#
#      [r, colat, lon] = recsph(rectan)
#
#   returns:
#
#      r       a double precision scalar or double precision 1XN
#              array describing the distance of the position from origin
#
#      colat   a double precision scalar or double precision 1XN
#              array describing the angle between the point and the
#              positive z-axis, measured in radians (also referred to
#              as the polar angle)
#
#      lon     a double precision scalar or double precision 1XN array
#              describing the angle of the projection of the point to the XY
#              plane from the positive X-axis, measured in radians,
#              with range:
#
#                  -pi < lon <= pi
#
#              The positive Y-axis is at longitude PI/2 radians.
#
#              The argument 'r' returns with the same units associated
#              with 'rectan'.
#
#              'r', 'colat', and 'lon' return with the same vectorization
#              measure (N) as 'rectan'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine recsph_c.
#
#   MICE.REQ
#
    function # recsph
#       (r::Float64,  # Ptr{SpiceDouble}
#        colat::Float64,  # Ptr{SpiceDouble}
#        lon::Float64) =   # Ptr{SpiceDouble}
        recsph(
            rectan::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(rectan) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        r = Array{Float64}(1);  # Ptr{SpiceDouble}
        r_ptr = pointer(r)
        colat = Array{Float64}(1);  # Ptr{SpiceDouble}
        colat_ptr = pointer(colat)
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        
#       make transposed copies of all input arrays and their pointers
        rectan_t = rectan'
        rectan_ptr = pointer(rectan_t)
        
#       ccall((:recsph_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),rectan,r,colat,lon)
        ccall((:recsph_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            rectan_ptr,r_ptr,colat_ptr,lon_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r[1], colat[1], lon[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to spherical
#      % coordinates.
#      %
#      [r, colat, lon] = recsph(pos);
#
#      %
#      % Convert the spherical to rectangular.
#      %
#      [rectan] = cspice_sphrec(r, colat, lon);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#                     0  -0.03701547067225   0.63783453323816
#      0.02182376758148   0.01641520435413  -0.01531271963894
#     -0.01912147275010  -0.04855217028457   0.02039513446643
#
#   Example (2):
#
#      %
#      % Define eleven sets of rectangular coordinates.
#      %
#      rec = [ [ 0., 1., 0., 0., -1., 0., 0., 1., 1., 0., 1. ]; ...
#              [ 0., 0., 1., 0., 0., -1., 0., 1., 0., 1., 1. ]; ...
#              [ 0., 0., 0., 1., 0., 0., -1., 0., 1., 1., 1. ]    ];
#
#      %
#      % ...convert the rectangular coordinates to spherical coordinates
#      %
#      [r, colat, lon] = recsph(rec);
#
#      %
#      % Convert 'colat' and 'lon to degrees...
#      %
#      colat = colat * cspice_dpr;
#      lon   = lon   * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r        colat       lon          x         y           z   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; colat; lon; rec(1,:); rec(2,:); rec(3,:) ];
#      txt    = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', ...
#                        output );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r        colat       lon          x         y           z
#     --------   --------   --------   --------   --------   --------
#       0.0000     0.0000     0.0000     0.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000    90.0000     0.0000     1.0000     0.0000
#       1.0000     0.0000     0.0000     0.0000     0.0000     1.0000
#       1.0000    90.0000   180.0000    -1.0000     0.0000     0.0000
#       1.0000    90.0000   -90.0000     0.0000    -1.0000     0.0000
#       1.0000   180.0000     0.0000     0.0000     0.0000    -1.0000
#       1.4142    90.0000    45.0000     1.0000     1.0000     0.0000
#       1.4142    45.0000     0.0000     1.0000     0.0000     1.0000
#       1.4142    45.0000    90.0000     0.0000     1.0000     1.0000
#       1.7321    54.7356    45.0000     1.0000     1.0000     1.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####    #####    ##     #####  ######
#    #    #  #    #     #     #  #      #    #
#    #    #  #    #     #    #    #     #    #####
#    #####   #    #     #    ######     #    #
#    #   #   #    #     #    #    #     #    #
#    #    #   ####      #    #    #     #    ######
#
#   generate a rotation matrix
#
################################################################################
#-Abstract
#
#   rotate calculates the 3x3 rotation matrix generated
#   by a rotation of a specified angle about a specified axis.
#   This rotation operates as a rotation of the coordinate
#   system.
#
#-I/O
#
#   Given:
#
#      angle  the double precision scalar or 1XN-vector of rotation
#             angles measured in radians
#
#      iaxis   the integer ID of the axis of rotation where
#              X=1, Y=2, Z=3
#
#   the call:
#
#      mout = rotate( angle, iaxis)
#
#   returns:
#
#      mout   a double precision 3x3 or 3x3xN array of rotation matrices
#             that describe a rotation of 'angle' radians about 'iaxis'
#
#             'mout' return with the same vectorization measure
#             (N) as 'angle'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine rotate_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # rotate
#       (mout::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        rotate(
            angle::Float64, # SpiceDouble
            iaxis::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        mout = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        mout_ptr = pointer(mout)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:rotate_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceInt,Array_3_Array_3_SpiceDouble),angle,iaxis,mout)
        ccall((:rotate_c,libNasaSpice),Void,
            (Float64,Int32,Ptr{Float64}),
            angle,iaxis,mout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return mout'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % A Pi/10 rotation about the Z axis.
#      %
#      rot_mat = rotate( 0.1*cspice_pi, 3 )
#
#      %
#      % Apply the coordinate rotation to a vector.
#      %
#      vec = [ 1.2; 3.4; 4.5 ];
#
#      vec1 = rot_mat * vec
#
#   MATLAB outputs:
#
#      rot_mat =
#
#          0.9511    0.3090         0
#         -0.3090    0.9511         0
#               0         0    1.0000
#
#      vec1 =
#
#          2.1919
#          2.8628
#          4.5000
#
#-Version
#
#    -Mice Version 1.0.0, 10-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####    ####    #####  #    #    ##     #####
#    #    #  #    #     #    ##  ##   #  #      #
#    #    #  #    #     #    # ## #  #    #     #
#    #####   #    #     #    #    #  ######     #
#    #   #   #    #     #    #    #  #    #     #
#    #    #   ####      #    #    #  #    #     #
#
#   rotate a matrix
#
################################################################################
#-Abstract
#
#   rotmat calculates the 3x3 rotation matrix generated by
#   a rotation of a specified angle about a specified axis applied
#   to a matrix. This rotation is thought of as rotating the
#   coordinate system.
#
#-I/O
#
#   Given:
#
#      m1      the double precision 3x3 array on which to apply the rotation.
#              In matrix algebra, the components of the matrix are
#              relative to one particular coordinate system. Applying
#              rotmat changes the components of 'm1' so that they are
#              relative to a rotated coordinate system.
#
#      angle   the double precision scalar angle in radians through which
#              to rotate the original coordinate system
#
#      iaxis   the scalar integer index for the axis of the original
#              coordinate system about which to perform the rotation by
#              'angle'. iaxis = 1,2 or 3 respectively designates the
#              x-, y-, or z-axis.
#
#   the call:
#
#      mout = rotmat( m1, angle, iaxis)
#
#   returns:
#
#      mout    a double precision 3x3 array resulting from the application of
#              'angle' to the input matrix 'm1'.  If
#
#                 [angle]
#                       iaxis
#
#              denotes the rotation matrix by 'angle' radians about 'iaxis',
#              (see the Rotations Required Reading document) then 'mout' is
#              given by the following matrix equation:
#
#                 mout = [angle]      * m1
#                               iaxis
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine rotmat_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # rotmat
#       (mout::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        rotmat(
            m1::Array{Float64,2}, # Array_3_Array_3_ConstSpiceDouble
            angle::Float64, # SpiceDouble
            iaxis::Int32) # SpiceInt
        
#       enforce input array sizes
        if size(m1) != (3,3)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        mout = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        mout_ptr = pointer(mout)
        
#       make transposed copies of all input arrays and their pointers
        m1_t = m1'
        m1_ptr = pointer(m1_t)
        
#       ccall((:rotmat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_Array_3_ConstSpiceDouble,SpiceDouble,SpiceInt,Array_3_Array_3_SpiceDouble),m1,angle,iaxis,mout)
        ccall((:rotmat_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Int32,Ptr{Float64}),
            m1_ptr,angle,iaxis,mout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return mout'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Rotate the 3x3 identity matrix by 90 degrees about
#      % the y axis.
#      %
#
#      %
#      % Create the 3x3 identity matrix.
#      %
#      ident = eye(3);
#
#      %
#      % Rotate 'ident' by Pi/2 about the Y axis.
#      %
#      r = rotmat( ident, cspice_halfpi, 2 )
#
#   MATLAB outputs:
#
#      r =
#
#          0.0000         0   -1.0000
#               0    1.0000         0
#          1.0000         0    0.0000
#
#-Version
#
#   -Mice Version 1.1.0, 24-JAN-2009, EDW (JPL)
#
#      Corrected the function definition name. This wrapper had a
#      the function name "cspice_rotate" instead of "rotmat."
#
#
#   -Mice Version 1.0.0, 17-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #####   #####   #####
#    #    #  #    #  #    #
#    #    #  #    #  #    #
#    #####   #####   #    #
#    #   #   #       #    #
#    #    #  #       #####
#
#   radians per degree
#
################################################################################
#-Abstract
#
#   rpd returns the value of the constant pi/180 which represents  
#   the number of radians per degree of arc.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      rpd = rpd
#
#   returns:
#
#      rpd   the number of radians per degree: pi/180.
#
#            [1,1] = size(rpd); double = class(rpd)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine rpd_c.
#
#   MICE.REQ
#
    function # rpd
        rpd()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:rpd_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:rpd_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####     ##    ######  #        ####   #    #
#    #        #  #   #       #       #    #  #    #
#     ####   #    #  #####   #       #       #    #
#         #  ######  #       #       #  ###  #    #
#    #    #  #    #  #       #       #    #   #  #
#     ####   #    #  ######  ######   ####     ##
#
#   semi-axes of ellipse from generating vectors
#
################################################################################
#-Abstract
#
#   saelgv calculates the semi-axis vectors of an ellipse generated
#   by two arbitrary three-dimensional vectors.
#
#-I/O
#
#   Given:
#
#      vec1 &
#      vec2     the two double precision 3x1 arrays defining an ellipse
#               (the generating vectors). The ellipse is the set of points
#
#                  center  +  cos(theta) vec1  +  sin(theta) vec2
#
#               where theta ranges over the interval (-pi, pi] and
#               center is an arbitrary point at which the ellipse
#               is centered.  An ellipse's semi-axes are
#               independent of its center, so the vector center
#               shown above is not an input to this routine.
#
#               'vec1' and 'vec2' need not be linearly independent;
#               degenerate input ellipses are allowed.
#
#   the call:
#
#      [ smajor, sminor ] = saelgv( vec1, vec2 )
#
#   returns:
#
#      smajor     double precision 3x1 array defining the semi-major
#                 axis of the ellipse
#
#      sminor     double precision 3x1 array defining the semi-minor
#                 axis of the ellipse
#
#-Particulars
#
#   We note here that two linearly independent but not necessarily
#   orthogonal vectors vec1 and vec2 can define an ellipse
#   centered at the origin:  the ellipse is the set of points in
#   3-space
#
#      center  +  cos(theta) vec1  +  sin(theta) vec2
#
#   where theta is in the interval (-pi, pi] and center is an
#   arbitrary point at which the ellipse is centered.
#
#   This routine finds vectors that constitute semi-axes of an
#   ellipse that is defined, except for the location of its center,
#   by vec1 and vec2.  The semi-major axis is a vector of largest
#   possible magnitude in the set
#
#      cos(theta) vec1  +  sin(theta) vec2
#
#   There are two such vectors; they are additive inverses of each
#   other. The semi-minor axis is an analogous vector of smallest
#   possible magnitude.  The semi-major and semi-minor axes are
#   orthogonal to each other. If smajor and sminor are choices of
#   semi-major and semi-minor axes, then the input ellipse can also
#   be represented as the set of points
#
#      center  +  cos(theta) smajor  +  sin(theta) sminor
#
#   where theta is in the interval (-pi, pi].
#
#   The capability of finding the axes of an ellipse is useful in
#   finding the image of an ellipse under a linear transformation.
#   Finding this image is useful for determining the orthogonal and
#   gnomonic projections of an ellipse, and also for finding the limb
#   and terminator of an ellipsoidal body.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine saelgv_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # saelgv
#       (smajor::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        sminor::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        saelgv(
            vec1::Array{Float64,1}, # Array_3_ConstSpiceDouble
            vec2::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(vec1) != 3
            error("Incorrect size for parameter 1")
        end
        if length(vec2) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        smajor = Array{Float64,1}(3);  # Array_3_SpiceDouble
        smajor_ptr = pointer(smajor)
        sminor = Array{Float64,1}(3);  # Array_3_SpiceDouble
        sminor_ptr = pointer(sminor)
        
#       make transposed copies of all input arrays and their pointers
        vec1_t = vec1'
        vec1_ptr = pointer(vec1_t)
        vec2_t = vec2'
        vec2_ptr = pointer(vec2_t)
        
#       ccall((:saelgv_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Array_3_SpiceDouble),vec1,vec2,smajor,sminor)
        ccall((:saelgv_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            vec1_ptr,vec2_ptr,smajor_ptr,sminor_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return smajor, sminor
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define two arbitrary, linearly independent, vectors.
#      %
#      vec1 = [ 1;  1; 1 ];
#      vec2 = [ 1; -1; 1 ];
#
#      %
#      % Calculate the semi-major and semi-minor axes of an
#      % ellipse generated by the two vector.
#      %
#      [ smajor, sminor] = saelgv( vec1, vec2 )
#
#   MATLAB outputs:
#
#      smajor =
#
#          1.4142
#         -0.0000
#          1.4142
#
#      sminor =
#
#          0.0000
#          1.4142
#          0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 07-MAY-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#     ####    ####   ###### #     #   ####
#    #       #    #  #            #  #    #
#     ####   #       #####   #####   #
#         #  #       #      #        #
#    #    #  #    #  #      #        #    #
#     ####    ####   ###### #######   ####
#
#   ephemeris time to continuous spacecraft_clock ticks
#
################################################################################
#-Abstract
#
#   sce2c converts ephemeris seconds past J2000 (ET) to
#   continuous encoded spacecraft clock ("ticks").  Non-integral
#   tick values may be returned.
#
#-I/O
#
#   Given:
#
#      sc   the scalar integer NAIF ID of the spacecraft clock whose
#           encoded SCLK value at the epoch 'et' is desired
#
#      et   the scalar or N-vector of double precision epochs,
#           specified as ephemeris seconds past J2000
#
#   the call:
#
#      sclkdp = sce2c( sc, et )
#
#   returns:
#
#      sclkdp   the double precision scalar or double precision 1xN array
#               of encoded SCLK value(s) corresponding to 'et' for 'sc'
#
#               'sclkdp' returns with the same vectorization
#                measure (N) as 'et'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sce2c_c.
#
#   MICE.REQ
#   SCLK.REQ
#   TIME.REQ
#
    function # sce2c
#       (sclkdp::Float64) =   # Ptr{SpiceDouble}
        sce2c(
            sc::Int32, # SpiceInt
            et::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        sclkdp = Array{Float64}(1);  # Ptr{SpiceDouble}
        sclkdp_ptr = pointer(sclkdp)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sce2c_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceDouble,Ptr{SpiceDouble}),sc,et,sclkdp)
        ccall((:sce2c_c,libNasaSpice),Void,
            (Int32,Float64,Ptr{Float64}),
            sc,et,sclkdp_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return sclkdp[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the leapseconds kernel for time conversion.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Assign values for the spacecraft ID (Voyager2),
#      % and SCLK kernel.
#      %
#      SC         = -32;
#      SCLK       = '/kernels/voyager2/sclk/vg200004.tsc';
#      event_time = '1979 JUL 05 21:50:21.23379';
#
#      %
#      % Load the SCLK file.
#      %
#      cspice_furnsh( SCLK )
#
#      %
#      % Convert the time string to ephemeris time.
#      %
#      et = cspice_str2et( event_time );
#
#      %
#      % Convert the ephemeris time to the encoded SCLK
#      % format.
#      %
#      sclkdp = sce2c( SC, et );
#      txt    = sprintf( ' %16.6f', sclkdp );
#      disp( txt )
#
#      %
#      % Vectorized use, a vector of UTC times.
#      %
#      event_time =  strvcat( '1979 JUL 05 22:50:21.23379', ...
#                             '1979 JUL 05 23:50:21.23379', ...
#                             '1979 JUL 06 00:50:21.23379' );
#
#      %
#      % Convert the time strings to ET.
#      %
#      et = cspice_str2et( event_time );
#
#      %
#      % Convert the 'et' array to the encoded
#      % spacecraft clock.
#      %
#      sclkdp = sce2c( SC, et );
#
#      for i=1:3
#         txt = sprintf( ' %16.6f', sclkdp(i) );
#         disp( txt )
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#       985327949.999971
#
#      Vector:
#       985387950.043701
#       985447950.087433
#       985507950.131163
#
#-Version
#
#   -Mice Version 1.0.0, 18-APR-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    ####   ######  #    #   ####   #####
#    #       #    #  #       ##   #  #    #  #    #
#     ####   #       #####   # #  #  #       #    #
#         #  #       #       #  # #  #       #    #
#    #    #  #    #  #       #   ##  #    #  #    #
#     ####    ####   ######  #    #   ####   #####
#
#   encode spacecraft_clock
#
################################################################################
#-Abstract
#
#   scencd encodes a character representation of spacecraft
#   clock time to the corresponding double precision number.
#
#-I/O
#
#   Given:
#
#      sc       the scalar integer NAIF ID of the spacecraft clock
#               whose time is being encoded
#
#      sclkch   the scalar string or NXM character array representation
#               of spacecraft 'sc' clock count
#
#   the call:
#
#      sclkdp = scencd( sc, sclkch )
#
#   returns:
#
#      sclkdp   the double precision scalar or double precision 1xN array
#               encoding(s) of 'sclkch' for 'sc'
#
#               'sclkdp' returns with the same vectorization measure (N)
#                as 'sclkch'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine scencd_c.
#
#   MICE.REQ
#   SCLK.REQ
#
    function # scencd
#       (sclkdp::Float64) =   # Ptr{SpiceDouble}
        scencd(
            sc::Int32, # SpiceInt
            sclkch::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        sclkdp = Array{Float64}(1);  # Ptr{SpiceDouble}
        sclkdp_ptr = pointer(sclkdp)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:scencd_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,Ptr{ConstSpiceChar},Ptr{SpiceDouble}),sc,sclkch,sclkdp)
        ccall((:scencd_c,libNasaSpice),Void,
            (Int32,Ptr{UInt8},Ptr{Float64}),
            sc,sclkch,sclkdp_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return sclkdp[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Assign values for the spacecraft ID (Voyager2),
#      % the SCLK kernel, and a double precision
#      % encodings of SCLK strings
#      %
#      SC     = -32;
#      SCLK   = '/kernels/voyager2/sclk/vg200004.tsc';
#      timein = 985327950.0;
#
#      %
#      % Load the kernel files.
#      %
#      cspice_furnsh( SCLK )
#
#      %
#      % Convert the Voyager encoded SCLK to an
#      % SCLK string.
#      %
#      sclkch = cspice_scdecd( SC, timein );
#
#      %
#      % Convert the SCLK string to double precision form.
#      % The output value should match the original.
#      %
#      sclkdp = scencd( SC, sclkch );
#
#      disp( 'Scalar:' )
#
#      txt = sprintf( 'Original: %20.8f', timein );
#      disp( txt )
#
#      txt = sprintf( ['SCLKCH  : ' sclkch] );
#      disp( txt )
#
#      txt = sprintf( 'Decoded : %20.8f', sclkdp );
#      disp( txt )
#
#      disp( ' ' )
#
#      %
#      % Convert a vector of SCLK values.
#      %
#      timein = [ 985327950.0, ...
#                 985553550.0, ...
#                 985901583.0, ...
#                 986447183.0, ...
#                 9136032015.0 ];
#
#      %
#      % Convert the SCLK double precision values to the string
#      % representation, then convert to the dp form. As before, the
#      % output value should match the original.
#      %
#      sclkch = cspice_scdecd( SC, timein );
#      sclkdp = scencd( SC, sclkch );
#
#      disp( 'Vector:' )
#      for i=1:5
#
#         txt = sprintf( 'Original: %20.8f', timein(i) );
#         disp( txt )
#
#         txt = sprintf( ['SCLKCH  : ' sclkch(i,:) ] );
#         disp( txt )
#
#         txt = sprintf( 'Decoded : %20.8f', sclkdp(i) );
#         disp( txt )
#
#         disp( ' ' )
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#      Original:   985327950.00000000
#      SCLKCH  : 2/20538:39:768
#      Decoded :   985327950.00000000
#
#      Vector:
#      Original:   985327950.00000000
#      SCLKCH  : 2/20538:39:768
#      Decoded :   985327950.00000000
#
#      Original:   985553550.00000000
#      SCLKCH  : 2/20543:21:768
#      Decoded :   985553550.00000000
#
#      Original:   985901583.00000000
#      SCLKCH  : 2/20550:37:001
#      Decoded :   985901583.00000000
#
#      Original:   986447183.00000000
#      SCLKCH  : 2/20561:59:001
#      Decoded :   986447183.00000000
#
#      Original:  9136032015.00000000
#      SCLKCH  : 5/04563:00:001
#      Decoded :  9136032015.00000000
#
#-Version
#
#   -Mice Version 1.0.0, 18-APR-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#     ####    ####    ####  #     #  ######
#    #       #    #  #            #  #
#     ####   #        ####   #####   #####
#         #  #            # #        #
#    #    #  #    #  #    # #        #
#     ####    ####    ####  #######  ######
#
#   spacecraft_clock string to ephemeris time
#
################################################################################
#-Abstract
#
#   scs2e converts a spacecraft clock string to ephemeris
#   seconds past J2000 (ET).
#
#-I/O
#
#   Given:
#
#      sc       the scalar integer NAIF ID of the spacecraft clock
#               whose clock value is represented by 'sclkch'
#
#      sclkch   the scalar string or NXM character array representation
#               of spacecraft 'sc' clock count ('sclkch' is an absolute
#               spacecraft clock time, so the string should include
#               partition information)
#
#   the call:
#
#      et = scs2e( sc, sclkch )
#
#   returns:
#
#      et    the double precision scalar or double precision 1xN array
#            in ephemeris seconds past J2000, that corresponds to 'sclkch'
#
#            'et' returns with the same vectorization measure
#             (N) as 'sclkch'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine scs2e_c.
#
#   MICE.REQ
#   SCLK.REQ
#
    function # scs2e
#       (et::Float64) =   # Ptr{SpiceDouble}
        scs2e(
            sc::Int32, # SpiceInt
            sclkch::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        et = Array{Float64}(1);  # Ptr{SpiceDouble}
        et_ptr = pointer(et)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:scs2e_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,Ptr{ConstSpiceChar},Ptr{SpiceDouble}),sc,sclkch,et)
        ccall((:scs2e_c,libNasaSpice),Void,
            (Int32,Ptr{UInt8},Ptr{Float64}),
            sc,sclkch,et_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return et[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the leapseconds kernel for time conversion.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Assign values for the spacecraft ID (Voyager2),
#      % and SCLK kernel.
#      %
#      SC     = -32;
#      SCLK   = '/kernels/voyager2/sclk/vg200004.tsc';
#      sclkch = '2/20538:39:768';
#
#      %
#      % Load the SCLK kernel.
#      %
#      cspice_furnsh( SCLK )
#
#      %
#      % Convert 'sclkch' for spacecraft 'SC' to ephemeris time.
#      %
#      et = scs2e( SC, sclkch );
#
#      %
#      % Convert the ephemeris time to a UTC calendar string.
#      %
#      utc = cspice_et2utc( et, 'C', 3 );
#
#      disp( 'Scalar:' )
#      txt = sprintf( 'Original:  %s', sclkch );
#      disp( txt )
#
#      txt = sprintf( 'ET      : %20.8f',  et );
#      disp( txt )
#
#      txt = sprintf( 'UTC     : %s', utc );
#      disp( txt )
#
#      disp (' ')
#
#      %
#      % Convert a vector of SCLK strings to ET and
#      % UTC.
#      %
#      sclkch =  strvcat( '2/20538:39:768' , ...
#                         '2/20543:21:768' , ...
#                         '2/20550:37'     , ...
#                         '2/20561:59'     , ...
#                         '5/04563:00:001'  );
#
#      et  = scs2e( SC, sclkch );
#      utc = cspice_et2utc( et, 'C', 3 );
#
#      disp( 'Vector:' )
#      for i=1:5
#
#         txt = sprintf( 'Original:  %s', sclkch(i,:) );
#         disp( txt )
#
#         txt = sprintf( 'ET      : %20.8f',  et(i) );
#         disp( txt )
#
#         txt = sprintf( 'UTC     : %s', utc(i,:) );
#         disp( txt )
#
#         disp (' ')
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#      Original:  2/20538:39:768
#      ET      :  -646668528.58222842
#      UTC     : 1979 JUL 05 21:50:21.234
#
#      Vector:
#      Original:  2/20538:39:768
#      ET      :  -646668528.58222842
#      UTC     : 1979 JUL 05 21:50:21.234
#
#      Original:  2/20543:21:768
#      ET      :  -646654992.59209847
#      UTC     : 1979 JUL 06 01:35:57.224
#
#      Original:  2/20550:37
#      ET      :  -646634110.62732494
#      UTC     : 1979 JUL 06 07:23:59.189
#
#      Original:  2/20561:59
#      ET      :  -646601374.65119493
#      UTC     : 1979 JUL 06 16:29:35.165
#
#      Original:  5/04563:00:001
#      ET      :  -157626068.50102001
#      UTC     : 1995 JAN 03 02:57:50.315
#
#-Version
#
#   -Mice Version 1.0.0, 18-APR-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#     ####    ####    ##### #     #  ######
#    #       #    #     #         #  #
#     ####   #          #    #####   #####
#         #  #          #   #        #
#    #    #  #    #     #   #        #
#     ####    ####      #   #######  ######
#
#   spacecraft_clock ticks to ephemeris time
#
################################################################################
#-Abstract
#
#   sct2e converts encoded spacecraft clock (`ticks')
#   to ephemeris seconds past J2000 (ET).
#
#-I/O
#
#   Given:
#
#      sc       the NAIF ID of the spacecraft clock, whose encoded
#               clock value is represented by 'sclkdp'.
#
#               [1,1] = size(sc); int32 = class(sc)
#
#                 or
#
#               [1,1] = size(sc); double = class(sc)
#
#      sclkdp   the encoding of a clock time(s) in units of ticks since the
#               spacecraft clock start time.
#
#               [1,n] = size(sclkdp); double = class(sclkdp)
#
#   the call:
#
#      et = sct2e( sc, sclkdp )
#
#   returns:
#
#      et    the epoch in ephemeris seconds past J2000, that corresponds 
#            to 'sclkdp'.
#
#            'et' returns with the same vectorization measure (N)
#            as 'sclkdp'.
#
#            [1,n] = size(et); double = class(et)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sct2e_c.
#
#   MICE.REQ
#   SCLK.REQ
#   TIME.REQ
#
    function # sct2e
#       (et::Float64) =   # Ptr{SpiceDouble}
        sct2e(
            sc::Int32, # SpiceInt
            sclkdp::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        et = Array{Float64}(1);  # Ptr{SpiceDouble}
        et_ptr = pointer(et)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sct2e_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceDouble,Ptr{SpiceDouble}),sc,sclkdp,et)
        ccall((:sct2e_c,libNasaSpice),Void,
            (Int32,Float64,Ptr{Float64}),
            sc,sclkdp,et_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return et[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load the leapseconds kernel for time conversion.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Assign values for the spacecraft ID (Voyager2),
#      % SCLK kernel.
#      %
#      SC     = -32;
#      SCLK   = '/kernels/voyager2/sclk/vg200004.tsc';
#      sclkdp = 985327965.0;
#
#      %
#      % Load the SCLK kernel.
#      %
#      cspice_furnsh( SCLK )
#
#      %
#      % Convert 'sclkdp' for spacecraft 'SC' to ephemeris time.
#      %
#      et = sct2e( SC, sclkdp );
#
#      %
#      % Convert the ephemeris time to a UTC calendar string.
#      %
#      utc = cspice_et2utc( et, 'C', 3 );
#
#      disp( 'Scalar:' )
#      txt = sprintf( 'SCLKDP: %16.6f', sclkdp );
#      disp( txt )
#
#      txt = sprintf( 'ET    : %16.6f', et );
#      disp( txt )
#
#      txt = sprintf( 'UTC   : %s', utc );
#      disp( txt )
#
#      disp(' ')
#
#      %
#      % Convert a vector of SCLK values.
#      %
#      sclkdp = [ 985327950.0, ...
#                 985553550.0, ...
#                 985901583.0, ...
#                 986447183.0, ...
#                 9136032015.0 ];
#
#      %
#      % Convert the 'sclkdp' vector  for spacecraft 'SC' to
#      % ephemeris time.
#      %
#      et = sct2e( SC, sclkdp );
#
#      %
#      % Convert the ephemeris time vector to a UTC calendar
#      % strings then output.
#      %
#      utc = cspice_et2utc( et, 'C', 3 );
#
#      disp( 'Vector:' )
#      for i=1:5
#         txt = sprintf( 'SCLKDP: %16.6f', sclkdp(i) );
#         disp( txt )
#
#         txt = sprintf( 'ET    : %16.6f', et(i) );
#         disp( txt )
#
#         txt = sprintf( 'UTC   : %s', utc(i,:) );
#         disp( txt )
#
#         disp(' ')
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar:
#      SCLKDP: 985327965.000000
#      ET    : -646668527.682229
#      UTC   : 1979 JUL 05 21:50:22.134
#
#      Vector:
#      SCLKDP: 985327950.000000
#      ET    : -646668528.582228
#      UTC   : 1979 JUL 05 21:50:21.234
#
#      SCLKDP: 985553550.000000
#      ET    : -646654992.592098
#      UTC   : 1979 JUL 06 01:35:57.224
#
#      SCLKDP: 985901583.000000
#      ET    : -646634110.627325
#      UTC   : 1979 JUL 06 07:23:59.189
#
#      SCLKDP: 986447183.000000
#      ET    : -646601374.651195
#      UTC   : 1979 JUL 06 16:29:35.165
#
#      SCLKDP: 9136032015.000000
#      ET    : -157626068.501020
#      UTC   : 1995 JAN 03 02:57:50.315
#
#-Version
#
#   -Mice Version 1.0.1, 04-SEP-2012, EDW (JPL)
#
#      Edit to call example in I/O to correct form.
#
#   -Mice Version 1.0.0, 18-APR-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####    ####    #####     #    #    #   ####
#    #       #    #     #       #    #   #   #
#     ####   #          #       #    ####     ####
#         #  #          #       #    #  #         #
#    #    #  #    #     #       #    #   #   #    #
#     ####    ####      #       #    #    #   ####
#
#   convert spacecraft_clock string to ticks
#
################################################################################
#-Abstract
#
#   sctiks convert a spacecraft clock format string to
#   number of 'ticks'.
#
#-I/O
#
#   Given:
#
#      sc       the scalar integer NAIF ID of the spacecraft clock
#               whose time is being encoded
#
#      clkstr   the scalar string or N-vector representation of the
#               'sc' spacecraft's clock time, WITHOUT PARTITION NUMBER
#
#   the call:
#
#      ticks = sctiks( sc, clkstr )
#
#   returns:
#
#      ticks   the double precision scalar or N-vector number of ticks
#              represented by the spacecraft clock string 'clkstr'
#
#              'ticks' returns with the same vectorization measure (N)
#               as 'clkstr'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sctiks_c.
#
#   MICE.REQ
#   SCLK.REQ
#
    function # sctiks
#       (ticks::Float64) =   # Ptr{SpiceDouble}
        sctiks(
            sc::Int32, # SpiceInt
            clkstr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        ticks = Array{Float64}(1);  # Ptr{SpiceDouble}
        ticks_ptr = pointer(ticks)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sctiks_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,Ptr{ConstSpiceChar},Ptr{SpiceDouble}),sc,clkstr,ticks)
        ccall((:sctiks_c,libNasaSpice),Void,
            (Int32,Ptr{UInt8},Ptr{Float64}),
            sc,clkstr,ticks_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return ticks[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#   MATLAB outputs:
#
#
#-Version
#
#   -Mice Version 1.0.0, 07-JUN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####      #    #    #   ####   #####    #####
#    #          #    ##   #  #    #  #    #     #
#     ####      #    # #  #  #       #    #     #
#         #     #    #  # #  #       #####      #
#    #    #     #    #   ##  #    #  #          #
#     ####      #    #    #   ####   #          #
#
#   find surface intercept point
#   find intersection of ray and target body surface
#   find intercept of ray on target body surface
#
################################################################################
#-Abstract
#
#   sincpt computes the surface intercept of the ray on a target
#   body at a specified epoch, optionally corrected for light time and stellar
#   aberration, given an observer and a direction vector defining a ray,
#
#   This routine supersedes cspice_srfxpt, which does not have an input
#   argument for the target body-fixed frame name.
#
#-I/O
#
#   Given:
#
#      method   a scalar string providing parameters defining
#               the computation method to be used. Parameters
#               include, but are not limited to, the shape model
#               used to represent the surface of the target body.
#
#               The only choice currently supported is
#
#                  "Ellipsoid"        The intercept computation uses
#                                     a triaxial ellipsoid to model
#                                     the surface of the target body.
#                                     The ellipsoid's radii must be
#                                     available in the kernel pool.
#
#               Neither case nor white space are significant in
#               'method'. For example, the string ' eLLipsoid ' is
#               valid.
#
#      target   the scalar string name of the target body. 'target' is
#               case-insensitive, and leading and trailing blanks in
#               'target' are not significant. Optionally, you may
#               supply a string containing the integer ID code
#               for the object. For example both "MOON" and "301"
#               are legitimate strings that indicate the moon is the
#               target body.
#
#
#      et       the double precision scalar epoch of participation of
#               the observer, expressed as ephemeris seconds past J2000
#               TDB: 'et' is the epoch at which the observer's state
#               is computed.
#
#               When aberration corrections are not used, 'et' is also
#               the epoch at which the position and orientation of the
#               target body are computed.
#
#               When aberration corrections are used, 'et' is the epoch
#               at which the observer's state relative to the solar
#               system barycenter is computed; in this case the
#               position and orientation of the target body are
#               computed at et-lt or et+lt, where 'lt' is the one-way
#               light time between the intercept point and the
#               observer, and the sign applied to 'lt' depends on the
#               selected correction. See the description of 'abcorr'
#               below for details.
#
#      fixref   the scalar string name of the body-fixed, body-centered
#               reference frame associated with the target body. The
#               output intercept point 'spoint' and observer to
#               intercept vector 'srfvec' expressed relative to
#               this reference frame.
#
#      abcorr   the scalar string aberration correction to be applied
#               when computing the observer-target state and the
#               orientation of the target body. 'abcorr' may be any of
#               the following.
#
#                  "NONE"     Apply no correction. Return the
#                             geometric surface intercept point on the
#                             target body.
#
#               Let 'lt' represent the one-way light time between the
#               observer and the surface intercept point (note: NOT
#               between the observer and the target body's center).
#               The following values of 'abcorr' apply to the
#               "reception" case in which photons depart from the
#               intercept point's location at the light-time
#               corrected epoch et-lt and *arrive* at the observer's
#               location at 'et':
#
#                  "LT"       Correct for one-way light time (also
#                             called "planetary aberration") using a
#                             Newtonian formulation. This correction
#                             yields the location of the surface
#                             intercept point at the moment it
#                             emitted photons arriving at the
#                             observer at 'et'.
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             "LT" option uses one iteration.
#
#                             Both the target state as seen by the
#                             observer, and rotation of the target
#                             body, are corrected for light time.
#
#                  "LT+S"     Correct for one-way light time and
#                             stellar aberration using a Newtonian
#                             formulation. This option modifies the
#                             state obtained with the "LT" option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The result is the apparent
#                             surface intercept point as seen by the
#                             observer.
#
#                  "CN"       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the "CN" correction iterates
#                             until the solution converges. Both the
#                             state and rotation of the target body
#                             are corrected for light time.
#
#                  "CN+S"     Converged Newtonian light time
#                             and stellar aberration corrections.
#
#               The following values of 'abcorr' apply to the
#               "transmission" case in which photons *depart* from
#               the observer's location at 'et' and arrive at the
#               intercept point at the light-time corrected epoch
#               ET+LT:
#
#                  "XLT"      "Transmission" case: correct for
#                             one-way light time using a Newtonian
#                             formulation. This correction yields the
#                             intercept location at the moment it
#                             receives photons emitted from the
#                             observer's location at 'et'.
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             "LT" option uses one iteration.
#
#                             Both the target state as seen by the
#                             observer, and rotation of the target
#                             body, are corrected for light time.
#
#                  "XLT+S"    "Transmission" case: correct for
#                             one-way light time and stellar
#                             aberration using a Newtonian
#                             formulation  This option modifies the
#                             intercept obtained with the "XLT"
#                             option to account for the observer's
#                             velocity relative to the solar system
#                             barycenter.
#
#                  "XCN"      Converged Newtonian light time
#                             correction. This is the same as XLT
#                             correction but with further iterations
#                             to a converged Newtonian light time
#                             solution.
#
#                  "XCN+S"    "Transmission" case: converged
#                             Newtonian light time and stellar
#                             aberration corrections.
#
#               Case and embedded blanks are not significant in 'abcorr'.
#
#      obsrvr   the scalar string name of the observing body. This is
#               typically a spacecraft, the earth, or a surface point on
#               the earth. 'obsrvr' is case-insensitive, and leading and
#               trailing blanks in 'obsrvr' are not significant.
#               Optionally, you may supply a string containing the
#               integer ID code for the object. For example both
#               "MOON" and "301" are legitimate strings that indicate
#               the moon is the observer.
#
#      dref     the scalar string name of the reference frame relative to
#               which the input direction vector is expressed. This may be
#               any frame supported by the SPICE system, including
#               built-in frames (documented in the Frames Required
#               Reading) and frames defined by a loaded frame kernel
#               (FK).
#
#               When 'dref' designates a non-inertial frame, the
#               orientation of the frame is evaluated at an epoch
#               dependent on the frame's center and, if the center is
#               not the observer, on the selected aberration
#               correction. See the description of the direction
#               vector 'dvec' for details.
#
#      dvec     the double precision 3x1 array defining the pointing
#               vector emanating from the observer. The intercept
#               with the target body's surface of the ray
#               defined by the observer and 'dvec' is sought.
#
#               'dvec' is specified relative to the reference frame
#               designated by 'dref'.
#
#               Non-inertial reference frames are treated as follows:
#               if the center of the frame is at the observer's
#               location, the frame is evaluated at 'et'. If the
#               frame's center is located elsewhere, then letting
#               'ltcent' be the one-way light time between the observer
#               and the central body associated with the frame, the
#               orientation of the frame is evaluated at et-ltcent,
#               et+ltcent, or 'et' depending on whether the requested
#               aberration correction is, respectively, for received
#               radiation, transmitted radiation, or is omitted.
#               'ltcent' is computed using the method indicated by
#               'abcorr'.
#
#   the call:
#
#      [ spoint, trgepc, srfvec, found] = sincpt( method, target, ...
#                                                        et,     fixref, ...
#                                                        abcorr, obsrvr, ...
#                                                        dref,   dvec)
#
#   returns:
#
#      spoint   double precision 3x1 array defining surface intercept
#               point on the target body of the ray defined by the observer
#               and the direction vector. If the ray intersects the target
#               body in multiple points, the selected intersection point is
#               the one closest to the observer. The output argument
#               'found' (see below) indicates whether an intercept was
#               found.
#
#               'spoint' is expressed in Cartesian coordinates,
#               relative to the target body-fixed frame designated by
#               FIXFRM. The body-fixed target frame is evaluated at
#               the intercept epoch 'trgepc' (see description below).
#
#               When light time correction is used, the duration of
#               light travel between 'spoint' to the observer is
#               considered to be the one way light time. When both
#               light time and stellar aberration corrections are
#               used, 'spoint' is selected such that, when 'spoint' is
#               corrected for light time and the vector from the
#               observer to the light-time corrected location of
#               'spoint' is corrected for stellar aberration, the
#               resulting vector is parallel to the ray defined by
#               the observer's location and 'dvec'.
#
#               The components of 'spoint' are given in units of km.
#
#      trgepc   the scalar double precision "intercept epoch."  This is the
#               epoch at which the ray defined by 'obsrvr' and 'dvec'
#               intercepts the target surface at 'spoint'. 'trgepc' is defined
#               as follows: letting 'lt' be the one-way light time between
#               the observer and the intercept point, 'trgepc' is the
#               epoch et-lt, et+lt, or 'et' depending on whether the
#               requested aberration correction is, respectively, for
#               received radiation, transmitted radiation, or
#               omitted. 'lt' is computed using the method indicated by
#               'abcorr'.
#
#               'trgepc' is expressed as seconds past J2000 TDB.
#
#      srfvec   a double precision 3x1 array defining the vector
#               from the observer's position at 'et' to
#               'spoint'. 'srfvec' is expressed in the target body-fixed
#               reference frame designated by 'fixref', evaluated at
#               'trgepc'.
#
#               The components of 'srfvec' are given in units of km.
#
#               One can use the CSPICE function vnorm_c to obtain the
#               distance between the observer and 'spoint':
#
#                  dist = norm( srfvec )
#
#               The observer's position 'obspos', relative to the
#               target body's center, where the center's position is
#               corrected for aberration effects as indicated by
#               'abcorr', can be computed via the call:
#
#                  obspos = spoint - srfvec
#
#               To transform the vector 'srfvec' from a reference frame
#               'fixref' at time 'trgepc' to a time-dependent reference
#               frame 'ref' at time 'et', the routine 'cspice_pxfrm2' should be
#               called. Let 'xform' be the 3x3 matrix representing the
#               rotation from the reference frame 'fixref' at time
#               'trgepc' to the reference frame 'ref' at time 'et'. Then
#               'srfvec' can be transformed to the result 'refvec' as
#               follows:
#
#                  xform  = cspice_pxfrm2 ( fixref, ref, trgepc, et )
#                  refvec = xform * srfvec
#
#      found    a scalar logical indicating whether or not the ray
#               intersects the target. If an intersection exists
#               'found' will return as true If the ray misses
#               the target, 'found' will return as false.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sincpt_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   NAIF_IDS.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # sincpt
#       (spoint::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        trgepc::Float64,  # Ptr{SpiceDouble}
#        srfvec::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        found::Int32) =   # Ptr{SpiceBoolean}
        sincpt(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            fixref::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            dref::AbstractString, # Ptr{ConstSpiceChar}
            dvec::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(dvec) != 3
            error("Incorrect size for parameter 8")
        end
#       allocate the output parameters
        spoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        spoint_ptr = pointer(spoint)
        trgepc = Array{Float64}(1);  # Ptr{SpiceDouble}
        trgepc_ptr = pointer(trgepc)
        srfvec = Array{Float64,1}(3);  # Array_3_SpiceDouble
        srfvec_ptr = pointer(srfvec)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        dvec_t = dvec'
        dvec_ptr = pointer(dvec_t)
        
#       ccall((:sincpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble},Array_3_SpiceDouble,Ptr{SpiceBoolean}),method,target,et,fixref,abcorr,obsrvr,dref,dvec,spoint,trgepc,srfvec,found)
        ccall((:sincpt_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Int32}),
            method,target,et,fixref,abcorr,obsrvr,dref,dvec_ptr,spoint_ptr,trgepc_ptr,srfvec_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return spoint, trgepc[1], srfvec, convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      The following program computes surface intercept points on
#      Mars for the boresight and FOV boundary vectors of the MGS MOC
#      narrow angle camera. The intercepts are computed for a single
#      observation epoch. Light time and stellar aberration corrections
#      are used. For simplicity, camera distortion is ignored.
#
#      %
#      %  Local variables
#      %
#      abcorr  = 'CN+S';
#      camera  = 'MGS_MOC_NA';
#      fixref  = 'IAU_MARS';
#      method  = 'Ellipsoid';
#      obsrvr  = 'MGS';
#      target  = 'Mars';
#      utc     = '2003 OCT 13 06:00:00 UTC';
#      NCORNR  = 4;
#
#      %
#      % Load kernel files.
#      %
#      cspice_furnsh( 'standard.tm' );
#      cspice_furnsh( { '/kernels/MGS/ik/moc20.ti',                 ...
#                       '/kernels/MGS/sclk/MGS_SCLKSCET.00061.tsc'  ,...
#                       '/kernels/MGS/spk/mgs_ext12_ipng_mgs95j.bsp',...
#                       '/kernels/MGS/ck/mgs_sc_ext12.bc' } )
#
#      %
#      % Convert the UTC request time to ET (seconds past
#      % J2000, TDB).
#      %
#      et = cspice_str2et( utc );
#
#      %
#      % Get the MGS MOC Narrow angle camera (MGS_MOC_NA)
#      % ID code. Then look up the field of view (FOV)
#      % parameters.
#      %
#      [ camid, found ] = cspice_bodn2c( camera );
#
#      if ( ~found )
#         txt = sprintf( [ 'SPICE(NOTRANSLATION) ' ...
#                         'Could not find ID code for instrument %s.' ], ...
#                          camera);
#         error( txt )
#      end
#
#      %
#      % cspice_getfov will return the name of the camera-fixed frame
#      % in the string 'dref', the camera boresight vector in
#      % the array 'bsight', and the FOV corner vectors in the
#      % array 'bounds'.
#      %
#      [shape, dref, bsight, bounds] = cspice_getfov( camid, NCORNR);
#
#      fprintf (  ['\n' ...
#                  'Surface Intercept Locations for Camera\n'  ...
#                  'FOV Boundary and Boresight Vectors\n'      ...
#                  '\n'                                        ...
#                  '   Instrument:             %s\n'           ...
#                  '   Epoch:                  %s\n'           ...
#                  '   Aberration correction:  %s\n'           ...
#                  '\n'],                                      ...
#                  camera, utc, abcorr )
#
#      for i=1:NCORNR+1
#
#         if( i <= NCORNR )
#            fprintf( 'Corner vector %d\n\n', i)
#            dvec = bounds(:,i);
#         end
#
#         if ( i == (NCORNR + 1) )
#            fprintf( 'Boresight vector\n\n' )
#            dvec = bsight;
#         end
#
#         %
#         % Compute the surface intercept point using
#         % the specified aberration corrections.
#         %
#         [ spoint, trgepc, srfvec, found ] =                   ...
#                        sincpt( method, target,         ...
#                                       et,     fixref, abcorr, ...
#                                       obsrvr, dref,   dvec );
#         if( found )
#
#            %
#            % Compute range from observer to apparent intercept.
#            %
#            dist = vnorm( srfvec );
#
#            %
#            % Convert rectangular coordinates to planetocentric
#            % latitude and longitude. Convert radians to degrees.
#            %
#            [ radius, lon, lat ] = cspice_reclat( spoint );
#
#            lon = lon * cspice_dpr;
#            lat = lat * cspice_dpr;
#
#            %
#            % Display the results.
#            %
#            fprintf( '  Vector in %s frame = \n', dref )
#            fprintf( '   %18.10e %18.10e %18.10e\n', dvec );
#
#            fprintf( [ '\n'                                              ...
#                       '  Intercept:\n'                                  ...
#                       '\n'                                              ...
#                       '     Radius                   (km)  = %18.10e\n' ...
#                       '     Planetocentric Latitude  (deg) = %18.10e\n' ...
#                       '     Planetocentric Longitude (deg) = %18.10e\n' ...
#                       '     Range                    (km)  = %18.10e\n' ...
#                       '\n' ],                                           ...
#                        radius,  lat,  lon,  dist                          )
#         else
#            disp( 'Intercept not found.' )
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Surface Intercept Locations for Camera
#      FOV Boundary and Boresight Vectors
#
#         Instrument:             MGS_MOC_NA
#         Epoch:                  2003 OCT 13 06:00:00 UTC
#         Aberration correction:  CN+S
#
#      Corner vector 1
#
#        Vector in MGS_MOC_NA frame =
#           1.8571383810e-06  -3.8015622659e-03   9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849411359e+03
#           Planetocentric Latitude  (deg) =  -4.8477481924e+01
#           Planetocentric Longitude (deg) =  -1.2347407905e+02
#           Range                    (km)  =   3.8898310366e+02
#
#      Corner vector 2
#
#        Vector in MGS_MOC_NA frame =
#           1.8571383810e-06   3.8015622659e-03   9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849396987e+03
#           Planetocentric Latitude  (deg) =  -4.8481636340e+01
#           Planetocentric Longitude (deg) =  -1.2339882297e+02
#           Range                    (km)  =   3.8897512129e+02
#
#      Corner vector 3
#
#        Vector in MGS_MOC_NA frame =
#          -1.8571383810e-06   3.8015622659e-03   9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849396899e+03
#           Planetocentric Latitude  (deg) =  -4.8481661910e+01
#           Planetocentric Longitude (deg) =  -1.2339882618e+02
#           Range                    (km)  =   3.8897466238e+02
#
#      Corner vector 4
#
#        Vector in MGS_MOC_NA frame =
#          -1.8571383810e-06  -3.8015622659e-03   9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849411271e+03
#           Planetocentric Latitude  (deg) =  -4.8477507498e+01
#           Planetocentric Longitude (deg) =  -1.2347408220e+02
#           Range                    (km)  =   3.8898264472e+02
#
#      Boresight vector
#
#        Vector in MGS_MOC_NA frame =
#           0.0000000000e+00   0.0000000000e+00   1.0000000000e+00
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849404102e+03
#           Planetocentric Latitude  (deg) =  -4.8479579822e+01
#           Planetocentric Longitude (deg) =  -1.2343645396e+02
#           Range                    (km)  =   3.8897573572e+02
#
#-Version
#
#   -Mice Version 1.0.3, 12-MAR-2012, SCK (JPL)
#
#      References to the new 'cspice_pxfrm2' routine were
#      added to the 'I/O returns' section. A problem description was
#      added to the 'Examples' section, and the references to
#      'srfxpt_c' and the second example were removed.
#
#   -Mice Version 1.0.2, 14-JUL-2010, EDW (JPL)
#
#      Corrected minor typo in header.
#
#   -Mice Version 1.0.1, 23-FEB-2009, EDW (JPL)
#
#      Added proper markers for usage string variable types.
#
#   -Mice Version 1.0.0, 11-FEB-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #####
#    #       #    #  #    #
#     ####   #    #  #    #
#         #  #####   #    #
#    #    #  #       #    #
#     ####   #       #####
#
#   seconds per day
#
################################################################################
#-Abstract
#
#   spd returns the value of the number of seconds in a  
#   standard calendar day: 86400.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      spd = spd
#
#   returns:
#
#      spd   the number of seconds in a day: 86400.
#
#            [1,1] = size(spd); double = class(spd)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spd_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # spd
        spd()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:spd_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:spd_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> spd
#
#   MATLAB outputs:   86400.000
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####    #   #  #
#    #       #    #  #    #  #    #    # #   #
#     ####   #    #  ######  #          #    #
#         #  #####   #    #  #          #    #
#    #    #  #       #    #  #    #     #    #
#     ####   #       #    #   ####      #    ######
#
#   spherical to cylindrical coordinates
#
################################################################################
#-Abstract
#
#   sphcyl converts spherical coordinates to cylindrical
#   coordinates.
#
#-I/O
#
#   Given:
#
#      radius   a double precision scalar or double precision 1XN
#               array describing the distance of the position from origin
#
#      colat    a double precision scalar or double precision 1XN array
#               describing the angle of the projection of the point to the XY
#               positive z-axis, measured in radians (also referred to
#               as the polar angle)
#
#      slon     a double precision scalar or 1XN array describing
#               the angle of the projection of the point to the XY
#               plane from the positive X-axis, measured in radians,
#               with range:
#
#                   -pi < slon <= pi
#
#               The positive Y-axis is at longitude PI/2 radians.
#
#   the call:
#
#      [ r, lonc, z] = sphcyl( radius, colat, slon)
#
#   returns:
#
#      r      a double precision scalar or double precision 1xN array
#             describing the distance of the point of interest from z axis
#
#      lonc   a double precision scalar or double precision 1xN array
#             describing the cylindrical angle of the point of interest
#             from the XZ plane measured in radians
#
#      z      a double precision scalar or double precision 1xN array
#             describing the height of the point above the XY plane
#
#             The arguments 'r' and 'z' return in the same units associated
#             with 'radius'.
#
#             'r', 'lonc', and 'z' return with the same vectorization
#             measure(N) as 'radius', 'colat', and 'slon'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sphcyl_c.
#
#   MICE.REQ
#
    function # sphcyl
#       (r::Float64,  # Ptr{SpiceDouble}
#        lon::Float64,  # Ptr{SpiceDouble}
#        z::Float64) =   # Ptr{SpiceDouble}
        sphcyl(
            radius::Float64, # SpiceDouble
            colat::Float64, # SpiceDouble
            slon::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        r = Array{Float64}(1);  # Ptr{SpiceDouble}
        r_ptr = pointer(r)
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        z = Array{Float64}(1);  # Ptr{SpiceDouble}
        z_ptr = pointer(z)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sphcyl_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),radius,colat,slon,r,lon,z)
        ccall((:sphcyl_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            radius,colat,slon,r_ptr,lon_ptr,z_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r[1], lon[1], z[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to spherical
#      % coordinates.
#      %
#      [radius, colat, lon] = cspice_recsph(pos);
#
#      %
#      % Convert the spherical coords to cylindrical.
#      %
#      [r, lon, z] = sphcyl(radius, colat, lon);
#
#      %
#      % Convert the cylindrical to rectangular.
#      %
#      [rectan] = cspice_cylrec(r, lon, z);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#                     0  -0.03701547067225   0.63783453323816
#      0.02182376758148   0.01641520435413  -0.01531271963894
#     -0.01912147275010  -0.04855217028457   0.02039513446643
#
#      The relative error between the original array of position vectors
#      and those that resulted from the various coordinate conversion
#      has magnitude on the order of 10^(-14).
#
#   Example (2):
#
#      %
#      % Define six sets of spherical coordinates, 'slon' and 'colat'
#      % expressed in degrees - converted to radians by use of cspice_rpd.
#      %
#      radius = [  1.,  1., 1.4142, 1.4142, 1.  , 0. ];
#      colat  = [ 90., 90., 45.   , 135.  , 0.  , 0. ] * cspice_rpd;
#      slon   = [  0., 90., 180.  , 180.  , 180., 33.] * cspice_rpd;
#
#      %
#      % ...convert the spherical coordinates to cylindrical coordinates
#      %
#      [r, lonc, z] = sphcyl(radius, colat, slon);
#
#     %
#      % ...convert angular measure to degrees.
#      %
#      colat = colat * cspice_dpr;
#      lonc = lonc   * cspice_dpr;
#      slon = slon   * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r         lonc        z        radius     slon       colat  ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; lonc; z; radius; slon; colat ];
#      txt   = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r         lonc        z        radius      lon       colat
#     --------   --------   --------   --------   --------   --------
#       1.0000     0.0000     0.0000     1.0000     0.0000    90.0000
#       1.0000    90.0000     0.0000     1.0000    90.0000    90.0000
#       1.0000   180.0000     1.0000     1.4142   180.0000    45.0000
#       1.0000   180.0000    -1.0000     1.4142   180.0000   135.0000
#       0.0000   180.0000     1.0000     1.0000   180.0000     0.0000
#       0.0000    33.0000     0.0000     0.0000    33.0000     0.0000
#
#-Version
#
#   -Mice Version 1.0.0, 12-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #  #         ##     #####
#    #       #    #  #    #  #        #  #      #
#     ####   #    #  ######  #       #    #     #
#         #  #####   #    #  #       ######     #
#    #    #  #       #    #  #       #    #     #
#     ####   #       #    #  ######  #    #     #
#
#   spherical to latitudinal coordinates
#
################################################################################
#-Abstract
#
#   sphlat converts spherical coordinates to latitudinal
#   coordinates.
#
#-I/O
#
#   Given:
#
#      r       a double precision scalar or double precision 1XN
#              array describing the distance of the position from origin
#
#      colat   a double precision scalar or double precision 1XN
#              array describing the angle between the point and the
#              positive z-axis, measured in radians (also referred to
#              as the polar angle)
#
#      lons    a double precision scalar or double precision 1XN array
#              describing the angle of the projection of the point to the XY
#              plane from the positive X-axis, measured in radians,
#              with range:
#
#                  -pi < lons <= pi
#
#              The positive Y-axis is at longitude PI/2 radians.
#
#   the call:
#
#      [radius, lon, lat] = sphlat(r, colat, lons)
#
#   returns:
#
#      radius   a double precision scalar or double precision 1xN array
#               describing the distance of the position from origin
#
#      lon      a double precision scalar or double precision 1xN array
#               describing the angle of the position from the XZ plane
#               measured in radians
#
#      lat      a double precision scalar or double precision 1xN array
#               describing the angle of the position from the XY plane
#               measured in radians
#
#               The argument 'radius' returns in the same units associated
#               with 'r'.
#
#               'radius', 'lon', and 'lat' return with the same
#                vectorization measure (N) as the 'r', 'colat',
#                and 'lons'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sphlat_c.
#
#   MICE.REQ
#
    function # sphlat
#       (radius::Float64,  # Ptr{SpiceDouble}
#        lon::Float64,  # Ptr{SpiceDouble}
#        lat::Float64) =   # Ptr{SpiceDouble}
        sphlat(
            r::Float64, # SpiceDouble
            colat::Float64, # SpiceDouble
            lons::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        radius = Array{Float64}(1);  # Ptr{SpiceDouble}
        radius_ptr = pointer(radius)
        lon = Array{Float64}(1);  # Ptr{SpiceDouble}
        lon_ptr = pointer(lon)
        lat = Array{Float64}(1);  # Ptr{SpiceDouble}
        lat_ptr = pointer(lat)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sphlat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Ptr{SpiceDouble}),r,colat,lons,radius,lon,lat)
        ccall((:sphlat_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            r,colat,lons,radius_ptr,lon_ptr,lat_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return radius[1], lon[1], lat[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to latitudinal
#      % coordinates.
#      %
#      [r, colat, lons] = cspice_recsph(pos);
#
#      %
#      % Convert the latitudinal coords to spherical.
#      %
#      [ radius, lon, lat] = sphlat(r, colat, lons);
#
#      %
#      % Convert the spherical coords to rectangular.
#      %
#      [rectan] = cspice_latrec( radius, lon, lat);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#                     0  -0.05552320600838   0.63783453323816
#      0.02182376758148                  0  -0.01531271963894
#      0.01912147275010  -0.02427608514229   0.02039513446643
#
#   Example(2):
#
#      %
#      % Define six sets of spherical coordinates, 'lon' and 'colat'
#      % expressed in degrees - converted to radians by use of cspice_rpd.
#      %
#      r     = [  1.,  1., 1.4142, 1.4142, 1.  , 0. ];
#      colat = [ 90., 90., 45.   , 135.  , 0.  , 0. ] * cspice_rpd;
#      lons  = [  0., 90., 180.  , 180.  , 180., 33.] * cspice_rpd;
#
#      %
#      % ...convert the latitudinal coordinates to spherical coordinates
#      %
#      [rad, lon, lat] = sphlat(r, colat, lons);
#
#      %
#      % ...convert angular measure to degrees.
#      %
#      colat = colat * cspice_dpr;
#      lon   = lon   * cspice_dpr;
#      lons  = lons  * cspice_dpr;
#      lat   = lat   * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('    r         colat       lons       rad        lon        lat   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; colat; lons; rad; lon; lat];
#      txt    = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#       r         colat       lons       rad        lon        lat
#     --------   --------   --------   --------   --------   --------
#       1.0000    90.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000    90.0000     1.0000    90.0000     0.0000
#       1.4142    45.0000   180.0000     1.4142   180.0000    45.0000
#       1.4142   135.0000   180.0000     1.4142   180.0000   -45.0000
#       1.0000     0.0000   180.0000     1.0000   180.0000    90.0000
#       0.0000     0.0000    33.0000     0.0000    33.0000    90.0000
#
#-Version
#
#   -Mice Version 1.0.0, 12-DEC-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #  #####   ######   ####
#    #       #    #  #    #  #    #  #       #    #
#     ####   #    #  ######  #    #  #####   #
#         #  #####   #    #  #####   #       #
#    #    #  #       #    #  #   #   #       #    #
#     ####   #       #    #  #    #  ######   ####
#
#   spherical to rectangular coordinates
#
################################################################################
#-Abstract
#
#   sphrec converts spherical coordinates to rectangular
#   (Cartesian) coordinates.
#
#-I/O
#
#   Given:
#
#      r       a double precision scalar or double precision 1XN
#              array describing the distance of the position from origin
#
#      colat   a double precision scalar or double precision 1XN
#              array describing the angle between the point and the
#              positive z-axis, measured in radians (also referred to
#              as the polar angle)
#
#      lon     a double precision scalar or double precision 1XN array
#              describing the angle of the projection of the point to the XY
#              plane from the positive X-axis, measured in radians,
#              with range:
#
#                  -pi < lon <= pi
#
#              The positive Y-axis is at longitude PI/2 radians.
#
#   the call:
#
#       rectan = sphrec( r, colat, lon)
#
#   returns:
#
#      rectan   a double precision 3x1 array or double precision
#               3xN array containing the rectangular coordinates of the
#               position or set of positions
#
#               The argument 'rectan' returns in the same units associated
#               with 'r'.
#
#               'rectan' returns with the same vectorization measure (N)
#                as 'r', 'colat', and 'lon'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sphrec_c.
#
#   MICE.REQ
#
    function # sphrec
#       (rectan::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        sphrec(
            r::Float64, # SpiceDouble
            colat::Float64, # SpiceDouble
            lon::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        rectan = Array{Float64,1}(3);  # Array_3_SpiceDouble
        rectan_ptr = pointer(rectan)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sphrec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble),r,colat,lon,rectan)
        ccall((:sphrec_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64}),
            r,colat,lon,rectan_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rectan
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example (1):
#
#      %
#      % Load an SPK, leapseconds, and PCK kernel set.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create a vector of scalar times.
#      %
#      et = [0:2]*2.*cspice_spd;
#
#      %
#      % Retrieve the position of the moon seen from earth at 'et'
#      % in the J2000 frame without aberration correction.
#      %
#      [pos, et] = cspice_spkpos( 'MOON', et, 'J2000', 'NONE', 'EARTH' );
#
#      %
#      % Convert the array of position vectors 'pos' to spherical
#      % coordinates.
#      %
#      [r, colat, lon] = cspice_recsph(pos);
#
#      %
#      % Convert the spherical to rectangular.
#      %
#      [rectan] = sphrec(r, colat, lon);
#
#      %
#      % Calculate the relative error against the original position
#      % vectors.
#      %
#      (rectan-pos) ./ pos
#
#   MATLAB outputs:
#
#      1.0e-14 *
#
#                     0  -0.03701547067225   0.63783453323816
#      0.02182376758148   0.01641520435413  -0.01531271963894
#     -0.01912147275010  -0.04855217028457   0.02039513446643
#
#      Example (2):
#
#      %
#      % Define eleven sets of spherical coordinates, 'lon' and 'colat'
#      % expressed in degrees - converted to radians by use of cspice_rpd.
#      %
#      r     = [  0., 1., 1., 1., 1., 1., 1., ...
#                 sqrt(2), sqrt(2), sqrt(2), sqrt(3) ];
#      colat = [  0., 90., 90., 0., 90., 90., ...
#                 180. 90., 45., 45., 54.7356] * cspice_rpd;
#      lons  = [  0., 0., 90., 0., 180., -90.,...
#                 0., 45., 0., 90., 45] * cspice_rpd;
#
#      %
#      % ...convert the spherical coordinates to rectangular coordinates
#      %
#      rec = sphrec(r, colat, lons);
#
#      %
#      % Loop over each set of coordinates for output, convert  'colat' and
#      % 'lons' to degrees...
#      %
#      colat = colat * cspice_dpr;
#      lons  = lons  * cspice_dpr;
#
#      %
#      % Output banner.
#      %
#      disp('     r        colat       lons         x         y           z   ')
#      disp('  --------   --------   --------   --------   --------   --------')
#
#      %
#      % Create an array of values for output.
#      %
#      output = [ r; colat; lons; rec(1,:); rec(2,:); rec(3,:)];
#      txt    = sprintf( '%10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n', output);
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        r        colat       lons         x         y           z
#     --------   --------   --------   --------   --------   --------
#       0.0000     0.0000     0.0000     0.0000     0.0000     0.0000
#       1.0000    90.0000     0.0000     1.0000     0.0000     0.0000
#       1.0000    90.0000    90.0000     0.0000     1.0000     0.0000
#       1.0000     0.0000     0.0000     0.0000     0.0000     1.0000
#       1.0000    90.0000   180.0000    -1.0000     0.0000     0.0000
#       1.0000    90.0000   -90.0000     0.0000    -1.0000     0.0000
#       1.0000   180.0000     0.0000     0.0000     0.0000    -1.0000
#       1.4142    90.0000    45.0000     1.0000     1.0000     0.0000
#       1.4142    45.0000     0.0000     1.0000     0.0000     1.0000
#       1.4142    45.0000    90.0000     0.0000     1.0000     1.0000
#       1.7321    54.7356    45.0000     1.0000     1.0000     1.0000
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####   #        ####
#    #       #    #  #   #   #    #  #       #
#     ####   #    #  ####    #       #        ####
#         #  #####   #  #    #       #            #
#    #    #  #       #   #   #    #  #       #    #
#     ####   #       #    #   ####   ######   ####
#
#   close an spk file
#
################################################################################
#-Abstract
#
#   spkcls closes a SPK file opened for read or write.
#
#-I/O
#
#   Given:
#
#      handle   the file handle for an open SPK file.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#   the call:
#
#      spkcls( handle )
#
#   returns:
#
#   The routine closes the file indicated by 'handle'. The close operation
#   tests the file to ensure the presence of data segments.
#
#-Particulars
#
#   A spkcls call should balance every cspice_spkopn
#   call.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkcls_c.
#
#   MICE.REQ
#   SPK.REQ
#
    function # spkcls
#       (handle::Int32) =   # SpiceInt
        spkcls()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:spkcls_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),handle)
        ccall((:spkcls_c,libNasaSpice),Void,
            (Ptr{Int32},),
            handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#-Version
#
#   -Mice Version 1.0.0, 23-MAY-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####   #####    ####
#    #       #    #  #   #   #    #  #    #  #    #
#     ####   #    #  ####    #       #    #  #    #
#         #  #####   #  #    #       #####   #    #
#    #    #  #       #   #   #    #  #       #    #
#     ####   #       #    #   ####   #        ####
#
#   state relative to constant_position_observer
#   state relative to constant_position surface_point
#   state relative to surface_point on extended_object
#   state relative to landmark on extended_object
#
################################################################################
#-Abstract
#
#   spkcpo returns the state of a specified target relative to
#   an "observer," where the observer has constant position in a
#   specified reference frame. The observer's position is provided
#   by the calling program rather than by loaded SPK files.
#
#-I/O
#
#   Given:
#
#      target   name of a target body. Optionally, you may supply
#               the ID code of the object as an integer string. For
#               example, both 'EARTH' and '399' are legitimate strings
#               to supply to indicate the target is earth.
#
#               Case and leading and trailing blanks are not significant
#               in the string 'target'.
#
#               [1,c1] = size(target), char = class(target)
#
#                  or
#
#               [1,1] = size(target); cell = class(target)
#
#      et       ephemeris time at which the state of the target relative to
#               the observer is to be computed. 'et' is expressed as seconds
#               past J2000 TDB. 'et' refers to time at the observer's location.
#
#               [1,1] = size(et), double = class(et)
#
#      outref   name of the reference frame with respect to which
#               the output state is expressed.
#
#               When 'outref' is time-dependent (non-inertial), its
#               orientation relative to the J2000 frame is evaluated in
#               the manner commanded by the input argument 'refloc' (see
#               description below).
#
#               Case and leading and trailing blanks are not significant
#               in the string 'outref'.
#
#               [1,c2] = size(outref), char = class(outref)
#
#                  or
#
#               [1,1] = size(outref); cell = class(outref)
#
#      refloc   name indicating the output reference frame
#               evaluation locus: this is the location associated
#               with the epoch at which this routine is to evaluate
#               the orientation, relative to the J2000 frame, of the
#               output frame 'outref'. The values and meanings of
#               'refloc' are:
#
#                  'OBSERVER'  Evaluate 'outref' at the observer's
#                              epoch 'et'.
#
#                              Normally the locus 'OBSERVER' should
#                              be selected when 'outref' is centered
#                              at the observer.
#
#                  'TARGET'    Evaluate 'outref' at the target epoch;
#                              letting 'lt' be the one-way light time
#                              between the target and observer, the
#                              target epoch is
#
#                                 et-lt  if reception aberration
#                                        corrections are used
#
#                                 et+lt  if transmission aberration
#                                        corrections are used
#
#                                 et     if no aberration corrections
#                                        are used
#
#                              Normally the locus 'TARGET' should
#                              be selected when 'outref' is centered
#                              at the target object.
#
#                  'CENTER'    Evaluate the frame 'outref' at the epoch
#                              associated its center. This epoch,
#                              which we'll call 'etctr', is determined
#                              as follows:
#
#                                 Let 'ltctr' be the one-way light time
#                                 between the observer and the center
#                                 of 'outref'. Then 'etctr' is
#
#                                    et-ltctr  if reception
#                                              aberration corrections
#                                              are used
#
#                                    et+ltctr  if transmission
#                                              aberration corrections
#                                              are used
#
#                                    et        if no aberration
#                                              corrections are used
#
#
#                              The locus 'CENTER' should be selected
#                              when the user intends to obtain
#                              results compatible with those produced
#                              by cspice_spkezr.
#
#               When 'outref' is inertial, all choices of 'refloc'
#               yield the same results.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'refloc'.
#
#               [1,c3] = size(refloc), char = class(refloc)
#
#                  or
#
#               [1,1] = size(refloc); cell = class(refloc)
#
#      abcorr   scalar string name indicating the aberration corrections to be
#               applied to the observer-target state to account for one-way
#               light time and stellar aberration.
#
#               'abcorr' may be any of the following:
#
#                  'NONE'     Apply no correction. Return the
#                             geometric state of the target
#                             relative to the observer.
#
#               The following values of 'abcorr' apply to the
#               "reception" case in which photons depart from the
#               target's location at the light-time corrected epoch
#               et-lt and *arrive* at the observer's location at 'et':
#
#                  'LT'       Correct for one-way light time (also
#                             called "planetary aberration") using a
#                             Newtonian formulation. This correction
#                             yields the state of the target at the
#                             moment it emitted photons arriving at
#                             the observer at 'et'.
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             'LT' option uses one iteration.
#
#                  'LT+S'     Correct for one-way light time and
#                             stellar aberration using a Newtonian
#                             formulation. This option modifies the
#                             state obtained with the 'LT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The result is the apparent
#                             state of the target---the position and
#                             velocity of the target as seen by the
#                             observer.
#
#                  'CN'       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the 'CN' correction iterates
#                             until the solution converges.
#
#                  'CN+S'     Converged Newtonian light time
#                             and stellar aberration corrections.
#
#
#               The following values of 'abcorr' apply to the
#               "transmission" case in which photons *depart* from
#               the observer's location at 'et' and arrive at the
#               target's location at the light-time corrected epoch
#               et+lt:
#
#                  'XLT'      "Transmission" case:  correct for
#                             one-way light time using a Newtonian
#                             formulation. This correction yields the
#                             state of the target at the moment it
#                             receives photons emitted from the
#                             observer's location at 'et'.
#
#                  'XLT+S'    "Transmission" case:  correct for
#                             one-way light time and stellar
#                             aberration using a Newtonian
#                             formulation  This option modifies the
#                             state obtained with the 'XLT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The position component of
#                             the computed target state indicates the
#                             direction that photons emitted from the
#                             observer's location must be "aimed" to
#                             hit the target.
#
#                  'XCN'      "Transmission" case:  converged
#                             Newtonian light time correction.
#
#                  'XCN+S'    "Transmission" case:  converged
#                             Newtonian light time and stellar
#                             aberration corrections.
#
#
#               Neither special nor general relativistic effects are
#               accounted for in the aberration corrections applied
#               by this routine.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'abcorr'.
#
#               [1,c4] = size(abcorr), char = class(abcorr)
#
#                  or
#
#               [1,1] = size(abcorr); cell = class(abcorr)
#
#      obspos   fixed (constant) geometric position of an observer
#               relative to its center of motion 'obsctr', expressed in
#               the reference frame 'obsref'.
#
#               Units are always km.
#
#               [3,1] = size(obspos), double = class(obspos)
#
#      obsctr   name of the center of motion of 'obspos'. The
#               ephemeris of 'obsctr' is provided by loaded SPK files.
#
#               Optionally, you may supply the integer ID code for
#               the object as an integer string. For example both
#               'MOON' and '301' are legitimate strings that indicate
#               the moon is the center of motion.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'obsctr'.
#
#               [1,c5] = size(obsctr), char = class(obsctr)
#
#                  or
#
#               [1,1] = size(obsctr); cell = class(obsctr)
#
#      obsref   name of the reference frame relative to which the
#               input position 'obspos' is expressed. The observer has
#               constant position relative to its center of motion in
#               this reference frame.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'obsref'.
#
#               [1,c6] = size(obsref), char = class(obsref)
#
#                  or
#
#               [1,1] = size(obsref); cell = class(obsref)
#
#   the call:
#
#      [state, lt] = spkcpo(target, et,     outref, ...
#                                  refloc, abcorr, obspos, ...
#                                  obsctr, obsref)
#
#   returns:
#
#      state   state of the target relative to the specified
#              observer. 'state' is corrected for the specified
#              aberrations and is expressed with respect to the
#              reference frame specified by 'outref'. The first three
#              components of 'state' represent the x-, y- and
#              z-components of the target's position; the last three
#              components form the corresponding velocity vector.
#
#              The position component of 'state' points from the
#              observer's location at 'et' to the aberration-corrected
#              location of the target. Note that the sense of the
#              position vector is independent of the direction of
#              radiation travel implied by the aberration
#              correction.
#
#              The velocity component of 'state' is the derivative
#              with respect to time of the position component of
#              'state'.
#
#              Units are always km and km/sec.
#
#              When 'state' is expressed in a time-dependent
#              (non-inertial) output frame, the orientation of that
#              frame relative to the J2000 frame is evaluated in the
#              manner indicated by the input argument 'refloc' (see
#              description above).
#
#              [6,1] = size(state), double = class(state)
#
#      lt      one-way light time between the observer
#              and target in seconds. If the target state is corrected
#              for aberrations, then 'lt' is the one-way light time
#              between the observer and the light time corrected
#              target location.
#
#              [1,1] = size(lt), double = class(lt)
#
#-Particulars
#
#   This routine computes observer-target states for observers whose
#   trajectories are not provided by SPK files.
#
#   Observers supported by this routine must have constant position
#   with respect to a specified center of motion, expressed in a
#   caller-specified reference frame. The state of the center of
#   motion relative to the target must be computable using
#   loaded SPK data.
#
#   For applications in which the observer has constant, non-zero velocity
#   relative to its center of motion, the CSPICE routine
#
#      cspice_spkcvo     { SPK, constant velocity observer state }
#
#   can be used.
#
#   This routine is suitable for computing states of target ephemeris
#   objects, as seen from landmarks on the surface of an extended
#   object, in cases where no SPK data are available for those
#   landmarks.
#
#   This routine's treatment of the output reference frame differs
#   from that of the principal SPK API routines
#
#      cspice_spkezr
#      cspice_spkpos
#
#   which require both observer and target ephemerides to be provided
#   by loaded SPK files:
#
#      The SPK API routines listed above evaluate the orientation of the
#      output reference frame (with respect to the J2000 frame) at an
#      epoch corrected for one-way light time between the observer and
#      the center of the output frame. When the center of the output
#      frame is not the target (for example, when the target is on the
#      surface of Mars and the output frame is centered at Mars'
#      center), the epoch of evaluation may not closely match the
#      light-time corrected epoch associated with the target itself. A
#      similar problem may occur when the observer is a surface point on
#      an extended body and the output frame is centered at the body
#      center: the listed routines will correct the orientation of the
#      output frame for one-way light time between the frame center and
#      the observer.
#
#      This routine allows the caller to dictate how the orientation
#      of the output reference frame is to be evaluated. The caller
#      passes to this routine an input string called the output
#      frame's evaluation "locus." This string specifies the location
#      associated with the output frame's evaluation epoch. The three
#      possible values of the locus are
#
#         'TARGET'
#         'OBSERVER'
#         'CENTER'
#
#      The choice of locus has an effect when aberration corrections
#      are used and the output frame is non-inertial.
#
#      When the locus is 'TARGET' and light time corrections are
#      used, the orientation of the output frame is evaluated at the
#      epoch obtained by correcting the observation epoch 'et' for
#      one-way light time 'lt'. The evaluation epoch will be either
#      et-lt or et+lt for reception or transmission corrections
#      respectively.
#
#      For remote sensing applications where the target is a surface
#      point on an extended object, and the orientation of that
#      object should be evaluated at the emission time, the locus
#      'TARGET' should be used.
#
#      When the output frame's orientation should be evaluated at
#      the observation epoch 'et', which is the case when the
#      output frame is centered at the observer, the locus
#      'OBSERVER' should be used.
#
#      The locus option 'CENTER' is provided for compatibility
#      with existing SPK state computation APIs such as cspice_spkezr.
#
#      Note that the output frame evaluation locus does not affect
#      the computation of light time between the target and
#      observer.
#
#
#   The SPK routines that compute observer-target states for
#   combinations of objects having ephemerides provided by the SPK
#   system and objects having constant position or constant velocity
#   are
#
#      spkcpo {SPK, Constant position observer}
#      cspice_spkcpt {SPK, Constant position target}
#      cspice_spkcvo {SPK, Constant velocity observer}
#      cspice_spkcvt {SPK, Constant velocity target}
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkcpo_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # spkcpo
#       (state::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        lt::Float64) =   # Ptr{SpiceDouble}
        spkcpo(
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            outref::AbstractString, # Ptr{ConstSpiceChar}
            refloc::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obssta::Array{Float64,1}, # Array_3_ConstSpiceDouble
            obsctr::AbstractString, # Ptr{ConstSpiceChar}
            obsref::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
        if length(obssta) != 3
            error("Incorrect size for parameter 6")
        end
#       allocate the output parameters
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        lt = Array{Float64}(1);  # Ptr{SpiceDouble}
        lt_ptr = pointer(lt)
        
#       make transposed copies of all input arrays and their pointers
        obssta_t = obssta'
        obssta_ptr = pointer(obssta_t)
        
#       ccall((:spkcpo_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_ConstSpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_SpiceDouble,Ptr{SpiceDouble}),target,et,outref,refloc,abcorr,obssta,obsctr,obsref,state,lt)
        ccall((:spkcpo_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            target,et,outref,refloc,abcorr,obssta_ptr,obsctr,obsref,state_ptr,lt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return state, lt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#
#      KPL/MK
#
#         File name: spkcpo.tm
#
#         This is the meta-kernel file for the header code example for
#         the subroutine cspice_spkcvo. These kernel files can be found on
#         the NAIF website.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                        Contents
#            ---------                        --------
#            de421.bsp                        Planetary ephemeris
#            pck00010.tpc                     Planet orientation and
#                                             radii
#            naif0010.tls                     Leapseconds
#            earth_720101_070426.bpc          Earth historical
#                                             binary PCK
#            earthstns_itrf93_050714.bsp      DSN station SPK
#            earth_topo_050714.tf             DSN station FK
#            mgs_moc_v20.ti                   MGS MOC instrument
#                                             parameters
#            mgs_sclkscet_00061.tsc           MGS SCLK coefficients
#            mgs_sc_ext12.bc                  MGS s/c bus attitude
#            mgs_ext12_ipng_mgs95j.bsp        MGS ephemeris
#
#         \begindata
#
#         KERNELS_TO_LOAD = ( 'de421.bsp',
#                             'pck00010.tpc',
#                             'naif0010.tls',
#                             'earth_720101_070426.bpc',
#                             'earthstns_itrf93_050714.bsp',
#                             'earth_topo_050714.tf',
#                             'mgs_moc_v20.ti',
#                             'mgs_sclkscet_00061.tsc',
#                             'mgs_sc_ext12.bc',
#                             'mgs_ext12_ipng_mgs95j.bsp'  )
#
#         \begintext
#
#   Example:
#
#      %
#      % Program spkcpo_t
#      %
#      % This program uses spkcpo to compute solar azimuth
#      % and elevation at a given surface point on the earth.
#      %
#
#      %
#      % Local constants
#      %
#      META   =  'spkcpo.tm';
#      TIMFMT =  'YYYY MON DD HR:MN:SC.###### UTC';
#      TIMFM2 =  'YYYY MON DD HR:MN:SC.###### TDB ::TDB';
#
#      %
#      % Local variables
#      %
#      z = [ 0.0, 0.0, 1.0 ]';
#
#      %
#      % Load SPICE kernels.
#      %
#      cspice_furnsh( META )
#
#      %
#      % Convert the observation time to seconds past J2000 TDB.
#      %
#      obstim = '2003 OCT 13 06:00:00.000000 UTC';
#
#      et = cspice_str2et( obstim );
#
#      %
#      % Set the target, observer center, and observer frame.
#      %
#      target = 'SUN';
#      obsctr = 'EARTH';
#      obsref = 'ITRF93';
#
#      %
#      % Set the position of DSS-14 relative to the earth's
#      % center at the J2000 epoch, expressed in the
#      % ITRF93 reference frame. Values come from the
#      % earth station SPK specified in the meta-kernel.
#      %
#      % The actual station velocity is non-zero due
#      % to tectonic plate motion; we ignore the motion
#      % in this example. See the routine SPKCVO for an
#      % example in which the plate motion is accounted for.
#      %
#      obsepc    =  0.0;
#
#      obspos =  [ -2353.6213656676991,  ...
#                  -4641.3414911499403,  ...
#                   3677.0523293197439 ]';
#
#      %
#      % Find the apparent state of the sun relative
#      % to the station in the DSS-14_TOPO reference frame.
#      % Evaluate the output frame's orientation, that is the
#      % orientation of the DSS-14_TOPO frame relative to the
#      % J2000 frame, at the observation epoch. This
#      % correction is obtained by setting 'refloc' to
#      % 'OBSERVER'.
#      %
#
#      outref = 'DSS-14_TOPO';
#      abcorr = 'CN+S';
#
#      refloc = 'OBSERVER';
#
#      %
#      % Compute the observer-target state.
#      %
#      [state0, lt0] = spkcpo( target, et, outref, refloc, ...
#                                     abcorr, obspos, obsctr, obsref );
#
#      %
#      % Compute planetocentric coordinates of the
#      % observer-target position in the local
#      % topocentric reference frame DSS-14_TOPO.
#      %
#      [ r, lon, lat] = cspice_reclat( state0(1:3) );
#
#      %
#      % Compute solar azimuth. The latitude we've
#      % already computed is the elevation. Express
#      % both angles in degrees.
#      %
#      el =   lat * cspice_dpr;
#      az = - lon * cspice_dpr;
#
#      if ( az < 0.0 )
#         az = az + 360.0;
#      end
#
#      %
#      % Display the computed state, light time. and angles.
#      %
#      emitim = cspice_timout( et-lt0, TIMFMT );
#      epcstr = cspice_timout( obsepc, TIMFM2 );
#
#      fprintf( ' Frame evaluation locus:     %s\n\n', refloc )
#
#      fprintf( ' Target:                     %s\n', target )
#      fprintf( ' Observation time:           %s\n', obstim )
#      fprintf( ' Observer center:            %s\n', obsctr )
#      fprintf( ' Observer-center state time: %s\n', epcstr )
#      fprintf( ' Observer frame:             %s\n', obsref )
#      fprintf( ' Emission time:              %s\n', emitim )
#      fprintf( ' Output reference frame:     %s\n', outref )
#      fprintf( ' Aberration correction:      %s\n\n', abcorr)
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt0 )
#
#      fprintf( ' Solar azimuth (deg):     %20.8f\n', az )
#      fprintf( ' Solar elevation (deg):   %20.8f\n\n', el )
#
#      %
#      % For an arbitrary surface point, we might not
#      % have a frame kernel available. In this case
#      % we can look up the state in the observer frame
#      % using spkcpo and then convert the state to
#      % the local topocentric frame. We'll first
#      % create the transformation matrix for converting
#      % vectors in the observer frame to the topocentric
#      % frame.
#      %
#      % First step: find the geodetic (planetodetic)
#      % coordinates of the observer. We need the
#      % equatorial radius and flattening coefficient
#      % of the reference ellipsoid.
#      %
#      radii = cspice_bodvrd( 'EARTH', 'RADII', 3 );
#
#      re = radii(1);
#      rp = radii(3);
#
#      f  = ( re - rp ) / re;
#
#      [obslon, obslat, obsalt] = cspice_recgeo( obspos, re, f );
#
#      %
#      % Find the outward surface normal on the reference
#      % ellipsoid at the observer's longitude and latitude.
#      %
#      normal = cspice_latrec( 1., obslon, obslat );
#
#      %
#      % The topocentric frame has its +Z axis aligned
#      % with NORMAL and its +X axis pointed north.
#      % The north direction is aligned with the component
#      % of the ITRF93 +Z axis orthogonal to the topocentric
#      % +Z axis.
#      %
#      xform = cspice_twovec( normal, 3, z, 1 );
#
#      outref = 'ITRF93';
#      abcorr = 'CN+S';
#
#      refloc = 'OBSERVER';
#
#      %
#      % Compute the observer-target state.
#      %
#      [state1, lt1] = spkcpo( target, et, outref, refloc, ...
#                                     abcorr, obspos, obsctr, obsref );
#
#      %
#      % Convert the position to the topocentric frame.
#      %
#      topvec = xform * state1(1:3);
#
#      %
#      % Compute azimuth and elevation.
#      %
#      [ r, lon, lat] = cspice_reclat( topvec );
#
#      el =   lat * cspice_dpr;
#      az = - lon * cspice_dpr;
#
#      if ( az < 0.0 )
#         az = az + 360.0;
#      end
#
#      vpos = cspice_vdist( state0(1:3), topvec )
#      fprintf( ' AZ/EL computed without frame kernel:' )
#      fprintf( ' Distance between last two\n'          )
#      fprintf( ' positions (km):   %20.8f\n\n', vpos )
#
#      fprintf( ' Solar azimuth (deg):     %20.8f\n', az )
#      fprintf( ' Solar elevation (deg):   %20.8f\n\n', el )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Frame evaluation locus:     OBSERVER
#
#      Target:                     SUN
#      Observation time:           2003 OCT 13 06:00:00.000000 UTC
#      Observer center:            EARTH
#      Observer-center state time: 2000 JAN 01 12:00:00.000000 TDB
#      Observer frame:             ITRF93
#      Emission time:              2003 OCT 13 05:51:42.068322 UTC
#      Output reference frame:     DSS-14_TOPO
#      Aberration correction:      CN+S
#
#      Observer-target position (km):
#        62512272.82074845    58967494.42513601  -122059095.46751881
#      Observer-target velocity (km/s):
#            2475.97326517       -9870.26706232       -3499.90809969
#      Light time (s):                497.93167797
#
#      Solar azimuth (deg):             316.67141599
#      Solar elevation (deg):           -54.85253168
#
#      AZ/EL computed without frame kernel: Distance between last two
#      positions (km):             3.07056970
#
#      Solar azimuth (deg):             316.67141786
#      Solar elevation (deg):           -54.85253216
#
#
#-Version
#
#   -Mice Version 1.0.0, 16-APR-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####   #####    #####
#    #       #    #  #   #   #    #  #    #     #
#     ####   #    #  ####    #       #    #     #
#         #  #####   #  #    #       #####      #
#    #    #  #       #   #   #    #  #          #
#     ####   #       #    #   ####   #          #
#
#   state of constant_position_target
#   state of surface_point on extended_object
#   state of landmark on extended_object
#
################################################################################
#-Abstract
#
#   spkcpt returns the state, relative to a specified observer, of a
#   target having constant position in a specified reference frame. The
#   target's position is provided by the calling program rather than by
#   loaded SPK files.
#
#-I/O
#
#   Given:
#
#      trgpos   fixed (constant) position of a target relative
#               to its "center of motion" 'trgctr',
#               expressed in the reference frame 'trgref'.
#
#               Units are always km.
#
#               [3,1] = size(trgpos), double = class(trgpos)
#
#      trgctr   name of the center of motion of 'trgpos'. The
#               ephemeris of 'trgctr' is provided by loaded SPK files.
#
#               Optionally, you may supply the integer ID code for the
#               object as an integer string. For example both 'MOON' and
#               '301' are legitimate strings that indicate the moon is
#               the center of motion.
#
#               Case and leading and trailing blanks are not significant
#               in the string 'trgctr'.
#
#               [1,c1] = size(trgctr), char = class(trgctr)
#
#      trgref   name of the reference frame relative to which the
#               input position 'trgpos' is expressed. The target has
#               constant position relative to its center of motion in
#               this reference frame.
#
#               Case and leading and trailing blanks are not significant
#               in the string 'trgref'.
#
#               [1,c2] = size(trgref), char = class(trgref)
#
#      et       ephemeris time at which the state of the target
#               relative to the observer is to be computed. 'et' is
#               expressed as seconds past J2000 TDB. 'et' refers to time
#               at the observer's location.
#
#               'et' is independent of the target epoch 'trgepc'.
#
#               [1,1] = size(et), double = class(et)
#
#      outref   name of the reference frame with respect to which
#               the output state is expressed.
#
#               When 'outref' is time-dependent (non-inertial), its
#               orientation relative to the J2000 frame is evaluated in
#               the manner commanded by the input argument 'refloc' (see
#               description below).
#
#               Case and leading and trailing blanks are not significant
#               in the string 'outref'.
#
#               [1,c3] = size(outref), char = class(outref)
#
#      refloc   name indicating the output reference frame
#               evaluation locus: this is the location associated
#               with the epoch at which this routine is to evaluate
#               the orientation, relative to the J2000 frame, of the
#               output frame 'outref'. The values and meanings of
#               'refloc' are:
#
#                  'OBSERVER'  Evaluate 'outref' at the observer's
#                              epoch 'et'.
#
#                              Normally the locus 'OBSERVER' should
#                              be selected when 'outref' is centered
#                              at the observer.
#
#
#                  'TARGET'    Evaluate 'outref' at the target epoch;
#                              letting 'lt' be the one-way light time
#                              between the target and observer, the
#                              target epoch is
#
#                                 et-lt  if reception aberration
#                                        corrections are used
#
#                                 et+lt  if transmission aberration
#                                        corrections are used
#
#                                 et     if no aberration corrections
#                                        are used
#
#                              Normally the locus 'TARGET' should
#                              be selected when 'outref' is 'trgref',
#                              the frame in which the target position
#                              is specified.
#
#
#                  'CENTER'    Evaluate the frame 'outref' at the epoch
#                              associated its center. This epoch,
#                              which we'll call 'etctr', is determined
#                              as follows:
#
#                                 Let 'ltctr' be the one-way light time
#                                 between the observer and the center
#                                 of 'outref'. Then 'etctr' is
#
#                                    et-ltctr  if reception
#                                              aberration corrections
#                                              are used
#
#                                    et+ltctr  if transmission
#                                              aberration corrections
#                                              are used
#
#                                    et        if no aberration
#                                              corrections are used
#
#
#                              The locus 'CENTER' should be selected
#                              when the user intends to obtain
#                              results compatible with those produced
#                              by spkezr.
#
#               When 'outref' is inertial, all choices of 'refloc'
#               yield the same results.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'refloc'.
#
#               [1,c4] = size(refloc), char = class(refloc)
#
#      abcorr   name indicating the aberration corrections to be applied
#               to the observer-target state to account for one-way
#               light time and stellar aberration.
#
#               'abcorr' may be any of the following:
#
#                  'NONE'     Apply no correction. Return the
#                             geometric state of the target
#                             relative to the observer.
#
#               The following values of 'abcorr' apply to the
#               "reception" case in which photons depart from the
#               target's location at the light-time corrected epoch
#               et-lt and *arrive* at the observer's location at 'et':
#
#                  'LT'       Correct for one-way light time (also
#                             called "planetary aberration") using a
#                             Newtonian formulation. This correction
#                             yields the state of the target at the
#                             moment it emitted photons arriving at
#                             the observer at 'et'.
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             'LT' option uses one iteration.
#
#                  'LT+S'     Correct for one-way light time and
#                             stellar aberration using a Newtonian
#                             formulation. This option modifies the
#                             state obtained with the 'LT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The result is the apparent
#                             state of the target---the position and
#                             velocity of the target as seen by the
#                             observer.
#
#                  'CN'       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the 'CN' correction iterates
#                             until the solution converges.
#
#                  'CN+S'     Converged Newtonian light time
#                             and stellar aberration corrections.
#
#
#               The following values of 'abcorr' apply to the
#               "transmission" case in which photons *depart* from
#               the observer's location at 'et' and arrive at the
#               target's location at the light-time corrected epoch
#               et+lt:
#
#                  'XLT'      "Transmission" case:  correct for
#                             one-way light time using a Newtonian
#                             formulation. This correction yields the
#                             state of the target at the moment it
#                             receives photons emitted from the
#                             observer's location at 'et'.
#
#                  'XLT+S'    "Transmission" case:  correct for
#                             one-way light time and stellar
#                             aberration using a Newtonian
#                             formulation  This option modifies the
#                             state obtained with the 'XLT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The position component of
#                             the computed target state indicates the
#                             direction that photons emitted from the
#                             observer's location must be "aimed" to
#                             hit the target.
#
#                  'XCN'      "Transmission" case:  converged
#                             Newtonian light time correction.
#
#                  'XCN+S'    "Transmission" case:  converged
#                             Newtonian light time and stellar
#                             aberration corrections.
#
#               Neither special nor general relativistic effects are
#               accounted for in the aberration corrections applied
#               by this routine.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'abcorr'.
#
#               [1,c5] = size(abcorr), char = class(abcorr)
#
#      obsrvr   name of an observing body. Optionally, you
#               may supply the ID code of the object as an integer
#               string. For example, both 'EARTH' and '399' are
#               legitimate strings to supply to indicate the
#               observer is Earth.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'obsrvr'.
#
#               [1,c6] = size(obsrvr), char = class(obsrvr)
#
#   the call:
#
#      [state, lt] = spkcpt( trgpos, trgctr, trgref, ...
#                                   et,     outref, evlref, ...
#                                   abcorr, obsrvr )
#
#   returns:
#
#      state   state of the target relative to the specified
#              observer. 'state' is corrected for the specified
#              aberrations and is expressed with respect to the
#              reference frame specified by 'outref'. The first three
#              components of 'state' represent the x-, y- and
#              z-components of the target's position; the last three
#              components form the corresponding velocity vector.
#
#              The position component of 'state' points from the
#              observer's location at 'et' to the aberration-corrected
#              location of the target. Note that the sense of the
#              position vector is independent of the direction of
#              radiation travel implied by the aberration
#              correction.
#
#              The velocity component of 'state' is the derivative
#              with respect to time of the position component of
#              'state'.
#
#              Units are always km and km/sec.
#
#              When 'state' is expressed in a time-dependent
#              (non-inertial) output frame, the orientation of that
#              frame relative to the J2000 frame is evaluated in the
#              manner indicated by the input argument 'refloc' (see
#              description above).
#
#              [6,1] = size(state), double = class(state)
#
#      lt      scalar double precision one-way light time between the observer
#              and target in seconds. If the target state is corrected
#              for aberrations, then 'lt' is the one-way light time
#              between the observer and the light time corrected
#              target location.
#
#              [1,1] = size(lt), double = class(lt)
#
#-Particulars
#
#   This routine computes observer-target states for targets whose
#   trajectories are not provided by SPK files.
#
#   Targets supported by this routine must have constant position
#   with respect to a specified center of motion, expressed in a
#   caller-specified reference frame. The state of the center of
#   motion relative to the observer must be computable using
#   loaded SPK data.
#
#   For applications in which the target has non-zero, constant velocity
#   relative to its center of motion, the CSPICE routine
#
#      cspice_spkcvt     { SPK, constant velocity target }
#
#   can be used.
#
#   This routine is suitable for computing states of landmarks on the
#   surface of an extended object, as seen by a specified observer,
#   in cases where no SPK data are available for those landmarks.
#
#   This routine's treatment of the output reference frame differs
#   from that of the principal SPK API routines
#
#      cspice_spkezr
#      cspice_spkpos
#
#   which require both observer and target ephemerides to be provided
#   by loaded SPK files:
#
#      The SPK API routines listed above evaluate the orientation of
#      the output reference frame (with respect to the J2000 frame)
#      at an epoch corrected for one-way light time between the
#      observer and the center of the output frame. When the center
#      of the output frame is not the target (for example, when the
#      target is on the surface of Mars and the output frame is
#      centered at Mars' center), the epoch of evaluation may not
#      closely match the light-time corrected epoch associated with
#      the target itself.
#
#      This routine allows the caller to dictate how the orientation
#      of the output reference frame is to be evaluated. The caller
#      passes to this routine an input string called the output
#      frame's evaluation "locus." This string specifies the location
#      associated with the output frame's evaluation epoch. The three
#      possible values of the locus are
#
#         'TARGET'
#         'OBSERVER'
#         'CENTER'
#
#      The choice of locus has an effect when aberration corrections
#      are used and the output frame is non-inertial.
#
#      When the locus is 'TARGET' and light time corrections are used,
#      the orientation of the output frame is evaluated at the epoch
#      obtained by correcting the observation epoch 'et' for one-way
#      observer-target light time 'lt'. The evaluation epoch will be
#      either et-lt or et+lt for reception or transmission corrections
#      respectively.
#
#      For remote sensing applications where the target is a surface
#      point on an extended object, and the orientation of that
#      object should be evaluated at the emission time, the locus
#      'TARGET' should be used.
#
#      When the output frame's orientation should be evaluated at
#      the observation epoch 'et', which is the case when the
#      output frame is centered at the observer, the locus
#      'OBSERVER' should be used.
#
#      The locus option 'CENTER' is provided for compatibility
#      with existing SPK state computation APIs such as cspice_spkezr.
#
#      Note that the output frame evaluation locus does not affect
#      the computation of light time between the target and
#      observer.
#
#
#   The SPK routines that compute observer-target states for
#   combinations of objects having ephemerides provided by SPK files and
#   objects having constant position or constant velocity are
#
#      cspice_spkcpo {SPK, Constant position observer}
#      spkcpt {SPK, Constant position target}
#      cspice_spkcvo {SPK, Constant velocity observer}
#      cspice_spkcvt {SPK, Constant velocity target}
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkcpt_c.
#
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # spkcpt
#       (state::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        lt::Float64) =   # Ptr{SpiceDouble}
        spkcpt(
            trgpos::Array{Float64,1}, # Array_3_ConstSpiceDouble
            trgctr::AbstractString, # Ptr{ConstSpiceChar}
            trgref::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            outref::AbstractString, # Ptr{ConstSpiceChar}
            refloc::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
        if length(trgpos) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        lt = Array{Float64}(1);  # Ptr{SpiceDouble}
        lt_ptr = pointer(lt)
        
#       make transposed copies of all input arrays and their pointers
        trgpos_t = trgpos'
        trgpos_ptr = pointer(trgpos_t)
        
#       ccall((:spkcpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_SpiceDouble,Ptr{SpiceDouble}),trgpos,trgctr,trgref,et,outref,refloc,abcorr,obsrvr,state,lt)
        ccall((:spkcpt_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            trgpos_ptr,trgctr,trgref,et,outref,refloc,abcorr,obsrvr,state_ptr,lt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return state, lt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#
#      KPL/MK
#
#         File name: spkcpo.tm
#
#         This is the meta-kernel file for the header code example for
#         the subroutine cspice_spkcvo. These kernel files can be found on
#         the NAIF website.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                        Contents
#            ---------                        --------
#            de421.bsp                        Planetary ephemeris
#            pck00010.tpc                     Planet orientation and
#                                             radii
#            naif0010.tls                     Leapseconds
#            earth_720101_070426.bpc          Earth historical
#                                             binary PCK
#            earthstns_itrf93_050714.bsp      DSN station SPK
#            earth_topo_050714.tf             DSN station FK
#            mgs_moc_v20.ti                   MGS MOC instrument
#                                             parameters
#            mgs_sclkscet_00061.tsc           MGS SCLK coefficients
#            mgs_sc_ext12.bc                  MGS s/c bus attitude
#            mgs_ext12_ipng_mgs95j.bsp        MGS ephemeris
#
#         \begindata
#
#         KERNELS_TO_LOAD = ( 'de421.bsp',
#                             'pck00010.tpc',
#                             'naif0010.tls',
#                             'earth_720101_070426.bpc',
#                             'earthstns_itrf93_050714.bsp',
#                             'earth_topo_050714.tf',
#                             'mgs_moc_v20.ti',
#                             'mgs_sclkscet_00061.tsc',
#                             'mgs_sc_ext12.bc',
#                             'mgs_ext12_ipng_mgs95j.bsp'  )
#
#         \begintext
#
#   Example:
#
#      %
#      % Program spkcpt_t
#      %
#      %
#      % This program demonstrates the use of spkcpt.
#      % Computations are performed using all three possible
#      % values of the output frame evaluation locus `refloc':
#      %
#      % 'TARGET';
#      % 'OBSERVER';
#      % 'CENTER';
#      %
#      % Several unrelated computations are performed in this
#      % program. In particular, computations involving a surface
#      % point on Mars are included simply to demonstrate use of
#      % the 'OBSERVER' option.
#      %
#
#      %
#      % Local constants
#      %
#      CAMERA =  'MGS_MOC_NA';
#      MAXBND =  100;
#      META   =  'spkcpt.tm';
#      TIMFMT =  'YYYY MON DD HR:MN:SC.###### UTC';
#
#      %
#      % Load SPICE kernels.
#      %
#      cspice_furnsh( META )
#
#      %
#      % Convert the observation time to seconds past J2000 TDB.
#      %
#      obstim = '2003 OCT 13 06:00:00.000000 UTC';
#
#      et = cspice_str2et( obstim );
#
#      %
#      % Set the observer, target center, and target frame.
#      %
#      obsrvr = 'MGS';
#      trgctr = 'EARTH';
#      trgref = 'ITRF93';
#
#      %
#      % Set the state of DSS-14 relative to the earth's
#      % center at the J2000 epoch, expressed in the
#      % ITRF93 reference frame. Values come from the
#      % earth station SPK specified in the meta-kernel.
#      %
#      % The actual station velocity is non-zero due
#      % to tectonic plate motion; we ignore the motion
#      % in this example. See the routine cspice_spkcvt for an
#      % example in which the plate motion is accounted for.
#      %
#      trgpos = [ -2353.6213656676991, ...
#                 -4641.3414911499403, ...
#                  3677.0523293197439 ]';
#
#      %
#      % Find the apparent state of the station relative
#      % to the spacecraft in the ITRF93 reference frame.
#      % Evaluate the earth's orientation, that is the
#      % orientation of the ITRF93 frame relative to the
#      % J2000 frame, at the epoch obtained by correcting
#      % the observation time for one-way light time. This
#      % correction is obtained by setting `refloc' to 'TARGET'.
#      %
#      outref = 'ITRF93';
#      abcorr = 'CN+S';
#      refloc = 'TARGET';
#
#      %
#      % Compute the observer-target state.
#      %
#      [state0, lt0] = spkcpt( trgpos, trgctr, trgref, ...
#                                     et,     outref, refloc, ...
#                                     abcorr, obsrvr );
#
#      %
#      % Display the computed state and light time.
#      %
#      emitim = cspice_timout( et-lt0, TIMFMT );
#
#      fprintf( ' Frame evaluation locus:   %s\n\n', refloc )
#
#      fprintf( ' Observer:                 %s\n', obsrvr )
#      fprintf( ' Observation time:         %s\n', obstim )
#      fprintf( ' Target center:            %s\n', trgctr )
#      fprintf( ' Target frame:             %s\n', trgref )
#      fprintf( ' Emission time:            %s\n', emitim )
#      fprintf( ' Output reference frame:   %s\n', outref )
#      fprintf( ' Aberration correction:    %s\n\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt0 )
#
#      %
#      % Repeat the computation, this time evaluating the
#      % earth's orientation at the epoch obtained by
#      % subtracting from the observation time the one way
#      % light time from the earth's center.
#      %
#      % This is equivalent to looking up the observer-target
#      % state using cspice_spkezr.
#      %
#      refloc = 'CENTER';
#
#      [state, lt] = spkcpt( trgpos, trgctr, trgref, ...
#                                     et,     outref, refloc, ...
#                                     abcorr, obsrvr );
#
#      %
#      % Display the computed state and light time.
#      %
#      emitim = cspice_timout( et-lt1, TIMFMT );
#
#      fprintf( ' Frame evaluation locus:   %s\n\n', refloc )
#
#      fprintf( ' Observer:                 %s\n', obsrvr )
#      fprintf( ' Observation time:         %s\n', obstim )
#      fprintf( ' Target center:            %s\n', trgctr )
#      fprintf( ' Target frame:             %s\n', trgref )
#      fprintf( ' Emission time:            %s\n', emitim )
#      fprintf( ' Output reference frame:   %s\n', outref )
#      fprintf( ' Aberration correction:    %s\n\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state1(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state1(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt1 )
#
#      fprintf( ' Distance between above positions (km): %20.8f\n', ...
#                         cspice_vdist( state0(1:3), state1(1:3) ) )
#      fprintf( ' Velocity difference magnitude  (km/s): %20.8f\n\n', ...
#                         cspice_vdist( state0(4:6), state1(4:6) ) )
#
#      %
#      % Check: compare the state computed directly above
#      % to one produced by cspice_spkezr:
#      %
#      target = 'DSS-14';
#
#      [state2,  lt2] = cspice_spkezr( target, et, outref, abcorr, obsrvr );
#
#      fprintf( ' State computed using cspice_spkezr:\n\n' )
#
#      fprintf( ' Observer:               %s\n', obsrvr )
#      fprintf( ' Observation time:       %s\n', obstim )
#      fprintf( ' Target:                 %s\n', target )
#      fprintf( ' Output reference frame: %s\n', outref )
#      fprintf( ' Aberration correction:  %s\n\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state2(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state2(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt2 )
#
#      fprintf( ' Distance between last two positions (km): %20.8f\n', ...
#                         cspice_vdist( state1(1:3), state2(1:3) ) )
#      fprintf( ' Velocity difference magnitude  (km/s): %20.8f\n\n', ...
#                         cspice_vdist( state1(4:6), state2(4:6) ) )
#
#      %
#      % Finally, compute an observer-target state in
#      % a frame centered at the observer.
#      % The reference frame will be that of the
#      % MGS MOC NA camera.
#      %
#      % In this case we'll use as the target the surface
#      % intercept on Mars of the camera boresight. This
#      % allows us to easily verify the correctness of
#      % the results returned by spkcpt.
#      %
#      % Get camera frame and FOV parameters. We'll need
#      % the camera ID code first.
#      %
#      [camid, found] = cspice_bodn2c( CAMERA );
#
#      if ( ~found )
#         error( 'Camera name could not be mapped to an ID code.' )
#      end
#
#      %
#      % cspice_getfov will return the name of the camera-fixed frame
#      % in the string `camref', the camera boresight vector in
#      % the array `bsight', and the FOV corner vectors in the
#      % array `bounds'. All we're going to use are the camera
#      % frame name and camera boresight.
#      %
#      [shape, camref, bsight, bounds] = cspice_getfov( camid, MAXBND );
#
#      %
#      % Find the camera boresight surface intercept.
#      %
#
#      trgctr = 'MARS';
#      trgref = 'IAU_MARS';
#
#      [spoint, trgepc, srfvec, found] = cspice_sincpt( 'Ellipsoid', ...
#                                            trgctr, et,     trgref, ...
#                                            abcorr, obsrvr, camref, ...
#                                            bsight );
#
#      outref = camref;
#
#      refloc = 'OBSERVER';
#
#      [state3, lt3] = spkcpt( spoint, trgctr, trgref, ...
#                                 et, outref, refloc, abcorr, ...
#                                 obsrvr );
#
#      %
#      % Convert the emission time and the target state
#      % evaluation epoch to strings for output.
#      %
#      emitim = cspice_timout( et-lt3, TIMFMT );
#
#      fprintf( ' Frame evaluation locus:   %s\n\n', refloc )
#
#      fprintf( ' Observer:                 %s\n', obsrvr )
#      fprintf( ' Observation time:         %s\n', obstim )
#      fprintf( ' Target center:            %s\n', trgctr )
#      fprintf( ' Target frame:             %s\n', trgref )
#      fprintf( ' Emission time:            %s\n', emitim )
#      fprintf( ' Output reference frame:   %s\n', outref )
#      fprintf( ' Aberration correction:    %s\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state3(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state3(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n', lt3 )
#
#      fprintf( ' Target range from cspice_sincpt (km): %20.8f\n', ...
#                                         cspice_vnorm( srfvec ) )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Frame evaluation locus:   TARGET
#
#      Observer:                 MGS
#      Observation time:         2003 OCT 13 06:00:00.000000 UTC
#      Target center:            EARTH
#      Target frame:             ITRF93
#      Emission time:            2003 OCT 13 05:55:44.232914 UTC
#      Output reference frame:   ITRF93
#      Aberration correction:    CN+S
#
#      Observer-target position (km):
#        52746468.84243592    52367725.79653772    18836142.68957234
#      Observer-target velocity (km/s):
#            3823.39593314       -3840.60002121           2.21337692
#      Light time (s):                255.76708533
#
#      Frame evaluation locus:   CENTER
#
#      Observer:                 MGS
#      Observation time:         2003 OCT 13 06:00:00.000000 UTC
#      Target center:            EARTH
#      Target frame:             ITRF93
#      Emission time:            2003 OCT 13 05:55:44.232914 UTC
#      Output reference frame:   ITRF93
#      Aberration correction:    CN+S
#
#      Observer-target position (km):
#        52746419.34648802    52367775.65036674    18836142.68969753
#      Observer-target velocity (km/s):
#            3823.40103499       -3840.59789000           2.21337692
#      Light time (s):                255.76708533
#
#      Distance between above positions (km):          70.25135676
#      Velocity difference magnitude  (km/s):           0.00552910
#
#      State computed using cspice_spkezr:
#
#      Observer:               MGS
#      Observation time:       2003 OCT 13 06:00:00.000000 UTC
#      Target:                 DSS-14
#      Output reference frame: ITRF93
#      Aberration correction:  CN+S
#
#      Observer-target position (km):
#        52746419.34641990    52367775.65039122    18836142.68968301
#      Observer-target velocity (km/s):
#            3823.40103499       -3840.59789000           2.21337692
#      Light time (s):                255.76708533
#
#      Distance between last two positions (km):           0.00007383
#      Velocity difference magnitude  (km/s):           0.00000000
#
#      Frame evaluation locus:   OBSERVER
#
#      Observer:                 MGS
#      Observation time:         2003 OCT 13 06:00:00.000000 UTC
#      Target center:            MARS
#      Target frame:             IAU_MARS
#      Emission time:            2003 OCT 13 05:59:59.998702 UTC
#      Output reference frame:   MGS_MOC_NA
#      Aberration correction:    CN+S
#      Observer-target position (km):
#               0.00000001          -0.00000001         388.97573572
#      Observer-target velocity (km/s):
#               2.91968665           0.15140014           0.92363513
#      Light time (s):                  0.00129748
#      Target range from cspice_sincpt (km):         388.97573572
#
#-Version
#
#   -Mice Version 1.0.0, 16-APR-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####   #    #   ####
#    #       #    #  #   #   #    #  #    #  #    #
#     ####   #    #  ####    #       #    #  #    #
#         #  #####   #  #    #       #    #  #    #
#    #    #  #       #   #   #    #   #  #   #    #
#     ####   #       #    #   ####     ##     ####
#
#   state relative to constant_velocity_observer
#   state relative to constant_velocity surface_point
#   state relative to surface_point on extended_object
#   state relative to landmark on extended_object
#
################################################################################
#-Abstract
#
#   spkcvo returns the state of a specified target relative to an
#   "observer," where the observer has constant velocity in a specified
#   reference frame. The observer's state is provided by the calling
#   program rather than by loaded SPK files.
#
#-I/O
#
#   Given:
#
#      target   name of a target body. Optionally, you may supply
#               the ID code of the object as an integer string. For
#               example, both 'EARTH' and '399' are legitimate strings
#               to supply to indicate the target is earth.
#
#               Case and leading and trailing blanks are not significant
#               in the string 'target'.
#
#               [1,c1] = size(target), char = class(target)
#
#                  or
#
#               [1,1] = size(target); cell = class(target)
#
#      et       ephemeris time at which the state of the
#               target relative to the observer is to be computed. 'et' is
#               expressed as seconds past J2000 TDB. 'et' refers to time
#               at the observer's location.
#
#               'et' is independent of the observer epoch 'obsepc'.
#
#               [1,1] = size(et), double = class(et)
#
#      outref   name of the reference frame with respect to which
#               the output state is expressed.
#
#               When 'outref' is time-dependent (non-inertial), its
#               orientation relative to the J2000 frame is evaluated in
#               the manner commanded by the input argument 'refloc' (see
#               description below).
#
#               Case and leading and trailing blanks are not significant
#               in the string 'outref'.
#
#               [1,c2] = size(outref), char = class(outref)
#
#                  or
#
#               [1,1] = size(outref); cell = class(outref)
#
#     refloc    name indicating the output reference frame
#               evaluation locus: this is the location associated
#               with the epoch at which this routine is to evaluate
#               the orientation, relative to the J2000 frame, of the
#               output frame 'outref'. The values and meanings of
#               'refloc' are:
#
#                  'OBSERVER'  Evaluate 'outref' at the observer's
#                              epoch 'et'.
#
#                              Normally the locus 'OBSERVER' should
#                              be selected when 'outref' is centered
#                              at the observer.
#
#
#                  'TARGET'    Evaluate 'outref' at the target epoch;
#                              letting 'lt' be the one-way light time
#                              between the target and observer, the
#                              target epoch is
#
#                                 et-lt  if reception aberration
#                                        corrections are used
#
#                                 et+lt  if transmission aberration
#                                        corrections are used
#
#                                 et     if no aberration corrections
#                                        are used
#
#                              Normally the locus 'TARGET' should
#                              be selected when 'outref' is centered
#                              at the target object.
#
#
#                  'CENTER'    Evaluate the frame 'outref' at the epoch
#                              associated its center. This epoch,
#                              which we'll call 'etctr', is determined
#                              as follows:
#
#                                 Let 'ltctr' be the one-way light time
#                                 between the observer and the center
#                                 of 'outref'. Then 'etctr' is
#
#                                    et-ltctr  if reception
#                                              aberration corrections
#                                              are used
#
#                                    et+ltctr  if transmission
#                                              aberration corrections
#                                              are used
#
#                                    et        if no aberration
#                                              corrections are used
#
#
#                              The locus 'CENTER' should be selected
#                              when the user intends to obtain
#                              results compatible with those produced
#                              by cspice_spkezr.
#
#               When 'outref' is inertial, all choices of 'refloc'
#               yield the same results.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'refloc'.
#
#               [1,c3] = size(refloc), char = class(refloc)
#
#                  or
#
#               [1,1] = size(refloc); cell = class(refloc)
#
#      abcorr   name indicating the aberration corrections to be
#               applied to the observer-target state to account for one-way
#               light time and stellar aberration.
#
#               'abcorr' may be any of the following:
#
#                  'NONE'     Apply no correction. Return the
#                             geometric state of the target
#                             relative to the observer.
#
#               The following values of 'abcorr' apply to the
#               "reception" case in which photons depart from the
#               target's location at the light-time corrected epoch
#               et-lt and *arrive* at the observer's location at 'et':
#
#                  'LT'       Correct for one-way light time (also
#                             called "planetary aberration") using a
#                             Newtonian formulation. This correction
#                             yields the state of the target at the
#                             moment it emitted photons arriving at
#                             the observer at 'et'.
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             'LT' option uses one iteration.
#
#                  'LT+S'     Correct for one-way light time and
#                             stellar aberration using a Newtonian
#                             formulation. This option modifies the
#                             state obtained with the 'LT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The result is the apparent
#                             state of the target---the position and
#                             velocity of the target as seen by the
#                             observer.
#
#                  'CN'       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the 'CN' correction iterates
#                             until the solution converges.
#
#                  'CN+S'     Converged Newtonian light time
#                             and stellar aberration corrections.
#
#
#               The following values of 'abcorr' apply to the
#               "transmission" case in which photons *depart* from
#               the observer's location at 'et' and arrive at the
#               target's location at the light-time corrected epoch
#               et+lt:
#
#                  'XLT'      "Transmission" case:  correct for
#                             one-way light time using a Newtonian
#                             formulation. This correction yields the
#                             state of the target at the moment it
#                             receives photons emitted from the
#                             observer's location at 'et'.
#
#                  'XLT+S'    "Transmission" case:  correct for
#                             one-way light time and stellar
#                             aberration using a Newtonian
#                             formulation  This option modifies the
#                             state obtained with the 'XLT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The position component of
#                             the computed target state indicates the
#                             direction that photons emitted from the
#                             observer's location must be "aimed" to
#                             hit the target.
#
#                  'XCN'      "Transmission" case:  converged
#                             Newtonian light time correction.
#
#                  'XCN+S'    "Transmission" case:  converged
#                             Newtonian light time and stellar
#                             aberration corrections.
#
#
#               Neither special nor general relativistic effects are
#               accounted for in the aberration corrections applied
#               by this routine.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'abcorr'.
#
#               [1,c4] = size(abcorr), char = class(abcorr)
#
#                  or
#
#               [1,1] = size(abcorr); cell = class(abcorr)
#
#      obssta   geometric state of an observer moving at constant velocity
#               relative to its center of motion 'obsctr', expressed in the
#               reference frame 'obsref', at the epoch 'obsepc'.
#
#               'obssta' is a six-dimensional vector representing
#               position and velocity in Cartesian coordinates: the
#               first three components represent the position of an
#               observer relative to its center of motion; the last
#               three components represent the velocity of the
#               observer.
#
#               Units are always km and km/sec.
#
#               [6,1] = size(obssta), double = class(obssta)
#
#      obsepc   epoch expressed as seconds past J2000 TDB, at which the
#               observer state 'obssta' is applicable. For other epochs,
#               the position of the observer relative
#               to its center of motion is linearly extrapolated
#               using the velocity component of 'obssta'.
#
#               'obsepc' is independent of the epoch 'et' at which the
#               state of the target relative to the observer is to be
#               computed.
#
#               [1,1] = size(obsepc), double = class(obsepc)
#
#      obsctr   name of the center of motion of 'obssta'. The
#               ephemeris of 'obsctr' is provided by loaded SPK files.
#
#               Optionally, you may supply the integer ID code for
#               the object as an integer string. For example both
#               'MOON' and '301' are legitimate strings that indicate
#               the moon is the center of motion.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'obsctr'.
#
#               [1,c5] = size(obsctr), char = class(obsctr)
#
#                  or
#
#               [1,1] = size(obsref); cell = class(obsctr)
#
#      obsref   name of the reference frame relative to which
#               the input state 'obssta' is expressed. The observer has
#               constant velocity relative to its center of motion
#               in this reference frame.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'obsref'.
#
#               [1,c6] = size(obsref), char = class(obsref)
#
#                  or
#
#               [1,1] = size(obsref); cell = class(obsref)
#
#   the call:
#
#      [state, lt] = spkcvo( target, et,     outref, ...
#                                   refloc, abcorr, obssta, ...
#                                   obsepc, obsctr, obsref )
#
#   returns:
#
#      state   state of the target relative to the specified
#              observer. 'state' is corrected for the specified
#              aberrations and is expressed with respect to the
#              reference frame specified by 'outref'. The first three
#              components of 'state' represent the x-, y- and
#              z-components of the target's position; the last three
#              components form the corresponding velocity vector.
#
#              The position component of 'state' points from the
#              observer's location at 'et' to the aberration-corrected
#              location of the target. Note that the sense of the
#              position vector is independent of the direction of
#              radiation travel implied by the aberration
#              correction.
#
#              The velocity component of 'state' is the derivative
#              with respect to time of the position component of
#              'state'.
#
#              Units are always km and km/sec.
#
#              When 'state' is expressed in a time-dependent
#              (non-inertial) output frame, the orientation of that
#              frame relative to the J2000 frame is evaluated in the
#              manner indicated by the input argument 'refloc' (see
#              description above).
#
#              [6,1] = size(state), double = class(state)
#
#      lt      one-way light time between the observer
#              and target in seconds. If the target state is corrected
#              for aberrations, then 'lt' is the one-way light time
#              between the observer and the light time corrected
#              target location.
#
#              [1,1] = size(lt), double = class(lt)
#
#-Particulars
#
#   This routine computes observer-target states for observers whose
#   trajectories are not provided by SPK files.
#
#   Observers supported by this routine must have constant velocity
#   with respect to a specified center of motion, expressed in a
#   caller-specified reference frame. The state of the center of
#   motion relative to the target must be computable using
#   loaded SPK data.
#
#   For applications in which the observer has zero velocity
#   relative to its center of motion, the CSPICE routine
#
#      cspice_spkcpo     { SPK, constant position observer }
#
#   can be used. cspice_spkcpo has a simpler interface than that
#   of spkcvo.
#
#   This routine is suitable for computing states of target ephemeris
#   objects, as seen from landmarks on the surface of an extended
#   object, in cases where no SPK data are available for those
#   landmarks.
#
#   This routine's treatment of the output reference frame differs
#   from that of the principal SPK API routines
#
#      cspice_spkezr
#      cspice_spkpos
#
#   which require both observer and target ephemerides to be provided
#   by loaded SPK files:
#
#      The SPK API routines listed above evaluate the orientation of the
#      output reference frame (with respect to the J2000 frame) at an
#      epoch corrected for one-way light time between the observer and
#      the center of the output frame. When the center of the output
#      frame is not the target (for example, when the target is on the
#      surface of Mars and the output frame is centered at Mars'
#      center), the epoch of evaluation may not closely match the
#      light-time corrected epoch associated with the target itself. A
#      similar problem may occur when the observer is a surface point on
#      an extended body and the output frame is centered at the body
#      center: the listed routines will correct the orientation of the
#      output frame for one-way light time between the frame center and
#      the observer.
#
#      This routine allows the caller to dictate how the orientation
#      of the output reference frame is to be evaluated. The caller
#      passes to this routine an input string called the output
#      frame's evaluation "locus." This string specifies the location
#      associated with the output frame's evaluation epoch. The three
#      possible values of the locus are
#
#         'TARGET'
#         'OBSERVER'
#         'CENTER'
#
#      The choice of locus has an effect when aberration corrections
#      are used and the output frame is non-inertial.
#
#      When the locus is 'TARGET' and light time corrections are
#      used, the orientation of the output frame is evaluated at the
#      epoch obtained by correcting the observation epoch 'et' for
#      one-way light time 'lt'. The evaluation epoch will be either
#      et-lt or et+lt for reception or transmission corrections
#      respectively.
#
#      For remote sensing applications where the target is a surface
#      point on an extended object, and the orientation of that
#      object should be evaluated at the emission time, the locus
#      'TARGET' should be used.
#
#      When the output frame's orientation should be evaluated at
#      the observation epoch 'et', which is the case when the
#      output frame is centered at the observer, the locus
#      'OBSERVER' should be used.
#
#      The locus option 'CENTER' is provided for compatibility
#      with existing SPK state computation APIs such as cspice_spkezr.
#
#      Note that the output frame evaluation locus does not affect
#      the computation of light time between the target and
#      observer.
#
#
#   The SPK routines that compute observer-target states for
#   combinations of objects having ephemerides provided by the SPK
#   system and objects having constant position or constant velocity
#   are
#
#      cspice_spkcpo {SPK, Constant position observer}
#      cspice_spkcpt {SPK, Constant position target}
#      spkcvo {SPK, Constant velocity observer}
#      cspice_spkcvt {SPK, Constant velocity target}
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkcvo_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # spkcvo
#       (state::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        lt::Float64) =   # Ptr{SpiceDouble}
        spkcvo(
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            outref::AbstractString, # Ptr{ConstSpiceChar}
            refloc::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obssta::Array{Float64,1}, # Array_6_ConstSpiceDouble
            obsepc::Float64, # SpiceDouble
            obsctr::AbstractString, # Ptr{ConstSpiceChar}
            obsref::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
        if length(obssta) != 6
            error("Incorrect size for parameter 6")
        end
#       allocate the output parameters
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        lt = Array{Float64}(1);  # Ptr{SpiceDouble}
        lt_ptr = pointer(lt)
        
#       make transposed copies of all input arrays and their pointers
        obssta_t = obssta'
        obssta_ptr = pointer(obssta_t)
        
#       ccall((:spkcvo_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_ConstSpiceDouble,SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_SpiceDouble,Ptr{SpiceDouble}),target,et,outref,refloc,abcorr,obssta,obsepc,obsctr,obsref,state,lt)
        ccall((:spkcvo_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            target,et,outref,refloc,abcorr,obssta_ptr,obsepc,obsctr,obsref,state_ptr,lt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return state, lt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#
#      KPL/MK
#
#         File name: spkcvo.tm
#
#         This is the meta-kernel file for the header code example for
#         the subroutine spkcvo. These kernel files can be found on
#         the NAIF website.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                        Contents
#            ---------                        --------
#            de421.bsp                        Planetary ephemeris
#            pck00010.tpc                     Planet orientation and
#                                             radii
#            naif0010.tls                     Leapseconds
#            earth_720101_070426.bpc          Earth historical
#                                             binary PCK
#            earthstns_itrf93_050714.bsp      DSN station SPK
#            earth_topo_050714.tf             DSN station FK
#            mgs_moc_v20.ti                   MGS MOC instrument
#                                             parameters
#            mgs_sclkscet_00061.tsc           MGS SCLK coefficients
#            mgs_sc_ext12.bc                  MGS s/c bus attitude
#            mgs_ext12_ipng_mgs95j.bsp        MGS ephemeris
#
#         \begindata
#
#         KERNELS_TO_LOAD = ( 'de421.bsp',
#                             'pck00010.tpc',
#                             'naif0010.tls',
#                             'earth_720101_070426.bpc',
#                             'earthstns_itrf93_050714.bsp',
#                             'earth_topo_050714.tf',
#                             'mgs_moc_v20.ti',
#                             'mgs_sclkscet_00061.tsc',
#                             'mgs_sc_ext12.bc',
#                             'mgs_ext12_ipng_mgs95j.bsp'  )
#
#         \begintext
#
#   Example:
#
#      %
#      %  Program spkcvo_t
#      %
#      %  This program uses spkcvo to compute solar azimuth
#      %  and elevation at a given surface point on the earth.
#      %
#
#      %
#      % Local constants
#      %
#      META   =  'spkcvo.tm';
#      TIMFMT =  'YYYY MON DD HR:MN:SC.###### UTC';
#      TIMFM2 =  'YYYY MON DD HR:MN:SC.###### TDB ::TDB';
#
#      %
#      % Local variables
#      %
#      z = [0., 0., 1. ]';
#
#      %
#      % Load SPICE kernels.
#      %
#      cspice_furnsh( META )
#
#      %
#      % Convert the observation time to seconds past J2000 TDB.
#      %
#      obstim = '2003 OCT 13 06:00:00.000000 UTC';
#
#      et = cspice_str2et( obstim );
#
#      %
#      % Set the target, observer center, and observer frame.
#      %
#      target = 'SUN';
#      obsctr = 'EARTH';
#      obsref = 'ITRF93';
#
#      %
#      % Set the state of DSS-14 relative to the earth's
#      % center at the J2000 epoch, expressed in the
#      % ITRF93 reference frame. Values come from the
#      % earth station SPK specified in the meta-kernel.
#
#      %
#      % The velocity is non-zero due to tectonic
#      % plate motion.
#      %
#      obsepc    =  0.0;
#
#      obssta =  [ -2353.6213656676991, -4641.3414911499403,  ...
#                   3677.0523293197439, -0.00000000000057086, ...
#                   0.00000000000020549, -0.00000000000012171 ]';
#
#      %
#      % Find the apparent state of the sun relative
#      % to the station in the DSS-14_TOPO reference frame.
#      % Evaluate the output frame's orientation, that is the
#      % orientation of the DSS-14_TOPO frame relative to the
#      % J2000 frame, at the observation epoch. This
#      % correction is obtained by setting `refloc' to
#      % 'OBSERVER'.
#      %
#
#      outref = 'DSS-14_TOPO';
#      abcorr = 'CN+S';
#
#      refloc = 'OBSERVER';
#
#      %
#      % Compute the observer-target state.
#      %
#      [state0, lt0] = spkcvo( target, et,     outref, ...
#                                     refloc, abcorr, obssta, ...
#                                     obsepc, obsctr, obsref );
#
#      %
#      % Compute planetocentric coordinates of the
#      % observer-target position in the local
#      % topocentric reference frame DSS-14_TOPO.
#      %
#      [r, lon, lat] = cspice_reclat( state0(1:3) );
#
#      %
#      % Compute solar azimuth. The latitude we've
#      % already computed is the elevation. Express
#      % both angles in degrees.
#      %
#      el =   lat * cspice_dpr;
#      az = - lon * cspice_dpr;
#
#      if ( az < 0. )
#         az = az + 360.;
#      end
#
#      %
#      % Display the computed state, light time. and angles.
#      %
#      emitim = cspice_timout( et-lt0, TIMFMT );
#      epcstr = cspice_timout( obsepc, TIMFM2 );
#
#      fprintf( ' Frame evaluation locus:     %s\n\n', refloc )
#
#      fprintf( ' Target:                     %s\n', target )
#      fprintf( ' Observation time:           %s\n', obstim )
#      fprintf( ' Observer center:            %s\n', obsctr )
#      fprintf( ' Observer-center state time: %s\n', epcstr )
#      fprintf( ' Observer frame:             %s\n', obsref )
#      fprintf( ' Emission time:              %s\n', emitim )
#      fprintf( ' Output reference frame:     %s\n', outref )
#      fprintf( ' Aberration correction:      %s\n\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt0 )
#
#      fprintf( ' Solar azimuth (deg):     %20.8f\n', az )
#      fprintf( ' Solar elevation (deg):   %20.8f\n\n', el )
#
#      %
#      % For an arbitrary surface point, we might not
#      % have a frame kernel available. In this case
#      % we can look up the state in the observer frame
#      % using spkcvo and then convert the state to
#      % the local topocentric frame. We'll first
#      % create the transformation matrix for converting
#      % vectors in the observer frame to the topocentric
#      % frame.
#      %
#      % First step: find the geodetic (planetodetic)
#      % coordinates of the observer. We need the
#      % equatorial radius and flattening coefficient
#      % of the reference ellipsoid.
#      %
#      radii = cspice_bodvrd( 'EARTH', 'RADII', 3 );
#
#      re = radii(1);
#      rp = radii(3);
#
#      f  = ( re - rp ) / re;
#
#      [obslon, obslat, obsalt] = cspice_recgeo( obssta(1:3), re, f );
#
#      %
#      % Find the outward surface normal on the reference
#      % ellipsoid at the observer's longitude and latitude.
#      %
#      normal = cspice_latrec( 1., obslon, obslat );
#
#      %
#      % The topocentric frame has its +Z axis aligned
#      % with NORMAL and its +X axis pointed north.
#      % The north direction is aligned with the component
#      % of the ITRF93 +Z axis orthogonal to the topocentric
#      % +Z axis.
#      %
#      xform = cspice_twovec( normal, 3, z, 1 );
#
#      outref = 'ITRF93';
#      abcorr = 'CN+S';
#
#      refloc = 'OBSERVER';
#
#      %
#      % Compute the observer-target state.
#      %
#      [state1, lt1] = spkcvo( target, et,     outref, ...
#                                     refloc, abcorr, obssta, ...
#                                     obsepc, obsctr, obsref );
#
#      %
#      % Convert the position to the topocentric frame.
#      %
#      topvec = xform * state1(1:3);
#
#      %
#      % Compute azimuth and elevation.
#      %
#      [r, lon, lat] = cspice_reclat( topvec );
#
#      el =   lat * cspice_dpr;
#      az = - lon * cspice_dpr;
#
#      if ( az < 0. )
#         az = az + 360.;
#      end
#
#      fprintf( ' AZ/EL computed without frame kernel:' )
#      fprintf( ' Distance between last two\n'          )
#      fprintf( ' positions (km):   %20.8f\n\n',        ...
#                 cspice_vdist( state0(1:3), topvec )   )
#
#      fprintf( ' Solar azimuth (deg):     %20.8f\n', az )
#      fprintf( ' Solar elevation (deg):   %20.8f\n\n', el )
#
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#       Frame evaluation locus:     OBSERVER
#
#       Target:                     SUN
#       Observation time:           2003 OCT 13 06:00:00.000000 UTC
#       Observer center:            EARTH
#       Observer-center state time: 2000 JAN 01 12:00:00.000000 TDB
#       Observer frame:             ITRF93
#       Emission time:              2003 OCT 13 05:51:42.068322 UTC
#       Output reference frame:     DSS-14_TOPO
#       Aberration correction:      CN+S
#
#       Observer-target position (km):
#         62512272.82076502    58967494.42506485  -122059095.46751761
#       Observer-target velocity (km/s):
#             2475.97326517       -9870.26706232       -3499.90809969
#       Light time (s):                497.93167797
#
#       Solar azimuth (deg):             316.67141599
#       Solar elevation (deg):           -54.85253168
#
#       AZ/EL computed without frame kernel: Distance between last two
#       positions (km):             3.07056969
#
#       Solar azimuth (deg):             316.67141786
#       Solar elevation (deg):           -54.85253216
#
#-Version
#
#   -Mice Version 1.0.0, 11-JUN-2013, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####   #    #   #####
#    #       #    #  #   #   #    #  #    #     #
#     ####   #    #  ####    #       #    #     #
#         #  #####   #  #    #       #    #     #
#    #    #  #       #   #   #    #   #  #      #
#     ####   #       #    #   ####     ##       #
#
#   state of constant_velocity_target
#   state of surface_point on extended_object
#   state of landmark on extended_object
#
################################################################################
#-Abstract
#
#   spkcvt returns the state, relative to a specified observer, of a
#   target having constant velocity in a specified reference frame. The
#   target's state is provided by the calling program rather than by
#   loaded SPK files.
#
#-I/O
#
#   Given:
#
#      trgsta   geometric state of a target moving at constant velocity
#               relative to its center of motion 'trgctr', expressed in
#               the reference frame 'trgref', at the epoch 'trgepc'.
#
#               'trgsta' is a six-dimensional vector representing
#               position and velocity in Cartesian coordinates: the
#               first three components represent the position of a
#               target relative to its center of motion; the last three
#               components represent the velocity of the target.
#
#               Units are always km and km/sec.
#
#               [6,1] = size(trgsta), double = class(trgsta)
#
#      trgepc   epoch, expressed as seconds past J2000 TDB, at which the
#               target state 'trgsta' is applicable. For other epochs, the
#               position of the target relative to its center of motion is
#               linearly extrapolated from the position at 'trgepc' using
#               the velocity component of 'trgsta'.
#
#               'trgepc' is independent of the epoch 'et' at which the
#               state of the target relative to the observer is to be
#               computed.
#
#               [1,1] = size(trgepc), double = class(trgepc)
#
#      trgctr   name of the center of motion of 'trgsta'. The
#               ephemeris of 'trgctr' is provided by loaded SPK files.
#
#               Optionally, you may supply the integer ID code for
#               the object as an integer string. For example both
#               'MOON' and '301' are legitimate strings that indicate
#               the moon is the center of motion.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'trgctr'.
#
#               [1,c1] = size(trgctr), char = class(trgctr)
#
#                  or
#
#               [1,1] = size(trgctr); cell = class(trgctr)
#
#      trgref   name of the reference frame relative to which
#               the input state 'trgsta' is expressed. The target has
#               constant velocity relative to its center of motion
#               in this reference frame.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'trgref'.
#
#               [1,c2] = size(trgref), char = class(trgref)
#
#                  or
#
#               [1,1] = size(trgref); cell = class(trgref)
#
#      et       ephemeris time at which the state of the
#               target relative to the observer is to be computed. 'et' is
#               expressed as seconds past J2000 TDB. 'et' refers to time
#               at the observer's location.
#
#               'et' is independent of the target epoch 'trgepc'.
#
#               [1,1] = size(et), double = class(et)
#
#      outref   name of the reference frame with respect to which
#               the output state is expressed.
#
#               When 'outref' is time-dependent (non-inertial), its
#               orientation relative to the J2000 frame is evaluated in
#               the manner commanded by the input argument 'refloc' (see
#               description below).
#
#               Case and leading and trailing blanks are not significant
#               in the string 'outref'.
#
#               [1,c3] = size(outref), char = class(outref)
#
#                  or
#
#               [1,1] = size(outref); cell = class(outref)
#
#      refloc   name indicating the output reference frame
#               evaluation locus: this is the location associated
#               with the epoch at which this routine is to evaluate
#               the orientation, relative to the J2000 frame, of the
#               output frame 'outref'. The values and meanings of
#               'refloc' are:
#
#                  'OBSERVER'  Evaluate 'outref' at the observer's
#                              epoch 'et'.
#
#                              Normally the locus 'OBSERVER' should
#                              be selected when 'outref' is centered
#                              at the observer.
#
#
#                  'TARGET'    Evaluate 'outref' at the target epoch;
#                              letting 'ltime' be the one-way light time
#                              between the target and observer, the
#                              target epoch is
#
#                                 et-ltime  if reception aberration
#                                           corrections are used
#
#                                 et+ltime  if transmission aberration
#                                           corrections are used
#
#                                 et        if no aberration corrections
#                                           are used
#
#                              Normally the locus 'TARGET' should
#                              be selected when 'outref' is 'trgref',
#                              the frame in which the target state
#                              is specified.
#
#
#                  'CENTER'    Evaluate the frame 'outref' at the epoch
#                              associated its center. This epoch,
#                              which we'll call 'etctr', is determined
#                              as follows:
#
#                                 Let 'ltctr' be the one-way light time
#                                 between the observer and the center
#                                 of 'outref'. Then 'etctr' is
#
#                                    et-ltctr  if reception
#                                              aberration corrections
#                                              are used
#
#                                    et+ltctr  if transmission
#                                              aberration corrections
#                                              are used
#
#                                    et        if no aberration
#                                              corrections are used
#
#
#                              The locus 'CENTER' should be selected
#                              when the user intends to obtain
#                              results compatible with those produced
#                              by cspice_spkezr.
#
#               When 'outref' is inertial, all choices of 'refloc'
#               yield the same results.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'refloc'.
#
#               [1,c4] = size(refloc), char = class(refloc)
#
#                  or
#
#               [1,1] = size(refloc); cell = class(refloc)
#
#      abcorr   name indicating the aberration corrections to be
#               applied to the observer-target state to account for one-way
#               light time and stellar aberration.
#
#               'abcorr' may be any of the following:
#
#                  'NONE'     Apply no correction. Return the
#                             geometric state of the target
#                             relative to the observer.
#
#               The following values of 'abcorr' apply to the
#               'reception' case in which photons depart from the
#               target's location at the light-time corrected epoch
#               et-ltime and *arrive* at the observer's location at 'et':
#
#                  'LT'       Correct for one-way light time (also
#                             called "planetary aberration") using a
#                             Newtonian formulation. This correction
#                             yields the state of the target at the
#                             moment it emitted photons arriving at
#                             the observer at 'et'.
#
#                             The light time correction uses an
#                             iterative solution of the light time
#                             equation. The solution invoked by the
#                             'LT' option uses one iteration.
#
#                  'LT+S'     Correct for one-way light time and
#                             stellar aberration using a Newtonian
#                             formulation. This option modifies the
#                             state obtained with the 'LT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The result is the apparent
#                             state of the target---the position and
#                             velocity of the target as seen by the
#                             observer.
#
#                  'CN'       Converged Newtonian light time
#                             correction. In solving the light time
#                             equation, the 'CN' correction iterates
#                             until the solution converges.
#
#                  'CN+S'     Converged Newtonian light time
#                             and stellar aberration corrections.
#
#
#               The following values of 'abcorr' apply to the
#               "transmission" case in which photons *depart* from
#               the observer's location at 'et' and arrive at the
#               target's location at the light-time corrected epoch
#               et+ltime:
#
#                  'XLT'      "Transmission" case:  correct for
#                             one-way light time using a Newtonian
#                             formulation. This correction yields the
#                             state of the target at the moment it
#                             receives photons emitted from the
#                             observer's location at 'et'.
#
#                  'XLT+S'    "Transmission" case:  correct for
#                             one-way light time and stellar
#                             aberration using a Newtonian
#                             formulation  This option modifies the
#                             state obtained with the 'XLT' option to
#                             account for the observer's velocity
#                             relative to the solar system
#                             barycenter. The position component of
#                             the computed target state indicates the
#                             direction that photons emitted from the
#                             observer's location must be "aimed" to
#                             hit the target.
#
#                  'XCN'      "Transmission" case:  converged
#                             Newtonian light time correction.
#
#                  'XCN+S'    "Transmission" case:  converged
#                             Newtonian light time and stellar
#                             aberration corrections.
#
#               Neither special nor general relativistic effects are
#               accounted for in the aberration corrections applied
#               by this routine.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'abcorr'.
#
#               [1,c5] = size(abcorr), char = class(abcorr)
#
#                  or
#
#               [1,1] = size(abcorr); cell = class(abcorr)
#
#      obsrvr   name of an observing body. Optionally, you
#               may supply the ID code of the object as an integer
#               string. For example, both 'EARTH' and '399' are
#               legitimate strings to supply to indicate the
#               observer is Earth.
#
#               Case and leading and trailing blanks are not
#               significant in the string 'obsrvr'.
#
#               [1,c6] = size(obsrvr), char = class(obsrvr)
#
#                  or
#
#               [1,1] = size(obsrvr); cell = class(obsrvr)
#
#   the call:
#
#      [state, lt] = spkcvt( trgsta, trgepc, trgctr, ...
#                                   trgref, et,     outref, ...
#                                   evlref, abcorr, obsrvr )
#
#   returns:
#
#      state   state of the target relative to the specified
#              observer. 'state' is corrected for the specified
#              aberrations and is expressed with respect to the
#              reference frame specified by 'outref'. The first three
#              components of 'state' represent the x-, y- and
#              z-components of the target's position; the last three
#              components form the corresponding velocity vector.
#
#              The position component of 'state' points from the
#              observer's location at 'et' to the aberration-corrected
#              location of the target. Note that the sense of the
#              position vector is independent of the direction of
#              radiation travel implied by the aberration
#              correction.
#
#              The velocity component of 'state' is the derivative
#              with respect to time of the position component of
#              'state'.
#
#              Units are always km and km/sec.
#
#              When 'state' is expressed in a time-dependent
#              (non-inertial) output frame, the orientation of that
#              frame relative to the J2000 frame is evaluated in the
#              manner indicated by the input argument 'refloc' (see
#              description above).
#
#              [6,1] = size(state), double = class(state)
#
#      lt      one-way light time between the observer
#              and target in seconds. If the target state is corrected
#              for aberrations, then 'ltime' is the one-way light time
#              between the observer and the light time corrected
#              target location.
#
#              [1,1] = size(lt), double = class(lt)
#
#-Particulars
#
#   This routine computes observer-target states for targets whose
#   trajectories are not provided by SPK files.
#
#   Targets supported by this routine must have constant velocity
#   with respect to a specified center of motion, expressed in a
#   caller-specified reference frame. The state of the center of
#   motion relative to the observer must be computable using
#   loaded SPK data.
#
#   For applications in which the target has zero velocity
#   relative to its center of motion, the CSPICE routine
#
#      cspice_spkcpt     { SPK, constant position target }
#
#   can be used. cspice_spkcpt has a simpler interface than that
#   of spkcvt.
#
#   This routine is suitable for computing states of landmarks on the
#   surface of an extended object, as seen by a specified observer,
#   in cases where no SPK data are available for those landmarks.
#
#   This routine's treatment of the output reference frame differs
#   from that of the principal SPK API routines
#
#      cspice_spkezr
#      cspice_spkpos
#
#   which require both observer and target ephemerides to be provided
#   by loaded SPK files:
#
#      The SPK API routines listed above evaluate the orientation of
#      the output reference frame (with respect to the J2000 frame)
#      at an epoch corrected for one-way light time between the
#      observer and the center of the output frame. When the center
#      of the output frame is not the target (for example, when the
#      target is on the surface of Mars and the output frame is
#      centered at Mars' center), the epoch of evaluation may not
#      closely match the light-time corrected epoch associated with
#      the target itself.
#
#      This routine allows the caller to dictate how the orientation
#      of the output reference frame is to be evaluated. The caller
#      passes to this routine an input string called the output
#      frame's evaluation "locus." This string specifies the location
#      associated with the output frame's evaluation epoch. The three
#      possible values of the locus are
#
#         'TARGET'
#         'OBSERVER'
#         'CENTER'
#
#      The choice of locus has an effect when aberration corrections
#      are used and the output frame is non-inertial.
#
#      When the locus is 'TARGET' and light time corrections are used,
#      the orientation of the output frame is evaluated at the epoch
#      obtained by correcting the observation epoch 'et' for one-way
#      observer-target light time 'ltime'. The evaluation epoch will be
#      either et-ltime or et+ltime for reception or transmission corrections
#      respectively.
#
#      For remote sensing applications where the target is a surface
#      point on an extended object, and the orientation of that
#      object should be evaluated at the emission time, the locus
#      'TARGET' should be used.
#
#      When the output frame's orientation should be evaluated at
#      the observation epoch 'et', which is the case when the
#      output frame is centered at the observer, the locus
#      'OBSERVER' should be used.
#
#      The locus option 'CENTER' is provided for compatibility
#      with existing SPK state computation APIs such as cspice_spkezr.
#
#      Note that the output frame evaluation locus does not affect
#      the computation of light time between the target and
#      observer.
#
#
#   The SPK routines that compute observer-target states for
#   combinations of objects having ephemerides provided by SPK files and
#   objects having constant position or constant velocity are
#
#      cspice_spkcpo {SPK, Constant position observer}
#      cspice_spkcpt {SPK, Constant position target}
#      cspice_spkcvo {SPK, Constant velocity observer}
#      spkcvt {SPK, Constant velocity target}
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkcvt_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # spkcvt
#       (state::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        lt::Float64) =   # Ptr{SpiceDouble}
        spkcvt(
            trgsta::Array{Float64,1}, # Array_6_ConstSpiceDouble
            trgepc::Float64, # SpiceDouble
            trgctr::AbstractString, # Ptr{ConstSpiceChar}
            trgref::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            outref::AbstractString, # Ptr{ConstSpiceChar}
            refloc::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
        if length(trgsta) != 6
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        lt = Array{Float64}(1);  # Ptr{SpiceDouble}
        lt_ptr = pointer(lt)
        
#       make transposed copies of all input arrays and their pointers
        trgsta_t = trgsta'
        trgsta_ptr = pointer(trgsta_t)
        
#       ccall((:spkcvt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_SpiceDouble,Ptr{SpiceDouble}),trgsta,trgepc,trgctr,trgref,et,outref,refloc,abcorr,obsrvr,state,lt)
        ccall((:spkcvt_c,libNasaSpice),Void,
            (Ptr{Float64},Float64,Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            trgsta_ptr,trgepc,trgctr,trgref,et,outref,refloc,abcorr,obsrvr,state_ptr,lt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return state, lt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#
#      KPL/MK
#
#         File name: spkcvt.tm
#
#         This is the meta-kernel file for the header code example for
#         the subroutine cspice_spkcvo. These kernel files can be found on
#         the NAIF website.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                        Contents
#            ---------                        --------
#            de421.bsp                        Planetary ephemeris
#            pck00010.tpc                     Planet orientation and
#                                             radii
#            naif0010.tls                     Leapseconds
#            earth_720101_070426.bpc          Earth historical
#                                             binary PCK
#            earthstns_itrf93_050714.bsp      DSN station SPK
#            earth_topo_050714.tf             DSN station FK
#            mgs_moc_v20.ti                   MGS MOC instrument
#                                             parameters
#            mgs_sclkscet_00061.tsc           MGS SCLK coefficients
#            mgs_sc_ext12.bc                  MGS s/c bus attitude
#            mgs_ext12_ipng_mgs95j.bsp        MGS ephemeris
#
#         \begindata
#
#         KERNELS_TO_LOAD = ( 'de421.bsp',
#                             'pck00010.tpc',
#                             'naif0010.tls',
#                             'earth_720101_070426.bpc',
#                             'earthstns_itrf93_050714.bsp',
#                             'earth_topo_050714.tf',
#                             'mgs_moc_v20.ti',
#                             'mgs_sclkscet_00061.tsc',
#                             'mgs_sc_ext12.bc',
#                             'mgs_ext12_ipng_mgs95j.bsp'  )
#
#         \begintext
#
#   Example:
#
#      %
#      % Program spkcvt_ex1
#      %
#      %
#      % This program demonstrates the use of spkcvt.
#      % Computations are performed using all three possible
#      % values of the output frame evaluation locus `refloc':
#      %
#      % 'TARGET'
#      % 'OBSERVER'
#      % 'CENTER'
#      %
#      % Several unrelated computations are performed in this
#      % program. In particular, computations involving a surface
#      % point on Mars are included simply to demonstrate use of
#      % the 'OBSERVER' option.
#
#      %
#      % Local constants
#      %
#
#      CAMERA =  'MGS_MOC_NA';
#      MAXBND =  100;
#      META   =  'spkcvt.tm';
#      TIMFMT =  'YYYY MON DD HR:MN:SC.###### UTC';
#      TIMFM2 =  'YYYY MON DD HR:MN:SC.###### TDB ::TDB';
#
#      %
#      % Load SPICE kernels.
#      %
#      cspice_furnsh( META )
#
#      %
#      % Convert the observation time to seconds past J2000 TDB.
#      %
#      obstim = '2003 OCT 13 06:00:00.000000 UTC';
#
#      et = cspice_str2et( obstim );
#
#      %
#      % Set the observer, target center, and target frame.
#      %
#      obsrvr = 'MGS';
#      trgctr = 'EARTH';
#      trgref = 'ITRF93';
#
#      %
#      % Set the state of DSS-14 relative to the earth's
#      % center at the J2000 epoch, expressed in the
#      % ITRF93 reference frame. Values come from the
#      % earth station SPK specified in the meta-kernel.
#      %
#      % The velocity is non-zero due to tectonic
#      % plate motion.
#
#      trgepc =  0.0;
#
#      trgsta = [ -2353.6213656676991, -4641.3414911499403,  ...
#                 3677.0523293197439,  -0.00000000000057086, ...
#                 0.00000000000020549, -0.00000000000012171 ]';
#
#      %
#      % Find the apparent state of the station relative
#      % to the spacecraft in the ITRF93 reference frame.
#      % Evaluate the earth's orientation, that is the
#      % orientation of the ITRF93 frame relative to the
#      % J2000 frame, at the epoch obtained by correcting
#      % the observation time for one-way light time. This
#      % correction is obtained by setting `refloc' to 'TARGET'.
#      %
#      outref = 'ITRF93';
#      abcorr = 'CN+S';
#
#      refloc = 'TARGET';
#
#      %
#      % Compute the observer-target state.
#      %
#      [state0, lt0] = spkcvt( trgsta, trgepc, trgctr, trgref, ...
#                                     et,     outref, refloc, abcorr, ...
#                                     obsrvr );
#
#      %
#      % Display the computed state and light time.
#      %
#      emitim = cspice_timout( et-lt0, TIMFMT );
#      trgtim = cspice_timout( trgepc, TIMFM2 );
#
#      fprintf( ' Frame evaluation locus:   %s\n\n', refloc )
#
#      fprintf( ' Observer:                 %s\n', obsrvr )
#      fprintf( ' Observation time:         %s\n', obstim )
#      fprintf( ' Target center:            %s\n', trgctr )
#      fprintf( ' Target-center state time: %s\n', trgtim )
#      fprintf( ' Target frame:             %s\n', trgref )
#      fprintf( ' Emission time:            %s\n', emitim )
#      fprintf( ' Output reference frame:   %s\n', outref )
#      fprintf( ' Aberration correction:    %s\n\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state0(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt0 )
#
#      %
#      % Repeat the computation, this time evaluating the
#      % earth's orientation at the epoch obtained by
#      % subtracting from the observation time the one way
#      % light time from the earth's center.
#      %
#      % This is equivalent to looking up the observer-target
#      % state using cspice_spkezr.
#      %
#      refloc = 'CENTER';
#
#      [state1, lt1] = spkcvt( trgsta, trgepc, trgctr, trgref, ...
#                                     et,     outref, refloc, abcorr, ...
#                                    obsrvr );
#
#      %
#      % Display the computed state and light time.
#      %
#      emitim = cspice_timout( et-lt1, TIMFMT );
#
#      fprintf( '  Frame evaluation locus:   %s\n\n', refloc )
#
#      fprintf( ' Observer:                 %s\n', obsrvr )
#      fprintf( ' Observation time:         %s\n', obstim )
#      fprintf( ' Target center:            %s\n', trgctr )
#      fprintf( ' Target-center state time: %s\n', trgtim )
#      fprintf( ' Target frame:             %s\n', trgref )
#      fprintf( ' Emission time:            %s\n', emitim )
#      fprintf( ' Output reference frame:   %s\n', outref )
#      fprintf( ' Aberration correction:    %s\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state1(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state1(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt1 )
#
#      fprintf( ' Distance between above positions (km): %20.8f\n', ...
#                         cspice_vdist( state0(1:3), state1(1:3) ) )
#      fprintf( ' Velocity difference magnitude  (km/s): %20.8f\n\n', ...
#                         cspice_vdist( state0(4:6), state1(4:6) ) )
#
#      %
#      % Check: compare the state computed directly above
#      % to one produced by cspice_spkezr:
#      %
#      target = 'DSS-14';
#
#      [state2, lt2] = cspice_spkezr( target,  et, outref,  abcorr, ...
#                                     obsrvr );
#
#      fprintf( ' State computed using cspice_spkezr:\n\n' )
#
#      fprintf( ' Observer:               %s\n', obsrvr )
#      fprintf( ' Observation time:       %s\n', obstim )
#      fprintf( ' Target:                 %s\n', target )
#      fprintf( ' Output reference frame: %s\n', outref )
#      fprintf( ' Aberration correction:  %s\n\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state2(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state2(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n\n', lt2 )
#
#      fprintf( ' Distance between last two positions (km): %20.8f\n', ...
#                         cspice_vdist( state1(1:3), state2(1:3) ) )
#      fprintf( ' Velocity difference magnitude  (km/s): %20.8f\n\n', ...
#                         cspice_vdist( state1(4:6), state2(4:6) ) )
#
#      %
#      % Finally, compute an observer-target state in
#      % a frame centered at the observer.
#      % The reference frame will be that of the
#      % MGS MOC NA camera.
#      %
#      % In this case we'll use as the target the surface
#      % intercept on Mars of the camera boresight. This
#      % allows us to easily verify the correctness of
#      % the results returned by spkcvt.
#      %
#      % Get camera frame and FOV parameters. We'll need
#      % the camera ID code first.
#      %
#      [camid, found] = cspice_bodn2c( CAMERA );
#
#      if ( ~found )
#         error( 'Camera name could not be mapped to an ID code.' )
#      end
#
#      %
#      % cspice_getfov will return the name of the camera-fixed frame
#      % in the string `camref', the camera boresight vector in
#      % the array `bsight', and the FOV corner vectors in the
#      % array `bounds'. All we're going to use are the camera
#      % frame name and camera boresight.
#      %
#
#      [shape, camref, bsight, bounds] = cspice_getfov( camid, MAXBND );
#
#      %
#      % Find the camera boresight surface intercept.
#      %
#
#      trgctr = 'MARS';
#      trgref = 'IAU_MARS';
#
#      [spoint, trgep2, srfvec, found] = cspice_sincpt( ...
#                               'Ellipsoid', trgctr,    ...
#                               et,     trgref, abcorr, ...
#                               obsrvr, camref, bsight );
#
#      %
#      % Set the position component of the state vector
#      % `trgst2' to `spoint'.
#      %
#      % Set the velocity of the target state to zero.
#      %
#      % Since the velocity is zero, we can pick any value
#      % as the target epoch we choose 0 seconds past
#      % J2000 TDB.
#      %
#      trgst2 = [ spoint; [ 0., 0., 0. ]' ];
#
#      trgepc = 0.;
#      outref = camref;
#
#      refloc = 'OBSERVER';
#
#      [state3, lt3] = spkcvt( trgst2, trgepc, trgctr, trgref, ...
#                                     et,     outref, refloc, abcorr, ...
#                                     obsrvr );
#
#      %
#      % Convert the emission time and the target state
#      % evaluation epoch to strings for output.
#      %
#      emitim = cspice_timout( et-lt3, TIMFMT );
#      trgtim = cspice_timout( trgepc, TIMFM2 );
#
#      %
#      % Convert the emission time and the target state
#      % evaluation epoch to strings for output.
#      %
#      emitim = cspice_timout( et-lt3, TIMFMT );
#
#      fprintf( ' Frame evaluation locus:   %s\n\n', refloc )
#
#      fprintf( ' Observer:                 %s\n', obsrvr )
#      fprintf( ' Observation time:         %s\n', obstim )
#      fprintf( ' Target center:            %s\n', trgctr )
#      fprintf( ' Target-center state time: %s\n', trgtim )
#      fprintf( ' Target frame:             %s\n', trgref )
#      fprintf( ' Emission time:            %s\n', emitim )
#      fprintf( ' Output reference frame:   %s\n', outref )
#      fprintf( ' Aberration correction:    %s\n', abcorr )
#
#      fprintf( ' Observer-target position (km):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state3(1:3) )
#      fprintf( ' Observer-target velocity (km/s):\n' )
#      fprintf( '%20.8f %20.8f %20.8f\n', state3(4:6) )
#      fprintf( ' Light time (s):        %20.8f\n', lt3 )
#
#      fprintf( ' Target range from cspice_sincpt (km): %20.8f\n', ...
#                                         cspice_vnorm( srfvec ) )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Frame evaluation locus:   TARGET
#
#      Observer:                 MGS
#      Observation time:         2003 OCT 13 06:00:00.000000 UTC
#      Target center:            EARTH
#      Target-center state time: 2000 JAN 01 12:00:00.000000 TDB
#      Target frame:             ITRF93
#      Emission time:            2003 OCT 13 05:55:44.232914 UTC
#      Output reference frame:   ITRF93
#      Aberration correction:    CN+S
#
#      Observer-target position (km):
#        52746468.84236781    52367725.79656220    18836142.68955782
#      Observer-target velocity (km/s):
#            3823.39593314       -3840.60002121           2.21337692
#      Light time (s):                255.76708533
#
#       Frame evaluation locus:   CENTER
#
#      Observer:                 MGS
#      Observation time:         2003 OCT 13 06:00:00.000000 UTC
#      Target center:            EARTH
#      Target-center state time: 2000 JAN 01 12:00:00.000000 TDB
#      Target frame:             ITRF93
#      Emission time:            2003 OCT 13 05:55:44.232914 UTC
#      Output reference frame:   ITRF93
#      Aberration correction:    CN+S
#      Observer-target position (km):
#        52746419.34641990    52367775.65039122    18836142.68968301
#      Observer-target velocity (km/s):
#            3823.40103499       -3840.59789000           2.21337692
#      Light time (s):                255.76708533
#
#      Distance between above positions (km):          70.25135676
#      Velocity difference magnitude  (km/s):           0.00552910
#
#      State computed using cspice_spkezr:
#
#      Observer:               MGS
#      Observation time:       2003 OCT 13 06:00:00.000000 UTC
#      Target:                 DSS-14
#      Output reference frame: ITRF93
#      Aberration correction:  CN+S
#
#      Observer-target position (km):
#        52746419.34641990    52367775.65039122    18836142.68968301
#      Observer-target velocity (km/s):
#            3823.40103499       -3840.59789000           2.21337692
#      Light time (s):                255.76708533
#
#      Distance between last two positions (km):           0.00000000
#      Velocity difference magnitude  (km/s):           0.00000000
#
#      Frame evaluation locus:   OBSERVER
#
#      Observer:                 MGS
#      Observation time:         2003 OCT 13 06:00:00.000000 UTC
#      Target center:            MARS
#      Target-center state time: 2000 JAN 01 12:00:00.000000 TDB
#      Target frame:             IAU_MARS
#      Emission time:            2003 OCT 13 05:59:59.998702 UTC
#      Output reference frame:   MGS_MOC_NA
#      Aberration correction:    CN+S
#      Observer-target position (km):
#               0.00000001          -0.00000001         388.97573572
#      Observer-target velocity (km/s):
#               2.91968665           0.15140014           0.92363513
#      Light time (s):                  0.00129748
#      Target range from cspice_sincpt (km):         388.97573572
#
#-Version
#
#   -Mice Version 1.0.0, 11-JUN-2013, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #  ######  ######  #####
#    #       #    #  #   #   #           #   #    #
#     ####   #    #  ####    #####      #    #    #
#         #  #####   #  #    #         #     #####
#    #    #  #       #   #   #        #      #   #
#     ####   #       #    #  ######  ######  #    #
#
#   using body names get target state relative to an observer
#   get state relative to observer corrected for aberrations
#   read ephemeris data
#   read trajectory data
#
################################################################################
#-Abstract
#
#   spkezr returns the state (position and velocity) of
#   a target body relative to an observing body, optionally
#   corrected for light  time (planetary aberration) and stellar
#   aberration.
#
#-I/O
#
#   Given:
#
#      targ      the scalar string name of a target body.
#                Optionally, you may supply the integer ID code
#                for the object as an integer string, i.e. both
#                'MOON' and '301' are legitimate strings that
#                indicate the Moon is the target body.
#
#                The target and observer define a state vector
#                whose position component points from the observer
#                to the target.
#
#                [1,c1] = size(target), char = class(target)
#
#                   or
#
#                [1,1] = size(target); cell = class(target)
#
#      et        the scalar or 1XN-vector of double precision ephemeris epochs,
#                expressed as seconds past J2000 TDB, at which the state of the
#                target body relative to the observer is to be computed,
#                'et' refers to time at the observer's location
#
#                [1,N] = size(et), double = class(et)
#
#      ref       the scalar string name of the reference frame relative
#                to which the output state vector should be
#                expressed. This may be any frame supported by the SPICE
#                system, including built-in frames (documented in the
#                Frames Required Reading) and frames defined by a loaded
#                frame kernel (FK).
#
#                When 'ref' designates a non-inertial frame, the
#                orientation of the frame is evaluated at an epoch
#                dependent on the selected aberration correction.
#
#                [1,c2] = size(target), char = class(target)
#
#                   or
#
#                [1,1] = size(target); cell = class(target)
#
#      abcorr    a scalar string that indicates the aberration corrections
#                to apply to the state of the target body to account
#                for one-way light time and stellar aberration.
#
#                'abcorr' may be any of the following:
#
#                   'NONE'     Apply no correction. Return the
#                              geometric state of the target
#                              body relative to the observer.
#
#                The following values of 'abcorr' apply to the
#                "reception" case in which photons depart from the
#                target's location at the light-time corrected epoch
#                et-lt and *arrive* at the observer's location at
#                'et':
#
#                   'LT'       Correct for one-way light time (also
#                              called "planetary aberration") using a
#                              Newtonian formulation. This correction
#                              yields the state of the target at the
#                              moment it emitted photons arriving at
#                              the observer at 'et'.
#
#                              The light time correction uses an
#                              iterative solution of the light time
#                              equation (see Particulars for details).
#                              The solution invoked by the "LT" option
#                              uses one iteration.
#
#                   'LT+S'     Correct for one-way light time and
#                              stellar aberration using a Newtonian
#                              formulation. This option modifies the
#                              state obtained with the "LT" option to
#                              account for the observer's velocity
#                              relative to the solar system
#                              barycenter. The result is the apparent
#                              state of the target---the position and
#                              velocity of the target as seen by the
#                              observer.
#
#                   'CN'       Converged Newtonian light time correction.
#                              This option produces a solution that is at
#                              least as accurate at that obtainable 
#                              with the 'LT' option. Whether the 'CN' 
#                              solution is substantially more accurate 
#                              depends on the geometry of the 
#                              participating objects and on the 
#                              accuracy of the input data. In all 
#                              cases this routine will execute more 
#                              slowly when a converged solution is 
#                              computed. See the section titled "The 
#                              Computation of Light Time" in the SPK
#                              Required Reading document spk.req for 
#                              details.
#
#                   'CN+S'     Converged Newtonian light time
#                              correction and stellar aberration
#                              correction.
#
#
#                The following values of 'abcorr' apply to the
#                "transmission" case in which photons *depart* from
#                the observer's location at 'et' and arrive at the
#                target's location at the light-time corrected epoch
#                et+lt:
#
#                   'XLT'      "Transmission" case:  correct for
#                              one-way light time using a Newtonian
#                              formulation. This correction yields the
#                              state of the target at the moment it
#                              receives photons emitted from the
#                              observer's location at 'et'.
#
#                   'XLT+S'    "Transmission" case:  correct for
#                              one-way light time and stellar
#                              aberration using a Newtonian
#                              formulation  This option modifies the
#                              state obtained with the "XLT" option to
#                              account for the observer's velocity
#                              relative to the solar system
#                              barycenter. The position component of
#                              the computed target state indicates the
#                              direction that photons emitted from the
#                              observer's location must be "aimed" to
#                              hit the target.
#
#                   'XCN'      "Transmission" case:  converged
#                              Newtonian light time correction.
#
#                   'XCN+S'    "Transmission" case:  converged
#                              Newtonian light time correction and
#                              stellar aberration correction.
#
#
#                Neither special nor general relativistic effects are
#                accounted for in the aberration corrections applied
#                by this routine.
#
#                Neither letter case or embedded blanks are significant
#                in the 'abcorr' string.
#
#                [1,c3] = size(abcorr), char = class(abcorr)
#
#                   or
#
#                [1,1] = size(abcorr); cell = class(abcorr)
#
#      obs       the scalar string name of a observing body.
#                Optionally, you may supply the integer ID code
#                for the object as an integer string, i.e. both
#                'MOON' and '301' are legitimate strings that
#                indicate the Moon is the observing body.
#
#                [1,c4] = size(obs), char = class(obs)
#
#                   or
#
#                [1,1] = size(obs); cell = class(obs)
#
#   the call:
#
#      [state, lt] = spkezr(targ, et, ref, abcorr, obs)
#
#   returns:
#
#      state   a double precision 6x1 array or double precision
#              6xN array representing the state of the target body in
#              kilometers and kilometers-per-second of the target
#              body relative to the specified observer, (the first three
#              components of 'state' represent the x-, y- and
#              z-components of the target's position; the last three
#              components form the corresponding velocity vector)
#
#              [6,N] = size(state), double = class(state)
#
#      lt      the double precision scalar one-way light time or double
#              precision 1xN array of one-way light times between the
#              observer and target in seconds; if the target state
#              is corrected for aberrations, then 'lt' is the
#              one-way light time between the observer and the light
#              time corrected target location
#
#              'state' and 'lt' return with the same vectorization
#               measure (N) as 'et'.
#
#              [1,N] = size(lt), double = class(lt)
#
#-Particulars
#
#   A sister version of this routine exists named mice_spkezr that returns
#   the output arguments as fields in a single structure.
#
#   Aberration corrections 
#   ====================== 
# 
#   In space science or engineering applications one frequently 
#   wishes to know where to point a remote sensing instrument, such 
#   as an optical camera or radio antenna, in order to observe or 
#   otherwise receive radiation from a target. This pointing problem 
#   is complicated by the finite speed of light:  one needs to point 
#   to where the target appears to be as opposed to where it actually 
#   is at the epoch of observation. We use the adjectives 
#   "geometric," "uncorrected," or "true" to refer to an actual 
#   position or state of a target at a specified epoch. When a 
#   geometric position or state vector is modified to reflect how it 
#   appears to an observer, we describe that vector by any of the 
#   terms "apparent," "corrected," "aberration corrected," or "light 
#   time and stellar aberration corrected." The SPICE Toolkit can
#   correct for two phenomena affecting the apparent location of an
#   object:  one-way light time (also called "planetary aberration") and
#   stellar aberration.
#
#   One-way light time
#   ------------------
#
#   Correcting for one-way light time is done by computing, given an
#   observer and observation epoch, where a target was when the observed
#   photons departed the target's location. The vector from the
#   observer to this computed target location is called a "light time
#   corrected" vector. The light time correction depends on the motion
#   of the target relative to the solar system barycenter, but it is
#   independent of the velocity of the observer relative to the solar
#   system barycenter. Relativistic effects such as light bending and
#   gravitational delay are not accounted for in the light time
#   correction performed by this routine.
# 
#   Stellar aberration
#   ------------------
#
#   The velocity of the observer also affects the apparent location 
#   of a target:  photons arriving at the observer are subject to a 
#   "raindrop effect" whereby their velocity relative to the observer 
#   is, using a Newtonian approximation, the photons' velocity 
#   relative to the solar system barycenter minus the velocity of the 
#   observer relative to the solar system barycenter. This effect is 
#   called "stellar aberration."  Stellar aberration is independent 
#   of the velocity of the target. The stellar aberration formula 
#   used by this routine does not include (the much smaller)
#   relativistic effects.
# 
#   Stellar aberration corrections are applied after light time 
#   corrections:  the light time corrected target position vector is  
#   used as an input to the stellar aberration correction. 
# 
#   When light time and stellar aberration corrections are both 
#   applied to a geometric position vector, the resulting position  
#   vector indicates where the target "appears to be" from the 
#   observer's location.  
# 
#   As opposed to computing the apparent position of a target, one 
#   may wish to compute the pointing direction required for 
#   transmission of photons to the target. This also requires correction 
#   of the geometric target position for the effects of light time 
#   and stellar aberration, but in this case the corrections are 
#   computed for radiation traveling *from* the observer to the target. 
#   We will refer to this situation as the "transmission" case.
#
#   The "transmission" light time correction yields the target's 
#   location as it will be when photons emitted from the observer's 
#   location at `et' arrive at the target. The transmission stellar 
#   aberration correction is the inverse of the traditional stellar 
#   aberration correction:  it indicates the direction in which 
#   radiation should be emitted so that, using a Newtonian 
#   approximation, the sum of the velocity of the radiation relative 
#   to the observer and of the observer's velocity, relative to the  
#   solar system barycenter, yields a velocity vector that points in  
#   the direction of the light time corrected position of the target. 
#  
#   One may object to using the term "observer" in the transmission
#   case, in which radiation is emitted from the observer's location.
#   The terminology was retained for consistency with earlier
#   documentation.
# 
#   Below, we indicate the aberration corrections to use for some 
#   common applications: 
# 
#      1) Find the apparent direction of a target for a remote-sensing
#         observation.
#
#            Use 'LT+S' or 'CN+S: apply both light time and stellar 
#            aberration corrections.
#
#         Note that using light time corrections alone ('LT' or 'CN')
#         is generally not a good way to obtain an approximation to
#         an apparent target vector: since light time and stellar
#         aberration corrections often partially cancel each other,
#         it may be more accurate to use no correction at all than to
#         use light time alone.
#
#
#      2) Find the corrected pointing direction to radiate a signal
#         to a target. This computation is often applicable for 
#         implementing communications sessions.
#
#            Use 'XLT+S' or 'XCN+S: apply both light time and stellar 
#            aberration corrections for transmission.
#
#
#      3) Compute the apparent position of a target body relative
#         to a star or other distant object.
#
#            Use 'LT', 'CN', 'LT+S', or 'CN+S' as needed to match the
#            correction applied to the position of the distant
#            object. For example, if a star position is obtained from
#            a catalog, the position vector may not be corrected for
#            stellar aberration. In this case, to find the angular
#            separation of the star and the limb of a planet, the
#            vector from the observer to the planet should be
#            corrected for light time but not stellar aberration.
#
#
#      4) Obtain an uncorrected state vector derived directly from 
#         data in an SPK file.
#
#            Use 'NONE'.
#
#
#      5) Use a geometric state vector as a low-accuracy estimate
#         of the apparent state for an application where execution 
#         speed is critical.
#
#            Use 'NONE'.
#
#
#      6) While this routine cannot perform the relativistic
#         aberration corrections required to compute states
#         with the highest possible accuracy, it can supply the
#         geometric states required as inputs to these computations.
#
#            Use 'NONE', then apply relativistic aberration
#            corrections (not available in the SPICE Toolkit).
#
# 
#   Below, we discuss in more detail how the aberration corrections 
#   applied by this routine are computed.      
# 
#      Geometric case 
#      ============== 
# 
#      spkezr_c begins by computing the geometric position T(et) of the 
#      target body relative to the solar system barycenter (SSB). 
#      Subtracting the geometric position of the observer O(et) gives 
#      the geometric position of the target body relative to the 
#      observer. The one-way light time, lt, is given by 
# 
#                | T(et) - O(et) | 
#         lt = ------------------- 
#                        c 
# 
#      The geometric relationship between the observer, target, and 
#      solar system barycenter is as shown: 
# 
# 
#         SSB ---> O(et) 
#          |      / 
#          |     / 
#          |    /                            
#          |   /  T(et) - O(et)   
#          V  V                                   
#         T(et) 
# 
# 
#      The returned state consists of the position vector 
# 
#         T(et) - O(et) 
# 
#      and a velocity obtained by taking the difference of the 
#      corresponding velocities. In the geometric case, the  
#      returned velocity is actually the time derivative of the  
#      position. 
# 
# 
#      Reception case 
#      ============== 
# 
#      When any of the options "LT", "CN", "LT+S", "CN+S" is selected
#      for `abcorr', spkezr_c computes the position of the target body at
#      epoch et-lt, where `lt' is the one-way light time. Let T(t) and
#      O(t) represent the positions of the target and observer 
#      relative to the solar system barycenter at time t; then `lt' is 
#      the solution of the light-time equation 
# 
#                | T(et-lt) - O(et) | 
#         lt = ------------------------                            (1) 
#                         c 
# 
#      The ratio  
# 
#          | T(et) - O(et) | 
#        ---------------------                                     (2) 
#                  c 
# 
#      is used as a first approximation to `lt'; inserting (2) into the
#      right hand side of the light-time equation (1) yields the
#      "one-iteration" estimate of the one-way light time ("LT").
#      Repeating the process until the estimates of `lt' converge yields
#      the "converged Newtonian" light time estimate ("CN").
#      
#      Subtracting the geometric position of the observer O(et) gives 
#      the position of the target body relative to the observer: 
#      T(et-lt) - O(et). 
# 
#         SSB ---> O(et) 
#          | \     | 
#          |  \    | 
#          |   \   | T(et-lt) - O(et) 
#          |    \  | 
#          V     V V 
#         T(et)  T(et-lt) 
#       
#      The position component of the light time corrected state  
#      is the vector 
# 
#         T(et-lt) - O(et) 
# 
#      The velocity component of the light time corrected state  
#      is the difference 
# 
#         T_vel(et-lt)*(1-d(lt)/d(et)) - O_vel(et) 
#           
#      where T_vel and O_vel are, respectively, the velocities of the 
#      target and observer relative to the solar system barycenter at 
#      the epochs et-lt and `et'.  
#
#      If correction for stellar aberration is requested, the target 
#      position is rotated toward the solar system 
#      barycenter-relative velocity vector of the observer. The 
#      rotation is computed as follows: 
# 
#         Let r be the light time corrected vector from the observer 
#         to the object, and v be the velocity of the observer with 
#         respect to the solar system barycenter. Let w be the angle 
#         between them. The aberration angle phi is given by 
# 
#            sin(phi) = v sin(w) / c 
# 
#         Let h be the vector given by the cross product 
# 
#            h = r X v 
# 
#         Rotate r by phi radians about h to obtain the apparent 
#         position of the object. 
# 
#      When stellar aberration corrections are used, the rate of change
#      of the stellar aberration correction is accounted for in the
#      computation of the output velocity.
# 
# 
#      Transmission case 
#      ================== 
# 
#      When any of the options "XLT", "XCN", "XLT+S", "XCN+S" is 
#      selected, spkezr_c computes the position of the target body T at 
#      epoch et+lt, where `lt' is the one-way light time. `lt' is the 
#      solution of the light-time equation 
# 
#                | T(et+lt) - O(et) | 
#         lt = ------------------------                            (3) 
#                          c 
# 
#      Subtracting the geometric position of the observer, O(et), 
#      gives the position of the target body relative to the 
#      observer: T(et-lt) - O(et). 
# 
#                 SSB --> O(et) 
#                / |    *  
#               /  |  *  T(et+lt) - O(et)   
#              /   |*      
#             /   *|     
#            V  V  V      
#        T(et+lt)  T(et)     
# 
#      The position component of the light-time corrected state  
#      is the vector 
# 
#         T(et+lt) - O(et) 
# 
#      The velocity component of the light-time corrected state  
#      consists of the difference 
# 
#         T_vel(et+lt)*(1+d(lt)/d(et)) - O_vel(et) 
#           
#      where T_vel and O_vel are, respectively, the velocities of the 
#      target and observer relative to the solar system barycenter at 
#      the epochs et+lt and `et'. 
# 
#      If correction for stellar aberration is requested, the target 
#      position is rotated away from the solar system barycenter- 
#      relative velocity vector of the observer. The rotation is 
#      computed as in the reception case, but the sign of the 
#      rotation angle is negated. 
# 
# 
#   Precision of light time corrections 
#   =================================== 
# 
#      Corrections using one iteration of the light time solution 
#      ---------------------------------------------------------- 
# 
#      When the requested aberration correction is "LT", "LT+S", 
#      "XLT", or "XLT+S", only one iteration is performed in the 
#      algorithm used to compute lt. 
# 
#      The relative error in this computation 
# 
#         | LT_ACTUAL - LT_COMPUTED |  /  LT_ACTUAL 
# 
#      is at most  
# 
#          (V/C)**2 
#         ---------- 
#          1 - (V/C) 
# 
#      which is well approximated by (V/C)**2, where V is the 
#      velocity of the target relative to an inertial frame and C is 
#      the speed of light. 
# 
#      For nearly all objects in the solar system V is less than 60
#      km/sec. The value of C is ~300000 km/sec. Thus the
#      one-iteration solution for LT has a potential relative error
#      of not more than 4e-8. This is a potential light time error of
#      approximately 2e-5 seconds per astronomical unit of distance
#      separating the observer and target. Given the bound on V cited
#      above:
#
#         As long as the observer and target are separated by less
#         than 50 astronomical units, the error in the light time
#         returned using the one-iteration light time corrections is
#         less than 1 millisecond.
#
#         The magnitude of the corresponding position error, given
#         the above assumptions, may be as large as (V/C)**2 * the
#         distance between the observer and the uncorrected target
#         position: 300 km or equivalently 6 km/AU.
#
#      In practice, the difference between positions obtained using
#      one-iteration and converged light time is usually much smaller
#      than the value computed above and can be insignificant. For
#      example, for the spacecraft Mars Reconnaissance Orbiter and
#      Mars Express, the position error for the one-iteration light
#      time correction, applied to the spacecraft-to-Mars center
#      vector, is at the 1 cm level.
#      
#      Comparison of results obtained using the one-iteration and
#      converged light time solutions is recommended when adequacy of
#      the one-iteration solution is in doubt.
#
#
#      Converged corrections 
#      ---------------------
#
#      When the requested aberration correction is 'CN', 'CN+S',
#      'XCN', or 'XCN+S', as many iterations as are required for
#      convergence are performed in the computation of LT. Usually
#      the solution is found after three iterations. The relative
#      error present in this case is at most
#
#          (V/C)**4
#         ----------
#          1 - (V/C)
#
#      which is well approximated by (V/C)**4. 
#
#         The precision of this computation (ignoring round-off
#         error) is better than 4e-11 seconds for any pair of objects
#         less than 50 AU apart, and having speed relative to the
#         solar system barycenter less than 60 km/s.
#
#         The magnitude of the corresponding position error, given
#         the above assumptions, may be as large as (V/C)**4 * the
#         distance between the observer and the uncorrected target
#         position: 1.2 cm at 50 AU or equivalently 0.24 mm/AU.
#
#      However, to very accurately model the light time between
#      target and observer one must take into account effects due to
#      general relativity. These may be as high as a few hundredths
#      of a millisecond for some objects.
#
#
#   Relativistic Corrections 
#   ========================= 
# 
#   This routine does not attempt to perform either general or 
#   special relativistic corrections in computing the various 
#   aberration corrections. For many applications relativistic 
#   corrections are not worth the expense of added computation 
#   cycles. If however, your application requires these additional 
#   corrections we suggest you consult the astronomical almanac (page 
#   B36) for a discussion of how to carry out these corrections. 
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkezr_c.
#
#   MICE.REQ
#   SPK.REQ
#   NAIF_IDS.REQ
#   FRAMES.REQ
#   TIME.REQ
#
    function # spkezr
#       (state::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        lt::Float64) =   # Ptr{SpiceDouble}
        spkezr(
            target::AbstractString, # Ptr{ConstSpiceChar}
            epoch::Float64, # SpiceDouble
            frame::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            observer::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        lt = Array{Float64}(1);  # Ptr{SpiceDouble}
        lt_ptr = pointer(lt)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:spkezr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_SpiceDouble,Ptr{SpiceDouble}),target,epoch,frame,abcorr,observer,state,lt)
        ccall((:spkezr_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            target,epoch,frame,abcorr,observer,state_ptr,lt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return state, lt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK
#      %  file and a leapseconds file. Use a meta
#      %  kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      %  Define parameters for a state lookup:
#      %
#      %  Return the state vector of Mars (499) as seen from
#      %  Earth (399) in the J2000 frame
#      %  using aberration correction LT+S (light time plus
#      %  stellar aberration) at the epoch
#      %  July 4, 2003 11:00 AM PST.
#      %
#      target   = 'Mars';
#      epoch    = 'July 4, 2003 11:00 AM PST';
#      frame    = 'J2000';
#      abcorr   = 'LT+S';
#      observer = 'Earth';
#
#      %
#      %  Convert the epoch to ephemeris time.
#      %
#      et = cspice_str2et( epoch );
#
#      %
#      %  Look-up the state for the defined parameters.
#      %
#      [ state, ltime ] = spkezr( target, et, frame, ...
#                                        abcorr, observer);
#
#      %
#      %  Output...
#      %
#      txt = sprintf( 'The position of    : %s', target);
#      disp( txt )
#
#      txt = sprintf( 'As observed from   : %s', observer );
#      disp( txt )
#
#      txt = sprintf( 'In reference frame : %s', frame );
#      disp( txt )
#      disp( ' ' )
#
#      %
#      %  The first three entries of state contain the
#      %  X, Y, Z position components. The final three contain
#      %  the Vx, Vy, Vz velocity components.
#      %
#      txt = sprintf( 'Scalar' );
#      disp( txt )
#
#      utc_epoch = cspice_et2utc( et, 'C', 3 );
#
#      txt = sprintf(  'At epoch           : %s', epoch );
#      disp( txt )
#
#      txt = sprintf(  '                   : i.e. %s', utc_epoch );
#      disp( txt )
#
#      txt = sprintf( ['R (kilometers)     : ' ...
#                      '%12.4f %12.4f %12.4f'], state(1:3) );
#      disp( txt )
#
#      txt = sprintf( ['V (kilometers/sec) : ' ...
#                      '%12.7f %12.7f %12.7f'], state(4:6) );
#      disp( txt )
#
#      txt = sprintf( 'Light time (secs)  : %12.7f', ltime );
#      disp( txt )
#
#      disp(' between observer' )
#      disp(' and target' )
#      disp( ' ' )
#
#      %
#      % Create a vector of et's, starting at 'epoch'
#      % in steps of 100000 ephemeris seconds.
#      %
#      vec_et = [0:4]*100000. + et;
#
#      disp( 'Vector' )
#      vec_epoch = cspice_et2utc( vec_et, 'C', 3 );
#
#      %
#      % Look up the 'state' vectors and light time values
#      % 'ltime'  corresponding to the vector of input
#      % ephemeris time 'vec_et'.
#      %
#      [state , ltime] = spkezr( target, vec_et, ...
#                                       frame, abcorr, observer );
#
#      for i=1:5
#
#         txt = sprintf(  'At epoch (UTC)     : %s', vec_epoch(i,:) );
#         disp( txt )
#
#         txt = sprintf( ['R (kilometers)     : ' ...
#                         '%12.4f %12.4f %12.4f'], state(1:3,i) );
#         disp( txt )
#
#         txt = sprintf( ['V (kilometers/sec) : ' ...
#                         '%12.7f %12.7f %12.7f'], state(4:6,i) );
#         disp( txt )
#
#         txt = sprintf( ['Light time (secs)  : ' ...
#                        '%12.7f'], ltime(i) );
#         disp( txt )
#
#         disp(' between observer' )
#         disp(' and target' )
#         disp( ' ' )
#
#      end
#
#      %
#      %  It's always good form to unload kernels after use,
#      %  particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      The position of    : Mars
#      As observed from   : Earth
#      In reference frame : J2000
#
#      Scalar
#      At epoch           : July 4, 2003 11:00 AM PST
#                         : i.e. 2003 JUL 04 19:00:00.000
#      R (kilometers)     : 73822235.3105 -27127918.9985 -18741306.3015
#      V (kilometers/sec) :   -6.8090923    7.5131823    3.0009890
#      Light time (secs)  :  269.6898814
#       between observer
#       and target
#
#      Vector
#      At epoch (UTC)     : 2003 JUL 04 19:00:00.000
#      R (kilometers)     : 73822235.3105 -27127918.9985 -18741306.3015
#      V (kilometers/sec) :   -6.8090923    7.5131823    3.0009890
#      Light time (secs)  :  269.6898814
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 05 22:46:40.000
#      R (kilometers)     : 73140185.4144 -26390524.7797 -18446763.0348
#      V (kilometers/sec) :   -6.8317855    7.2333512    2.8893940
#      Light time (secs)  :  266.5640394
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 07 02:33:20.000
#      R (kilometers)     : 72456239.6608 -25681031.0146 -18163339.1448
#      V (kilometers/sec) :   -6.8470343    6.9552228    2.7786326
#      Light time (secs)  :  263.4803533
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 08 06:20:00.000
#      R (kilometers)     : 71771127.0087 -24999259.4606 -17890946.6362
#      V (kilometers/sec) :   -6.8551544    6.6789442    2.6687919
#      Light time (secs)  :  260.4395234
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 09 10:06:40.000
#      R (kilometers)     : 71085543.8280 -24345021.1811 -17629490.7100
#      V (kilometers/sec) :   -6.8564772    6.4045794    2.5599191
#      Light time (secs)  :  257.4422002
#       between observer
#       and target
#
#-Version
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #   ####   #####   #    #
#    #       #    #  #   #   #    #  #    #  ##   #
#     ####   #    #  ####    #    #  #    #  # #  #
#         #  #####   #  #    #    #  #####   #  # #
#    #    #  #       #   #   #    #  #       #   ##
#     ####   #       #    #   ####   #       #    #
#
#   open a new spk file
#
################################################################################
#-Abstract
#
#   spkopn opens a new SPK file, returning the handle
#   of the opened file.
#
#-I/O
#
#   Given:
#
#      fname    the name of the SPK file to open.
#
#               [1,c1] = size(fname); char = class(fname)
#
#                  or
#
#               [1,1] = size(fname); cell = class(fname)
#
#      ifname   the descriptive internal filename for the SPK.
#
#               [1,c2] = size(ifname); char = class(ifname)
#
#                  or
#
#               [1,1] = size(ifname); cell = class(ifname)
#
#      ncomch   the scalar integer number of characters to
#               reserve for comments.
#
#               [1,1] = size(ncomch); int32 = class(ncomch)
#
#   the call:
#
#      handle = spkopn( name, ifname, ncomch )
#
#   returns:
#
#      handle   the file handle assigned to 'fname'.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#-Particulars
#
#   A cspice_spkcls call should balance every spkopn
#   call.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkopn_c.
#
#   MICE.REQ
#   SPK.REQ
#
    function # spkopn
#       (handle::Int32) =   # Ptr{SpiceInt}
        spkopn(
            name::AbstractString, # Ptr{ConstSpiceChar}
            ifname::AbstractString, # Ptr{ConstSpiceChar}
            ncomch::Int32) # SpiceInt
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # Ptr{SpiceInt}
        handle_ptr = pointer(handle)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:spkopn_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceInt,Ptr{SpiceInt}),name,ifname,ncomch,handle)
        ccall((:spkopn_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Int32,Ptr{Int32}),
            name,ifname,ncomch,handle_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#-Version
#
#   -Mice Version 1.0.0, 23-MAY-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #  #####    ####    ####
#    #       #    #  #   #   #    #  #    #  #
#     ####   #    #  ####    #    #  #    #   ####
#         #  #####   #  #    #####   #    #       #
#    #    #  #       #   #   #       #    #  #    #
#     ####   #       #    #  #        ####    ####
#
#   using names get target position relative to an observer
#   position relative to observer corrected for aberrations
#   read ephemeris data
#   read trajectory data
#
################################################################################
#-Abstract
#
#   spkpos returns the position of a target body relative
#   to an observing body, optionally corrected for light time
#   (planetary aberration) and stellar aberration.
#
#-I/O
#
#   Given:
#
#      targ      the scalar string name of a target body.
#                Optionally, you may supply the integer ID code
#                for the object as an integer string, i.e. both
#                'MOON' and '301' are legitimate strings that
#                indicate the Moon is the target body.
#
#                The target and observer define a position vector
#                whose position component points from the observer
#                to the target.
#
#                [1,c1] = size(target), char = class(target)
#
#                   or
#
#                [1,1] = size(target); cell = class(target)
#
#      et        the scalar or 1XN-vector of double precision ephemeris
#                time, expressed as seconds past J2000 TDB, at which
#                position of the target body relative to the observer
#                the is to be  computed, 'et' refers to time at the
#                observer's location.
#
#                [1,N] = size(et), double = class(et)
#
#      ref       the scalar string name of the reference frame relative
#                to which the output position vector should be
#                expressed. This may be any frame supported by the SPICE
#                system, including built-in frames (documented in the
#                Frames Required Reading) and frames defined by a loaded
#                frame kernel (FK).
#
#                When 'ref' designates a non-inertial frame, the
#                orientation of the frame is evaluated at an epoch
#                dependent on the selected aberration correction.
#
#                [1,c2] = size(ref), char = class(ref)
#
#                   or
#
#                [1,1] = size(ref); cell = class(ref)
#
#      abcorr    a scalar string that indicates the aberration corrections
#                to apply to the position of the target body to account
#                for one-way light time and stellar aberration.
#
#                'abcorr' may be any of the following:
#
#                   'NONE'     Apply no correction. Return the
#                              geometric position of the target
#                              body relative to the observer.
#
#                The following values of 'abcorr' apply to the
#                "reception" case in which photons depart from the
#                target's location at the light-time corrected epoch
#                et-lt and *arrive* at the observer's location at
#                'et':
#
#                   'LT'       Correct for one-way light time (also
#                              called "planetary aberration") using a
#                              Newtonian formulation. This correction
#                              yields the position of the target at the
#                              moment it emitted photons arriving at
#                              the observer at 'et'.
#
#                              The light time correction uses an
#                              iterative solution of the light time
#                              equation (see Particulars for details).
#                              The solution invoked by the "LT" option
#                              uses one iteration.
#
#                   'LT+S'     Correct for one-way light time and
#                              stellar aberration using a Newtonian
#                              formulation. This option modifies the
#                              position obtained with the "LT" option to
#                              account for the observer's velocity
#                              relative to the solar system
#                              barycenter. The result is the apparent
#                              position of the target---the position
#                              of the target as seen by the
#                              observer.
#
#                   'CN'       Converged Newtonian light time correction.
#                              This option produces a solution that is at
#                              least as accurate at that obtainable 
#                              with the 'LT' option. Whether the 'CN' 
#                              solution is substantially more accurate 
#                              depends on the geometry of the 
#                              participating objects and on the 
#                              accuracy of the input data. In all 
#                              cases this routine will execute more 
#                              slowly when a converged solution is 
#                              computed. See the section titled "The 
#                              Computation of Light Time" in the SPK
#                              Required Reading document spk.req for 
#                              details.
#
#                   'CN+S'     Converged Newtonian light time
#                              correction and stellar aberration
#                              correction.
#
#
#                The following values of 'abcorr' apply to the
#                "transmission" case in which photons *depart* from
#                the observer's location at 'et' and arrive at the
#                target's location at the light-time corrected epoch
#                et+lt:
#
#                   'XLT'      "Transmission" case:  correct for
#                              one-way light time using a Newtonian
#                              formulation. This correction yields the
#                              position of the target at the moment it
#                              receives photons emitted from the
#                              observer's location at 'et'.
#
#                   'XLT+S'    "Transmission" case:  correct for
#                              one-way light time and stellar
#                              aberration using a Newtonian
#                              formulation  This option modifies the
#                              position obtained with the "XLT" option to
#                              account for the observer's velocity
#                              relative to the solar system
#                              barycenter. The position indicates the
#                              direction that photons emitted from the
#                              observer's location must be "aimed" to
#                              hit the target.
#
#                   'XCN'      "Transmission" case:  converged
#                              Newtonian light time correction.
#
#                   'XCN+S'    "Transmission" case:  converged
#                              Newtonian light time correction and
#                              stellar aberration correction.
#
#
#                Neither special nor general relativistic effects are
#                accounted for in the aberration corrections applied
#                by this routine.
#
#                Neither letter case or embedded blanks are significant
#                in the 'abcorr' string.
#
#                [1,c3] = size(abcorr), char = class(abcorr)
#
#                   or
#
#                [1,1] = size(abcorr); cell = class(abcorr)
#
#      obs       the scalar string name of a observing body.
#                Optionally, you may supply the integer ID code
#                for the object as an integer string, i.e. both
#                'MOON' and '301' are legitimate strings that
#                indicate the Moon is the observing body.
#
#                [1,c4] = size(obs), char = class(obs)
#
#                   or
#
#                [1,1] = size(obs); cell = class(obs)
#
#   the call:
#
#      [pos, lt] = spkpos(targ, et, ref, abcorr, obs)
#
#   returns:
#
#      pos   a double precision 3x1 array or double precision
#            3xN array representing the position of the target body in
#            kilometers relative to the specified observer
#
#            [3,N] = size(pos), double = class(pos)
#
#      lt    the double precision scalar one-way light time or double
#            precision 1xN array of one-way light times between the
#            observer and target in seconds; if the target state
#            is corrected for aberrations, then 'lt' is the
#            one-way light time between the observer and the light
#            time corrected target location
#
#            [1,N] = size(lt), double = class(lt)
#
#            'pos' and 'lt' return with the same vectorization
#            measure (N) as 'et'.
#
#-Particulars
#
#   A sister version of this routine exists named mice_spkpos that returns
#   the output arguments as fields in a single structure.
#
#   Aberration corrections 
#   ====================== 
# 
#   In space science or engineering applications one frequently 
#   wishes to know where to point a remote sensing instrument, such 
#   as an optical camera or radio antenna, in order to observe or 
#   otherwise receive radiation from a target. This pointing problem 
#   is complicated by the finite speed of light:  one needs to point 
#   to where the target appears to be as opposed to where it actually 
#   is at the epoch of observation. We use the adjectives 
#   "geometric," "uncorrected," or "true" to refer to an actual 
#   position or state of a target at a specified epoch. When a 
#   geometric position or state vector is modified to reflect how it 
#   appears to an observer, we describe that vector by any of the 
#   terms "apparent," "corrected," "aberration corrected," or "light 
#   time and stellar aberration corrected." The SPICE Toolkit can
#   correct for two phenomena affecting the apparent location of an
#   object:  one-way light time (also called "planetary aberration") and
#   stellar aberration.
#
#   One-way light time
#   ------------------
#
#   Correcting for one-way light time is done by computing, given an
#   observer and observation epoch, where a target was when the observed
#   photons departed the target's location. The vector from the
#   observer to this computed target location is called a "light time
#   corrected" vector. The light time correction depends on the motion
#   of the target relative to the solar system barycenter, but it is
#   independent of the velocity of the observer relative to the solar
#   system barycenter. Relativistic effects such as light bending and
#   gravitational delay are not accounted for in the light time
#   correction performed by this routine.
# 
#   Stellar aberration
#   ------------------
#
#   The velocity of the observer also affects the apparent location 
#   of a target:  photons arriving at the observer are subject to a 
#   "raindrop effect" whereby their velocity relative to the observer 
#   is, using a Newtonian approximation, the photons' velocity 
#   relative to the solar system barycenter minus the velocity of the 
#   observer relative to the solar system barycenter. This effect is 
#   called "stellar aberration."  Stellar aberration is independent 
#   of the velocity of the target. The stellar aberration formula 
#   used by this routine does not include (the much smaller)
#   relativistic effects.
# 
#   Stellar aberration corrections are applied after light time 
#   corrections:  the light time corrected target position vector is  
#   used as an input to the stellar aberration correction. 
# 
#   When light time and stellar aberration corrections are both 
#   applied to a geometric position vector, the resulting position  
#   vector indicates where the target "appears to be" from the 
#   observer's location.  
# 
#   As opposed to computing the apparent position of a target, one 
#   may wish to compute the pointing direction required for 
#   transmission of photons to the target. This also requires correction 
#   of the geometric target position for the effects of light time 
#   and stellar aberration, but in this case the corrections are 
#   computed for radiation traveling *from* the observer to the target. 
#   We will refer to this situation as the "transmission" case.
#
#   The "transmission" light time correction yields the target's 
#   location as it will be when photons emitted from the observer's 
#   location at `et' arrive at the target. The transmission stellar 
#   aberration correction is the inverse of the traditional stellar 
#   aberration correction:  it indicates the direction in which 
#   radiation should be emitted so that, using a Newtonian 
#   approximation, the sum of the velocity of the radiation relative 
#   to the observer and of the observer's velocity, relative to the  
#   solar system barycenter, yields a velocity vector that points in  
#   the direction of the light time corrected position of the target. 
#  
#   One may object to using the term "observer" in the transmission
#   case, in which radiation is emitted from the observer's location.
#   The terminology was retained for consistency with earlier
#   documentation.
# 
#   Below, we indicate the aberration corrections to use for some 
#   common applications: 
# 
#      1) Find the apparent direction of a target for a remote-sensing
#         observation.
#
#            Use 'LT+S' or 'CN+S: apply both light time and stellar 
#            aberration corrections.
#
#         Note that using light time corrections alone ('LT' or 'CN')
#         is generally not a good way to obtain an approximation to
#         an apparent target vector: since light time and stellar
#         aberration corrections often partially cancel each other,
#         it may be more accurate to use no correction at all than to
#         use light time alone.
#
#
#      2) Find the corrected pointing direction to radiate a signal
#         to a target. This computation is often applicable for 
#         implementing communications sessions.
#
#            Use 'XLT+S' or 'XCN+S: apply both light time and stellar 
#            aberration corrections for transmission.
#
#
#      3) Compute the apparent position of a target body relative
#         to a star or other distant object.
#
#            Use 'LT', 'CN', 'LT+S', or 'CN+S' as needed to match the
#            correction applied to the position of the distant
#            object. For example, if a star position is obtained from
#            a catalog, the position vector may not be corrected for
#            stellar aberration. In this case, to find the angular
#            separation of the star and the limb of a planet, the
#            vector from the observer to the planet should be
#            corrected for light time but not stellar aberration.
#
#
#      4) Obtain an uncorrected state vector derived directly from 
#         data in an SPK file.
#
#            Use 'NONE'.
#
#
#      5) Use a geometric state vector as a low-accuracy estimate
#         of the apparent state for an application where execution 
#         speed is critical.
#
#            Use 'NONE'.
#
#
#      6) While this routine cannot perform the relativistic
#         aberration corrections required to compute states
#         with the highest possible accuracy, it can supply the
#         geometric states required as inputs to these computations.
#
#            Use 'NONE', then apply relativistic aberration
#            corrections (not available in the SPICE Toolkit).
#
# 
#   Below, we discuss in more detail how the aberration corrections 
#   applied by this routine are computed.      
# 
#      Geometric case 
#      ============== 
# 
#      spkezr_c begins by computing the geometric position T(et) of the 
#      target body relative to the solar system barycenter (SSB). 
#      Subtracting the geometric position of the observer O(et) gives 
#      the geometric position of the target body relative to the 
#      observer. The one-way light time, lt, is given by 
# 
#                | T(et) - O(et) | 
#         lt = ------------------- 
#                        c 
# 
#      The geometric relationship between the observer, target, and 
#      solar system barycenter is as shown: 
# 
# 
#         SSB ---> O(et) 
#          |      / 
#          |     / 
#          |    /                            
#          |   /  T(et) - O(et)   
#          V  V                                   
#         T(et) 
# 
# 
#      The returned state consists of the position vector 
# 
#         T(et) - O(et) 
# 
#      and a velocity obtained by taking the difference of the 
#      corresponding velocities. In the geometric case, the  
#      returned velocity is actually the time derivative of the  
#      position. 
# 
# 
#      Reception case 
#      ============== 
# 
#      When any of the options "LT", "CN", "LT+S", "CN+S" is selected
#      for `abcorr', spkezr_c computes the position of the target body at
#      epoch et-lt, where `lt' is the one-way light time. Let T(t) and
#      O(t) represent the positions of the target and observer 
#      relative to the solar system barycenter at time t; then `lt' is 
#      the solution of the light-time equation 
# 
#                | T(et-lt) - O(et) | 
#         lt = ------------------------                            (1) 
#                         c 
# 
#      The ratio  
# 
#          | T(et) - O(et) | 
#        ---------------------                                     (2) 
#                  c 
# 
#      is used as a first approximation to `lt'; inserting (2) into the
#      right hand side of the light-time equation (1) yields the
#      "one-iteration" estimate of the one-way light time ("LT").
#      Repeating the process until the estimates of `lt' converge yields
#      the "converged Newtonian" light time estimate ("CN").
#      
#      Subtracting the geometric position of the observer O(et) gives 
#      the position of the target body relative to the observer: 
#      T(et-lt) - O(et). 
# 
#         SSB ---> O(et) 
#          | \     | 
#          |  \    | 
#          |   \   | T(et-lt) - O(et) 
#          |    \  | 
#          V     V V 
#         T(et)  T(et-lt) 
#       
#      The position component of the light time corrected state  
#      is the vector 
# 
#         T(et-lt) - O(et) 
# 
#      The velocity component of the light time corrected state  
#      is the difference 
# 
#         T_vel(et-lt)*(1-d(lt)/d(et)) - O_vel(et) 
#           
#      where T_vel and O_vel are, respectively, the velocities of the 
#      target and observer relative to the solar system barycenter at 
#      the epochs et-lt and `et'.  
#
#      If correction for stellar aberration is requested, the target 
#      position is rotated toward the solar system 
#      barycenter-relative velocity vector of the observer. The 
#      rotation is computed as follows: 
# 
#         Let r be the light time corrected vector from the observer 
#         to the object, and v be the velocity of the observer with 
#         respect to the solar system barycenter. Let w be the angle 
#         between them. The aberration angle phi is given by 
# 
#            sin(phi) = v sin(w) / c 
# 
#         Let h be the vector given by the cross product 
# 
#            h = r X v 
# 
#         Rotate r by phi radians about h to obtain the apparent 
#         position of the object. 
# 
#      When stellar aberration corrections are used, the rate of change
#      of the stellar aberration correction is accounted for in the
#      computation of the output velocity.
# 
# 
#      Transmission case 
#      ================== 
# 
#      When any of the options "XLT", "XCN", "XLT+S", "XCN+S" is 
#      selected, spkezr_c computes the position of the target body T at 
#      epoch et+lt, where `lt' is the one-way light time. `lt' is the 
#      solution of the light-time equation 
# 
#                | T(et+lt) - O(et) | 
#         lt = ------------------------                            (3) 
#                          c 
# 
#      Subtracting the geometric position of the observer, O(et), 
#      gives the position of the target body relative to the 
#      observer: T(et-lt) - O(et). 
# 
#                 SSB --> O(et) 
#                / |    *  
#               /  |  *  T(et+lt) - O(et)   
#              /   |*      
#             /   *|     
#            V  V  V      
#        T(et+lt)  T(et)     
# 
#      The position component of the light-time corrected state  
#      is the vector 
# 
#         T(et+lt) - O(et) 
# 
#      The velocity component of the light-time corrected state  
#      consists of the difference 
# 
#         T_vel(et+lt)*(1+d(lt)/d(et)) - O_vel(et) 
#           
#      where T_vel and O_vel are, respectively, the velocities of the 
#      target and observer relative to the solar system barycenter at 
#      the epochs et+lt and `et'. 
# 
#      If correction for stellar aberration is requested, the target 
#      position is rotated away from the solar system barycenter- 
#      relative velocity vector of the observer. The rotation is 
#      computed as in the reception case, but the sign of the 
#      rotation angle is negated. 
# 
# 
#   Precision of light time corrections 
#   =================================== 
# 
#      Corrections using one iteration of the light time solution 
#      ---------------------------------------------------------- 
# 
#      When the requested aberration correction is "LT", "LT+S", 
#      "XLT", or "XLT+S", only one iteration is performed in the 
#      algorithm used to compute lt. 
# 
#      The relative error in this computation 
# 
#         | LT_ACTUAL - LT_COMPUTED |  /  LT_ACTUAL 
# 
#      is at most  
# 
#          (V/C)**2 
#         ---------- 
#          1 - (V/C) 
# 
#      which is well approximated by (V/C)**2, where V is the 
#      velocity of the target relative to an inertial frame and C is 
#      the speed of light. 
# 
#      For nearly all objects in the solar system V is less than 60
#      km/sec. The value of C is ~300000 km/sec. Thus the
#      one-iteration solution for LT has a potential relative error
#      of not more than 4e-8. This is a potential light time error of
#      approximately 2e-5 seconds per astronomical unit of distance
#      separating the observer and target. Given the bound on V cited
#      above:
#
#         As long as the observer and target are separated by less
#         than 50 astronomical units, the error in the light time
#         returned using the one-iteration light time corrections is
#         less than 1 millisecond.
#
#         The magnitude of the corresponding position error, given
#         the above assumptions, may be as large as (V/C)**2 * the
#         distance between the observer and the uncorrected target
#         position: 300 km or equivalently 6 km/AU.
#
#      In practice, the difference between positions obtained using
#      one-iteration and converged light time is usually much smaller
#      than the value computed above and can be insignificant. For
#      example, for the spacecraft Mars Reconnaissance Orbiter and
#      Mars Express, the position error for the one-iteration light
#      time correction, applied to the spacecraft-to-Mars center
#      vector, is at the 1 cm level.
#      
#      Comparison of results obtained using the one-iteration and
#      converged light time solutions is recommended when adequacy of
#      the one-iteration solution is in doubt.
#
#
#      Converged corrections 
#      ---------------------
#
#      When the requested aberration correction is 'CN', 'CN+S',
#      'XCN', or 'XCN+S', as many iterations as are required for
#      convergence are performed in the computation of LT. Usually
#      the solution is found after three iterations. The relative
#      error present in this case is at most
#
#          (V/C)**4
#         ----------
#          1 - (V/C)
#
#      which is well approximated by (V/C)**4. 
#
#         The precision of this computation (ignoring round-off
#         error) is better than 4e-11 seconds for any pair of objects
#         less than 50 AU apart, and having speed relative to the
#         solar system barycenter less than 60 km/s.
#
#         The magnitude of the corresponding position error, given
#         the above assumptions, may be as large as (V/C)**4 * the
#         distance between the observer and the uncorrected target
#         position: 1.2 cm at 50 AU or equivalently 0.24 mm/AU.
#
#      However, to very accurately model the light time between
#      target and observer one must take into account effects due to
#      general relativity. These may be as high as a few hundredths
#      of a millisecond for some objects.
#
# 
#   Relativistic Corrections 
#   ========================= 
# 
#   This routine does not attempt to perform either general or 
#   special relativistic corrections in computing the various 
#   aberration corrections. For many applications relativistic 
#   corrections are not worth the expense of added computation 
#   cycles. If however, your application requires these additional 
#   corrections we suggest you consult the astronomical almanac (page 
#   B36) for a discussion of how to carry out these corrections. 
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkpos_c.
#
#   MICE.REQ
#   SPK.REQ
#   NAIF_IDS.REQ
#   FRAMES.REQ
#   TIME.REQ
#
    function # spkpos
#       (ptarg::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        lt::Float64) =   # Ptr{SpiceDouble}
        spkpos(
            targ::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            ref::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obs::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        ptarg = Array{Float64,1}(3);  # Array_3_SpiceDouble
        ptarg_ptr = pointer(ptarg)
        lt = Array{Float64}(1);  # Ptr{SpiceDouble}
        lt_ptr = pointer(lt)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:spkpos_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_SpiceDouble,Ptr{SpiceDouble}),targ,et,ref,abcorr,obs,ptarg,lt)
        ccall((:spkpos_c,libNasaSpice),Void,
            (Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            targ,et,ref,abcorr,obs,ptarg_ptr,lt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return ptarg, lt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK
#      %  file and a leapseconds file. Use a meta
#      %  kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      %  Define parameters for a position lookup:
#      %
#      %  Return the position vector of Mars (499) as seen from
#      %  Earth (399) in the J2000 frame
#      %  using aberration correction LT+S (light time plus
#      %  stellar aberration) at the epoch
#      %  July 4, 2003 11:00 AM PST.
#      %
#      target   = 'Mars';
#      epoch    = 'July 4, 2003 11:00 AM PST';
#      frame    = 'J2000';
#      abcorr   = 'LT+S';
#      observer = 'Earth';
#
#      %
#      %  Convert the epoch to ephemeris time.
#      %
#      et = cspice_str2et( epoch );
#
#      %
#      %  Look-up the position for the defined parameters.
#      %
#      [ pos, ltime ] = spkpos( target, et, frame, ...
#                                        abcorr, observer);
#
#      %
#      %  Output...
#      %
#      txt = sprintf( 'The position of    : %s', target);
#      disp( txt )
#
#      txt = sprintf( 'As observed from   : %s', observer );
#      disp( txt )
#
#      txt = sprintf( 'In reference frame : %s', frame );
#      disp( txt )
#      disp( ' ' )
#
#      txt = sprintf( 'Scalar' );
#      disp( txt )
#
#      utc_epoch = cspice_et2utc( et, 'C', 3 );
#
#      txt = sprintf(  'At epoch           : %s', epoch );
#      disp( txt )
#
#      txt = sprintf(  '                   : i.e. %s', utc_epoch );
#      disp( txt )
#
#      txt = sprintf( ['R (kilometers)     : ' ...
#                      '%12.4f %12.4f %12.4f'], pos );
#      disp( txt )
#
#      txt = sprintf( 'Light time (secs)  : %12.7f', ltime );
#      disp( txt )
#
#      disp(' between observer' )
#      disp(' and target' )
#      disp( ' ' )
#
#      %
#      % Create a vector of et's, starting at 'epoch'
#      % in steps of 100000 ephemeris seconds.
#      %
#      vec_et = [0:4]*100000. + et;
#
#      disp( 'Vector' )
#      vec_epoch = cspice_et2utc( vec_et, 'C', 3 );
#
#      %
#      % Look up the position vectors and light time values
#      % 'ltime'  corresponding to the vector of input
#      % ephemeris time 'vec_et'.
#      %
#      [pos , ltime] = spkpos( target, vec_et, ...
#                                       frame, abcorr, observer );
#
#      for i=1:5
#
#         txt = sprintf(  'At epoch (UTC)     : %s', vec_epoch(i,:) );
#         disp( txt )
#
#         txt = sprintf( ['R (kilometers)     : ' ...
#                         '%12.4f %12.4f %12.4f'], pos(i) );
#         disp( txt )
#
#         txt = sprintf( ['Light time (secs)  : ' ...
#                        '%12.7f'], ltime(i) );
#         disp( txt )
#
#         disp(' between observer' )
#         disp(' and target' )
#         disp( ' ' )
#
#      end
#
#      %
#      %  It's always good form to unload kernels after use,
#      %  particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      The position of    : Mars
#      As observed from   : Earth
#      In reference frame : J2000
#
#      Scalar
#      At epoch           : July 4, 2003 11:00 AM PST
#                         : i.e. 2003 JUL 04 19:00:00.000
#      R (kilometers)     : 73822235.3105 -27127918.9985 -18741306.3015
#      Light time (secs)  :  269.6898814
#       between observer
#       and target
#
#      Vector
#      At epoch (UTC)     : 2003 JUL 04 19:00:00.000
#      R (kilometers)     : 73822235.3105 -27127918.9985 -18741306.3015
#      Light time (secs)  :  269.6898814
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 05 22:46:40.000
#      R (kilometers)     : 73140185.4144 -26390524.7797 -18446763.0348
#      Light time (secs)  :  266.5640394
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 07 02:33:20.000
#      R (kilometers)     : 72456239.6608 -25681031.0146 -18163339.1448
#      Light time (secs)  :  263.4803533
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 08 06:20:00.000
#      R (kilometers)     : 71771127.0087 -24999259.4606 -17890946.6362
#      Light time (secs)  :  260.4395234
#       between observer
#       and target
#
#      At epoch (UTC)     : 2003 JUL 09 10:06:40.000
#      R (kilometers)     : 71085543.8280 -24345021.1811 -17629490.7100
#      Light time (secs)  :  257.4422002
#       between observer
#       and target
#
#-Version
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   #    #  #####   #    #  #    #
#    #       #    #  #   #   #    #  #    #  ##   #
#     ####   #    #  ####    #    #  #    #  # #  #
#         #  #####   #  #    #####   #    #  #  # #
#    #    #  #       #   #   #        #  #   #   ##
#     ####   #       #    #  #         ##    #    #
#
#   select spk file and segment
#
################################################################################
#-Abstract
#
#   spkpvn returns, for a specified SPK segment and time, the state
#   (position and velocity) of the segment's target body relative to its
#   center of motion.
#
#-I/O
#
#   Given:
#
#      handle,
#      descr     respectively, file handle assigned to a SPK file and
#                the descriptor for a segment within the file. Together
#                they determine the ephemeris data from which the state
#                of the body is to be computed.
#
#                [1,1] = size(handle); int32 = class(handle)
#
#                [5,1] = size(descr); double = class(descr)
#
#      et        a scalar double precision time, in seconds past the
#                epoch J2000 TDB.
#
#                [1,1] = size(et); double = class(et)
#
#   the call:
#
#      [ref, state, center] = spkpvn( handle, descr, et)
#
#   returns:
#
#      ref      the ID code of the reference frame relative to which the
#               state returned by the routine is expressed.
#
#               [1,1] = size(ref); int32 = class(ref)
#
#      state    the array containing the position and velocity, at epoch
#               'et', for the body covered by the specified segment. 'state'
#               has six elements:  the first three contain the body's
#               position; the last three contain the body's velocity. These
#               vectors are expressed into the specified reference frame.
#               Units are always km and km/sec.
#
#               [6,1] = size(state); double = class(state)
#
#      center   the SPK ID code of the center of motion for the state.
#
#               [1,1] = size(center); int32 = class(center)
#
#-Particulars
#
#   This routine finds the highest-priority segment, in any loaded
#   SPK file, such that the segment provides data for the specified
#   body and epoch.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkpvn_c.
#
#   MICE.REQ
#   SPK.REQ
#
    function # spkpvn
#       (ref::Int32,  # Ptr{SpiceInt}
#        state::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        center::Int32) =   # Ptr{SpiceInt}
        spkpvn(
            handle::Int32, # SpiceInt
            descr::Array{Float64,1}, # Array_5_ConstSpiceDouble
            et::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(descr) != 5
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        ref = Array{Int32}(1);  # Ptr{SpiceInt}
        ref_ptr = pointer(ref)
        state = Array{Float64,1}(6);  # Array_6_SpiceDouble
        state_ptr = pointer(state)
        center = Array{Int32}(1);  # Ptr{SpiceInt}
        center_ptr = pointer(center)
        
#       make transposed copies of all input arrays and their pointers
        descr_t = descr'
        descr_ptr = pointer(descr_t)
        
#       ccall((:spkpvn_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,Array_5_ConstSpiceDouble,SpiceDouble,Ptr{SpiceInt},Array_6_SpiceDouble,Ptr{SpiceInt}),handle,descr,et,ref,state,center)
        ccall((:spkpvn_c,libNasaSpice),Void,
            (Int32,Ptr{Float64},Float64,Ptr{Int32},Ptr{Float64},Ptr{Int32}),
            handle,descr_ptr,et,ref_ptr,state_ptr,center_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return ref[1], state, center[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   In the following code fragment, an SPK file is searched for
#   a segment containing ephemeris data for the Jupiter system
#   barycenter at a particular epoch. Using this segment,
#   states of the Jupiter system barycenter relative to the
#   solar system barycenter are evaluated at a sequence of times.
#
#   This method of state computation minimizes the number of
#   segment searches required to obtain requested data, but
#   it bypasses the SPK subsystem's state chaining mechanism.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: standard.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00010.tpc                  Planet orientation and
#                                          radii
#            naif0010.tls                  Leapseconds
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( 'de421.bsp',
#                                'pck00010.tpc',
#                                'naif0010.tls'  )
#
#         \begintext
#
#   Example:
#
#      %
#      % Local constants
#      %
#      META   =  'standard.tm';
#      ND     =  2;
#      NI     =  6;
#      TIMFMT =  'YYYY MON DD HR:MN:SC.######::TDB TDB';
#
#      %
#      % Load meta-kernel.
#      %
#      cspice_furnsh( META )
#
#      %
#      % Convert starting time to seconds past J2000 TDB.
#      %
#      timstr = '2012 APR 27 00:00:00.000 TDB';
#
#      et0 = cspice_str2et(timstr);
#
#      %
#      % Find a loaded segment for the Jupiter barycenter
#      % that covers `et0'.
#      %
#      body = 5;
#
#      [handle, descr, segid, found] = cspice_spksfs( body, et0);
#
#
#      if ~found
#         cspice_kclear
#         txt = sprintf( 'No SPK segment found for body %d at time %s', ...
#                         body, timstr );
#         error( txt )
#      end
#
#      %
#      % Unpack the descriptor of the current segment.
#      %
#      [dc, ic] = cspice_dafus( descr, ND, NI );
#
#      frname = cspice_frmnam( ic(3) );
#
#      fprintf( 'Body        = %d\n', ic(1) )
#      fprintf( 'Center      = %d\n', ic(2) )
#      fprintf( 'Frame       = %s\n', frname)
#      fprintf( 'Data type   = %d\n', ic(4) )
#      fprintf( 'Start ET    = %f\n', dc(1) )
#      fprintf( 'Stop ET     = %f\n', dc(2) )
#      fprintf( 'Segment ID  = %s\n\n', segid )
#
#
#      %
#      % Evaluate states at 10-second steps, starting at `et0'
#      % and continuing for 20 seconds.
#      %
#
#      for i=1:3
#
#         et = et0 + ( 10. * (i-1) );
#
#         %
#         % Convert `et' to a string for display.
#         %
#         outstr = cspice_timout( et, TIMFMT );
#
#         %
#         % Attempt to compute a state only if the segment's
#         % coverage interval contains `et'.
#         %
#         if ( et <= dc(2) )
#
#            %
#            % This segment has data at `et'. Evaluate the
#            % state of the target relative to its center
#            % of motion.
#            %
#            [ref_id, state, center] = spkpvn( handle, descr, et );
#
#            %
#            %  Display the time and state.
#            %
#            fprintf( '\n%s\n', outstr )
#            fprintf( 'Position X (km):   %24.17f\n', state(1) )
#            fprintf( 'Position Y (km):   %24.17f\n', state(2) )
#            fprintf( 'Position Z (km):   %24.17f\n', state(3) )
#            fprintf( 'Velocity X (km):   %24.17f\n', state(4) )
#            fprintf( 'Velocity X (km):   %24.17f\n', state(5) )
#            fprintf( 'Velocity X (km):   %24.17f\n', state(6) )
#
#         else
#
#            cspice_kclear
#            txt = sprintf( 'No data found for body %d at time %s', ...
#                         body, outstr );
#            error( txt )
#
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in IDL due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Body        = 5
#      Center      = 0
#      Frame       = J2000
#      Data type   = 2
#      Start ET    = -3169195200.000000
#      Stop ET     = 1696852800.000000
#      Segment ID  = DE-0421LE-0421
#
#
#      2012 APR 27 00:00:00.000000 TDB
#      Position X (km):   464528993.98216485977172852
#      Position Y (km):   541513126.15685200691223145
#      Position Z (km):   220785135.62462940812110901
#      Velocity X (km):      -10.38685648307654930
#      Velocity X (km):        7.95324700713742416
#      Velocity X (km):        3.66185835431306517
#
#      2012 APR 27 00:00:10.000000 TDB
#      Position X (km):   464528890.11359262466430664
#      Position Y (km):   541513205.68931341171264648
#      Position Z (km):   220785172.24320945143699646
#      Velocity X (km):      -10.38685796160419272
#      Velocity X (km):        7.95324528430304944
#      Velocity X (km):        3.66185765185608103
#
#      2012 APR 27 00:00:20.000000 TDB
#      Position X (km):   464528786.24500560760498047
#      Position Y (km):   541513285.22175765037536621
#      Position Z (km):   220785208.86178246140480042
#      Velocity X (km):      -10.38685944013147910
#      Velocity X (km):        7.95324356146845002
#      Velocity X (km):        3.66185694939899253
#
#-Version
#
#   -Mice Version 1.0.0, 30-OCT-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                                     ###    #####
#     ####   #####   #    #  #    #  #   #  #     #
#    #       #    #  #   #   #    # # #   # #     #
#     ####   #    #  ####    #    # #  #  #  #####
#         #  #####   #  #    # ## # #   # # #     #
#    #    #  #       #   #   ##  ##  #   #  #     #
#     ####   #       #    #  #    #   ###    #####
#
#   write spk type_8 ephemeris data segment
#
################################################################################
#-Abstract
#
#   spkw08 writes a type 8 segment to an SPK file.
#
#-I/O
#
#   Given:
#
#      handle   the file handle of an SPK file open for writing.
#
#               [1,1] = size(handle); int32 = class(handle)
#
#      body     the SPICE ID code for an ephemeris object
#               whose state relative to another body is described
#               by the segment to be created.
#
#               [1,1] = size(body); int32 = class(body)
#
#      center   the SPICE ID code for the center of motion
#               of the object identified by body.
#
#               [1,1] = size(center); int32 = class(center)
#
#      frame    the name for a reference frame relative to which the state
#               information for body is specified.
#
#               [1,c1] = size(fname); char = class(fname)
#
#                  or
#
#               [1,1] = size(fname); cell = class(fname)
#
#      first,
#      last     are, respectively, the start and stop times of
#               the time interval over which the segment defines
#               the state of body.
#
#               [1,1] = size(first); double = class(first)
#               [1,1] = size(last);  double = class(last)
#
#      segid    is the segment identifier.  An SPK segment
#               identifier may contain up to 40 characters.
#
#      degree   the degree of the Lagrange polynomials used to
#               interpolate the states.  All components of the
#               state vectors are interpolated by polynomials of
#               fixed degree.
#
#               [1,1] = size(degree); int32 = class(degree)
#
#      states   contains a time-ordered array of geometric states
#               ( x, y, z, dx/dt, dy/dt, dz/dt, in kilometers and
#               kilometers per second ) of body relative to center,
#               specified relative to frame.
#
#               [6,m] = size(states); double = class(states)
#
#      epoch1   the epoch corresponding to the first state in
#               the state array.  Because extra states are needed
#               at the beginning and end of the segment in order
#               for the interpolation method to work, epoch1 will
#               normally precede first.
#
#               [1,1] = size(epoch1); double = class(epoch1)
#
#      step     the time step separating the epochs of adjacent
#               states in the input state array.  step is specified
#               in TDB seconds.
#
#               [1,1] = size(step); double = class(step)
#
#   the call:
#
#      spkw08( handle, body,  center, frame,  first,  ...
#                     last,   segid, degree, states, epoch1, ...
#                     step )
#
#   returns:
#
#   The routine writes to the SPK file referred to by 'handle' a type 8 SPK
#   segment containing the data listed in 'states'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine spkw08_c.
#
    function # spkw08
#       (handle::Int32,  # SpiceInt
#        body::Int32,  # SpiceInt
#        center::Int32,  # SpiceInt
#        frame::AbstractString,  # Ptr{ConstSpiceChar}
#        first::Float64,  # SpiceDouble
#        last::Float64,  # SpiceDouble
#        segid::AbstractString,  # Ptr{ConstSpiceChar}
#        degree::Int32,  # SpiceInt
#        states::Array{Float64,1}(6),  # Ptr{Array_6_ConstSpiceDouble}
#        epoch1::Float64,  # SpiceDouble
#        step::Float64) =   # SpiceDouble
        spkw08()
        
#       enforce input array sizes
#       allocate the output parameters
        handle = Array{Int32}(1);  # SpiceInt
        handle_ptr = pointer(handle)
        body = Array{Int32}(1);  # SpiceInt
        body_ptr = pointer(body)
        center = Array{Int32}(1);  # SpiceInt
        center_ptr = pointer(center)
        frame = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        frame_ptr = pointer(frame)
        first = Array{Float64}(1);  # SpiceDouble
        first_ptr = pointer(first)
        last = Array{Float64}(1);  # SpiceDouble
        last_ptr = pointer(last)
        segid = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        segid_ptr = pointer(segid)
        degree = Array{Int32}(1);  # SpiceInt
        degree_ptr = pointer(degree)
        states = Array{Float64,1}(6);  # Ptr{Array_6_ConstSpiceDouble}
        states_ptr = pointer(states)
        epoch1 = Array{Float64}(1);  # SpiceDouble
        epoch1_ptr = pointer(epoch1)
        step = Array{Float64}(1);  # SpiceDouble
        step_ptr = pointer(step)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:spkw08_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,SpiceInt,SpiceInt,Ptr{ConstSpiceChar},SpiceDouble,SpiceDouble,Ptr{ConstSpiceChar},SpiceInt,SpiceInt,Ptr{Array_6_ConstSpiceDouble},SpiceDouble,SpiceDouble),handle,body,center,frame,first,last,segid,degree,n,states,epoch1,step)
        ccall((:spkw08_c,libNasaSpice),Void,
            (Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{AbstractString},Ptr{Float64},Ptr{Float64},Ptr{AbstractString},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            handle_ptr,body_ptr,center_ptr,frame_ptr,first_ptr,last_ptr,segid_ptr,degree_ptr,states_ptr,epoch1_ptr,step_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return handle[1], body[1], center[1], frame[1], first[1], last[1], segid[1], degree[1], states, epoch1[1], step[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example:
#
#
#      %
#      % Define the segment identifier parameters.
#      %
#      BODY       = 3;
#      CENTER     = 10;
#      REF        = 'J2000';
#      POLY_DEG   = 3;
#      SPK8       = 'test8.bsp';
#      N_DISCRETE = 9;
#
#      %
#      % A set of epochs.
#      %
#      DISCRETEEPOCHS = (1:9)*100;
#
#      %
#      % An array of discrete states to write to the SPK segment.
#      %
#      base = [ (1:6)*100 ]';
#
#      %
#      % Create the 6xN array of states.
#      %
#      DISCRETESTATES = [(base+1), (base+2), (base+3), ...
#                        (base+4), (base+5), (base+6), ...
#                        (base+7), (base+8), (base+9) ];
#
#      %
#      % Create a segment identifier.
#      %
#      segid = 'SPK type 8 test segment';
#
#      %
#      % Open a new SPK file. Delete if a file of the same name exists.
#      %
#
#      handle = cspice_spkopn( SPK8, segid, 4 );
#
#      step   = DISCRETEEPOCHS(2) - DISCRETEEPOCHS(1);
#
#      %
#      % Create a type 8 segment.
#      %
#      spkw08( handle,                       ...
#                     BODY,                         ...
#                     CENTER,                       ...
#                     REF,                          ...
#                     DISCRETEEPOCHS(1),            ...
#                     DISCRETEEPOCHS(N_DISCRETE),   ...
#                     segid,                        ...
#                     POLY_DEG,                     ...
#                     DISCRETESTATES,               ...
#                     DISCRETEEPOCHS(1),            ...
#                     step )
#
#      %
#      % Close the SPK file.
#      %
#      cspice_spkcls( handle )
#
#   MATLAB outputs:
#
#      SPK file "test8.bsp" created containing a single type 8 segment.
#
#-Version
#
#   -Mice Version 1.0.0, 23-MAY-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #####   ######  #    #  #####    #####
#    #       #    #  #        #  #   #    #     #
#     ####   #    #  #####     ##    #    #     #
#         #  #####   #         ##    #####      #
#    #    #  #   #   #        #  #   #          #
#     ####   #    #  #       #    #  #          #
#
#   DEPRECATED surface intercept point
#
################################################################################
#-Abstract
#
#   srfxpt computes the surface intercept point of a specified ray
#   on a target body at a specified epoch, optionally corrected for light
#   time and stellar aberration, given an observer and a direction vector
#   defining a ray.
#
#   Deprecated: This routine has been superseded by the routine
#   cspice_sincpt. This routine is supported for purposes of
#   backward compatibility only.
#
#-I/O
#
#   Given:
#
#      method   the scalar string providing the parameters to define the
#               computation method to use
#
#                  The only currently supported choice:
#
#                     "Ellipsoid"   The intercept computation uses
#                                   a triaxial ellipsoid to model
#                                   the surface of the target body.
#                                   The ellipsoid's radii must be
#                                   available in the kernel pool.
#
#      target   the scalar string name of the target body, 'target' being
#               case-insensitive, leading and trailing blanks are not
#               significant
#
#                  Optionally, you may supply a string containing the integer
#                  ID code for the object. For example both "MOON" and "301"
#                  are legitimate strings that indicate the moon is the
#                  target body.
#
#      et       the double precision, scalar or 1XN-vector of epochs,
#               expressed as ephemeris seconds past J2000 TDB, at which to
#               compute the surface intercept point on the target body (this
#               epoch represents either the time of signal reception, or
#               transmission, depending on the selected 'abcorr')
#
#      abcorr   the scalar string name of the aberration correction to
#               apply when computing the observer-target state and the target
#               body orientation
#
#               For practical purposes, 'CN' (converged Newtonian)
#               represents the best correction choice.
#
#      obsrvr   the scalar string name of the observing body, 'obsrvr' being
#               case-insensitive, leading and trailing blanks are not
#               significant.
#
#                  Optionally, you may supply a string containing the integer
#                  ID code for the object. For example both "MOON" and "301"
#                  are legitimate strings that indicate the moon is the
#                  target body.
#
#      dref      the scalar string name of the reference frame containing the
#                'dvec' direction vector
#
#      dvec      the double precision 3-vector emanating from the observer
#
#                  'dvec' is specified relative to the reference frame
#                   designated by 'dref'.
#
#   the call:
#
#      [ spoint, dist, trgepc, obspos, found ] = ...
#                 srfxpt( method, target, et, abcorr, obsrvr, dref, dvec)
#
#   returns:
#
#      spoint   the double precision 3-vector or 3xN array identifying the
#               surface intercept point on 'target' of the ray 'dvec' that
#               emanates from 'obsrvr', with 'spoint' expressed in Cartesian
#               coordinates relative to the body-fixed frame
#               associated 'target'.
#
#                  The body-fixed target frame is evaluated at the epoch
#                  'trgepc' NOT 'et'.
#
#                  The components of `spoint' are given in units of km.
#
#      dist     the double precision, scalar or 1XN-vector distance in
#               kilometers between the observer and surface intercept on the
#               target body
#
#      trgepc   the double precision, scalar or 1XN-vector "intercept epoch"
#               expressed as ephemeris seconds past J2000 TDB where "intercept
#               epoch" means the epoch at which the ray defined by 'obsrvr'
#               and 'dvec' intercepts 'target' surface at 'spoint'
#
#      obspos   the double precision 3-vector or 3xN array pointing from the
#               center of 'target' at epoch 'trgepc' to 'obsrvr' at epoch 'et',
#               with 'obspos' expressed in the target body-fixed
#               reference frame
#
#                  The body-fixed target frame is evaluated at the epoch
#                  'trgepc' NOT 'et'.
#
#                  The components of 'obspos' are given in units of km.
#
#      found    a logical scalar or 1XN-vector indicating whether or not
#               the ray 'dvec' intersects 'target' (TRUE) or not (FALSE)
#
#               'spoint', 'dist', 'trgepc', 'obspos(3)', and 'found'
#                return with the same vectorization measure (N) as 'et'.
#
#-Particulars
#
#   A sister version of this routine exists named mice_srfxpt that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine srfxpt_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   NAIF_IDS.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # srfxpt
#       (spoint::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        dist::Float64,  # Ptr{SpiceDouble}
#        trgepc::Float64,  # Ptr{SpiceDouble}
#        obspos::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        found::Int32) =   # Ptr{SpiceBoolean}
        srfxpt(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString, # Ptr{ConstSpiceChar}
            dref::AbstractString, # Ptr{ConstSpiceChar}
            dvec::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(dvec) != 3
            error("Incorrect size for parameter 7")
        end
#       allocate the output parameters
        spoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        spoint_ptr = pointer(spoint)
        dist = Array{Float64}(1);  # Ptr{SpiceDouble}
        dist_ptr = pointer(dist)
        trgepc = Array{Float64}(1);  # Ptr{SpiceDouble}
        trgepc_ptr = pointer(trgepc)
        obspos = Array{Float64,1}(3);  # Array_3_SpiceDouble
        obspos_ptr = pointer(obspos)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        dvec_t = dvec'
        dvec_ptr = pointer(dvec_t)
        
#       ccall((:srfxpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble},Ptr{SpiceDouble},Array_3_SpiceDouble,Ptr{SpiceBoolean}),method,target,et,abcorr,obsrvr,dref,dvec,spoint,dist,trgepc,obspos,found)
        ccall((:srfxpt_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Int32}),
            method,target,et,abcorr,obsrvr,dref,dvec_ptr,spoint_ptr,dist_ptr,trgepc_ptr,obspos_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return spoint, dist[1], trgepc[1], obspos, convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Assign needed constants.
#      %
#      BUSID   = -94000;
#      MGS     = -94;
#      NCORNR  = 4;
#      ABCORR  = 'LT+S';
#      CAMERA  = 'MGS_MOC_NA';
#      DREF    = 'J2000';
#      METHOD  = 'ELLIPSOID';
#      OBSRVR  = 'MGS';
#      TARGET  = 'MARS';
#      UTC     = '2003 OCT 13 06:00:00 UTC';
#
#      %
#      %    Load kernel files:
#      %
#      %       - Leapseconds kernel
#      %       - MGS SCLK kernel
#      %       - Text PCK file
#      %       - Planetary SPK file
#      %       - MGS I-kernel
#      %       - MGS spacecraft bus C-kernel
#      %       - MGS SPK file
#      %
#      cspice_furnsh( '/kernels/gen/lsk/naif0008.tls' )
#      cspice_furnsh( '/kernels/MGS/sclk/MGS_SCLKSCET.00053.tsc' )
#      cspice_furnsh( '/kernels/MGS/pck/mars_iau2000_v0.tpc' )
#      cspice_furnsh( '/kernels/gen/spk/de405s.bsp' )
#      cspice_furnsh( '/kernels/MGS/ik/moc20.ti' )
#      cspice_furnsh( '/kernels/MGS/ck/mgs_sc_ext12.bc' )
#      cspice_furnsh( '/kernels/MGS/spk/mgs_ext12.bsp' )
#
#      %
#      % Convert the UTC request time to ET (seconds past
#      % J2000, TDB).
#      %
#      et = cspice_str2et( UTC );
#
#      %
#      % Get the MGS MOC Narrow angle camera (MGS_MOC_NA)
#      % ID code.  Then look up the field of view (FOV)
#      % parameters.
#      %
#      [camid, found] = cspice_bodn2c( CAMERA );
#
#      [shape, dref, bsight, bounds] = cspice_getfov( camid, NCORNR);
#
#      disp( ' ' )
#      disp( 'Surface Intercept Locations for Camera' )
#      disp( 'FOV Boundary and Boresight Vectors'     )
#      disp( ' ' )
#
#      txt = sprintf( '   Instrument:             %s', CAMERA);
#      disp( txt )
#
#      txt = sprintf( '   Epoch:                  %s', UTC);
#      disp( txt )
#
#      txt = sprintf( '   Aberration correction:  %s', ABCORR);
#      disp( txt )
#      disp( ' ' )
#
#
#      %
#      % Now compute and display the surface intercepts for the
#      % boresight and all of the FOV boundary vectors.
#      %
#      for i=1:NCORNR+1
#
#         if( i <= NCORNR )
#
#            %
#            % 'bounds' represents a 3 X NCORNR array with each row a bounds
#            % vector. Extract the vectors from 'bounds' using as a vector
#            % segment.
#            %
#            %    corner vector 0: bounds(:,1)
#            %    corner vector 1: bounds(:,2)
#            %    corner vector 2: bounds(:,3)
#            %    corner vector 3: bounds(:,4)
#            %
#            %
#            title = sprintf( 'Corner vector %d', i );
#            dvec = bounds(:,i);
#
#         else
#
#            title = sprintf( 'Boresight vector' );
#            dvec = bsight;
#
#         end
#
#         %
#         % Compute the surface intercept point using
#         % the specified aberration corrections.
#         %
#         [spoint, dist, trgepc, obspos, found] = ...
#               srfxpt( METHOD, TARGET, et, ABCORR, OBSRVR, dref, dvec );
#
#
#         if( found )
#
#            %
#            % Convert rectangular coordinates to planetocentric
#            % latitude and longitude.  Convert radians to degrees.
#            %
#            [ radius, lon, lat ] = cspice_reclat( spoint );
#
#            lon = lon * cspice_dpr;
#            lat = lat * cspice_dpr;
#
#            %
#            % Display the results.
#            %
#            disp( title )
#            disp( ' ' )
#
#            txt = sprintf( '  Vector in %s frame = ', dref );
#            disp( txt )
#
#            txt = sprintf( '%18.10e%18.10e%18.10e', dvec );
#            disp( txt )
#            disp( ' ' )
#
#            disp( '  Intercept:' )
#            disp( ' ' )
#
#            txt = ...
#              sprintf('     Radius                   = %18.10e km', radius);
#            disp( txt )
#
#            txt = ...
#              sprintf('     Planetocentric Latitude  = %18.10e deg', lat);
#            disp( txt )
#
#            txt = ...
#              sprintf('     Planetocentric Longitude = %18.10e deg', lon);
#            disp( txt )
#
#            txt = ...
#              sprintf('     Range                    = %18.10e km', dist);
#            disp( txt )
#            disp( ' ' )
#
#         else
#
#            disp( 'Intercept not found.' )
#
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Surface Intercept Locations for Camera
#      FOV Boundary and Boresight Vectors
#
#         Instrument:             MGS_MOC_NA
#         Epoch:                  2003 OCT 13 06:00:00 UTC
#         Aberration correction:  LT+S
#
#      Corner vector 1
#
#        Vector in MGS_MOC_NA frame =
#        1.8571383810e-06 -3.8015622659e-03  9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849412615e+03
#           Planetocentric Latitude  (deg) =  -4.8477118861e+01
#           Planetocentric Longitude (deg) =  -1.2347365507e+02
#           Range                    (km)  =   3.8898362744e+02
#
#      Corner vector 2
#
#        Vector in MGS_MOC_NA frame =
#        1.8571383810e-06  3.8015622659e-03  9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849398244e+03
#           Planetocentric Latitude  (deg) =  -4.8481272936e+01
#           Planetocentric Longitude (deg) =  -1.2339839939e+02
#           Range                    (km)  =   3.8897565851e+02
#
#      Corner vector 3
#
#        Vector in MGS_MOC_NA frame =
#       -1.8571383810e-06  3.8015622659e-03  9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849398156e+03
#           Planetocentric Latitude  (deg) =  -4.8481298506e+01
#           Planetocentric Longitude (deg) =  -1.2339840260e+02
#           Range                    (km)  =   3.8897519958e+02
#
#      Corner vector 4
#
#        Vector in MGS_MOC_NA frame =
#       -1.8571383810e-06 -3.8015622659e-03  9.9999277403e-01
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849412527e+03
#           Planetocentric Latitude  (deg) =  -4.8477144435e+01
#           Planetocentric Longitude (deg) =  -1.2347365823e+02
#           Range                    (km)  =   3.8898316850e+02
#
#      Boresight vector
#
#        Vector in MGS_MOC_NA frame =
#        0.0000000000e+00  0.0000000000e+00  1.0000000000e+00
#
#        Intercept:
#
#           Radius                   (km)  =   3.3849405358e+03
#           Planetocentric Latitude  (deg) =  -4.8479216591e+01
#           Planetocentric Longitude (deg) =  -1.2343603019e+02
#           Range                    (km)  =   3.8897626607e+02
#
#-Version
#
#   -Mice Version 1.0.2, 18-MAY-2010, BVS (JPL)
#
#      Index line now states that this routine is deprecated.
#
#   -Mice Version 1.0.1, 11-NOV-2008, EDW (JPL)
#
#      Edits to header; Abstract now states that this routine is
#      deprecated.
#
#   -Mice Version 1.0.0, 03-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                            #####
#     ####    #####  #####  #     #  ######   #####
#    #          #    #    #       #  #          #
#     ####      #    #    #  #####   #####      #
#         #     #    #####  #        #          #
#    #    #     #    #   #  #        #          #
#     ####      #    #    # #######  ######     #
#
#    Convert a string to TDB seconds past the J2000 epoch
#
################################################################################
#-Abstract
#
#   str2et converts a string representing an epoch to a
#   double precision value representing the number of TDB seconds
#   past the J2000 epoch corresponding to the input epoch.
#
#-I/O
#
#   Given:
#
#      str   any scalar or NxM character array of strings recognized by
#            SPICE as an epoch.
#
#   the call:
#
#      et = str2et( str )
#
#   returns:
#
#      et   the scalar or 1XN-vector of double precision number of
#           TDB seconds past the J2000 epoch that corresponds to
#           the input 'str'.
#
#           'et' returns with the same vectorization measure (N) as 'str'.
#
#   Note: Reference the function cspice_tsetyr for information concerning
#   the translation of two digit representations of the century count.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine str2et_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # str2et
#       (et::Float64) =   # Ptr{SpiceDouble}
        str2et(
            date::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        et = Array{Float64}(1);  # Ptr{SpiceDouble}
        et_ptr = pointer(et)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:str2et_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{SpiceDouble}),date,et)
        ccall((:str2et_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{Float64}),
            date,et_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return et[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Load a leapseconds kernel.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define the epoch as a string.
#      %
#      date = 'Thu Mar 20 12:53:29 PST 1997';
#
#      %
#      % Convert a string to ephemeris time (ET).
#      %
#      et = str2et( date );
#
#      disp( 'Scalar:' )
#      txt = sprintf( '%20.8f', et );
#      disp( txt )
#
#      disp( ' ' )
#
#      %
#      % Define a vector of time strings:
#      %
#      time = strvcat( 'JD2454000.', ...
#                      'JD2464000.', ...
#                      'JD2474000.', ...
#                      'JD2484000.', ...
#                      'JD2494000.' );
#
#      %
#      % Convert the array of time strings 'time' to
#      % and array of ephemeris times 'et'.
#      %
#      et = str2et( time );
#
#      disp( 'Vector:' )
#      fprintf( '%20.8f\n', et' );
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#  MATLAB outputs:
#
#     Scalar:
#       -87836728.81438904
#
#     Vector:
#       212112064.18239054
#      1076112064.18491936
#      1940112064.18430591
#      2804112064.18263292
#      3668112064.18564129
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  #####   #####   #    #   #####
#    #       #    #  #    #  #    #  ##   #     #
#     ####   #    #  #####   #    #  # #  #     #
#         #  #    #  #    #  #####   #  # #     #
#    #    #  #    #  #    #  #       #   ##     #
#     ####    ####   #####   #       #    #     #
#
#   find sub-observer point on target body
#   find nearest point to observer on target body
#
################################################################################
#-Abstract
#
#   subpnt computes the rectangular coordinates of the
#   sub-observer point on a target body at a specified epoch,
#   optionally corrected for light time and stellar aberration.
#
#   This routine supersedes cspice_subpt, which does not have an input
#   argument for the target body-fixed frame name.
#
#-I/O
#
#   Given:
#
#      method   a scalar string providing parameters defining
#               the computation method to be used.
#
#               The supported values of 'method' are listed below.
#               Please note that the colon is a required delimiter;
#               using a blank will not work.
#
#                     'Near point: ellipsoid'   The sub-observer point
#                                               computation uses a
#                                               triaxial ellipsoid to
#                                               model the surface of the
#                                               target body. The
#                                               sub-observer point is
#                                               defined as the nearest
#                                               point on the target
#                                               relative to the observer.
#
#                     'Intercept: ellipsoid'    The sub-observer point
#                                               computation uses a
#                                               triaxial ellipsoid to
#                                               model the surface of the
#                                               target body. The
#                                               sub-observer point is
#                                               defined as the target
#                                               surface intercept of the
#                                               line containing the
#                                               observer and the
#                                               target's center.
#
#               Neither case nor white space are significant in
#               'method'. For example, the string
#
#                    ' nearpoint:ELLIPSOID '
#
#               is valid.
#
#      target   the scalar string name of the target body. The target
#               body is an ephemeris object (its trajectory is given by
#               SPK data), and is an extended object.
#
#               The string 'target' is case-insensitive, and leading
#               and trailing blanks in 'target' are not significant.
#               Optionally, you may supply a string containing the
#               integer ID code for the object. For example both
#               'MOON' and '301' are legitimate strings that indicate
#               the moon is the target body.
#
#               When the target body's surface is represented by a
#               tri-axial ellipsoid, this routine assumes that a
#               kernel variable representing the ellipsoid's radii is
#               present in the kernel pool. Normally the kernel
#               variable would be defined by loading a PCK file.
#
#
#      et       the double precision scalar epoch, expressed as seconds
#               past J2000 TDB, of the observer: 'et' is
#               the epoch at which the observer's state is computed.
#
#               When aberration corrections are not used, 'et' is also
#               the epoch at which the position and orientation of
#               the target body are computed.
#
#               When aberration corrections are used, 'et' is the epoch
#               at which the observer's state relative to the solar
#               system barycenter is computed; in this case the
#               position and orientation of the target body are
#               computed at et-lt or et+lt, where 'lt' is the one-way
#               light time between the sub-observer point and the
#               observer, and the sign applied to 'lt' depends on the
#               selected correction. See the description of 'abcorr'
#               below for details.
#
#      fixref   the scalar string name of the body-fixed, body-centered
#               reference frame associated with the target body.
#               The output sub-observer point 'spoint' will be
#               expressed relative to this reference frame.
#
#      abcorr   the scalar string aberration correction to apply
#               when computing the observer-target state and the
#               orientation of the target body.
#
#               For remote sensing applications, where the apparent
#               sub-observer point seen by the observer is desired,
#               normally either of the corrections
#
#                     'LT+S'
#                     'CN+S'
#
#               should be used. These and the other supported options
#               are described below. 'abcorr' may be any of the
#               following:
#
#                     'NONE'     Apply no correction. Return the
#                                geometric sub-observer point on the
#                                target body.
#
#               Let 'lt' represent the one-way light time between the
#               observer and the sub-observer point (note: NOT
#               between the observer and the target body's center).
#               The following values of 'abcorr' apply to the
#               "reception" case in which photons depart from the
#               sub-observer point's location at the light-time
#               corrected epoch et-lt and *arrive* at the observer's
#               location at 'et':
#
#                     'LT'       Correct for one-way light time (also
#                                called "planetary aberration") using a
#                                Newtonian formulation. This correction
#                                yields the location of sub-observer
#                                point at the moment it emitted photons
#                                arriving at the observer at 'et'.
#
#                                The light time correction uses an
#                                iterative solution of the light time
#                                equation. The solution invoked by the
#                                'LT' option uses one iteration.
#
#                                Both the target position as seen by the
#                                observer, and rotation of the target
#                                body, are corrected for light time.
#
#                     'LT+S'     Correct for one-way light time and
#                                stellar aberration using a Newtonian
#                                formulation. This option modifies the
#                                state obtained with the 'LT' option to
#                                account for the observer's velocity
#                                relative to the solar system
#                                barycenter. The result is the apparent
#                                sub-observer point as seen by the
#                                observer.
#
#                     'CN'       Converged Newtonian light time
#                                correction. In solving the light time
#                                equation, the 'CN' correction iterates
#                                until the solution converges. Both the
#                                position and rotation of the target
#                                body are corrected for light time.
#
#                     'CN+S'     Converged Newtonian light time and
#                                stellar aberration corrections. This
#                                option produces a solution that is at
#                                least as accurate at that obtainable
#                                with the 'LT+S' option. Whether the 'CN+S'
#                                solution is substantially more accurate
#                                depends on the geometry of the
#                                participating objects and on the
#                                accuracy of the input data. In all
#                                cases this routine will execute more
#                                slowly when a converged solution is
#                                computed.
#
#               The following values of 'abcorr' apply to the
#               "transmission" case in which photons *depart* from
#               the observer's location at 'et' and arrive at the
#               sub-observer point at the light-time corrected epoch
#               et+lt:
#
#                     'XLT'      "Transmission" case: correct for
#                                 one-way light time using a Newtonian
#                                 formulation. This correction yields the
#                                sub-observer location at the moment it
#                                receives photons emitted from the
#                                observer's location at 'et'.
#
#                                The light time correction uses an
#                                iterative solution of the light time
#                                equation. The solution invoked by the
#                                'LT' option uses one iteration.
#
#                                Both the target position as seen by the
#                                observer, and rotation of the target
#                                body, are corrected for light time.
#
#                     'XLT+S'    "Transmission" case: correct for
#                                one-way light time and stellar
#                                aberration using a Newtonian
#                                formulation  This option modifies the
#                                sub-observer point obtained with the
#                                'XLT' option to account for the
#                                observer's velocity relative to the
#                                solar system barycenter.
#
#                     'XCN'      Converged Newtonian light time
#                                correction. This is the same as XLT
#                                correction but with further iterations
#                                to a converged Newtonian light time
#                                solution.
#
#                     'XCN+S'    "Transmission" case: converged
#                                Newtonian light time and stellar
#                                aberration corrections.
#
#      obsrvr   the scalar string name of the observing body. The
#               observing body is an ephemeris object: it typically
#               is a spacecraft, the earth, or a surface point on the
#               earth. 'obsrvr' is case-insensitive, and leading and
#               'obsrvr' are not significant. Optionally, you may
#               trailing blanks in supply a string containing the integer
#               ID code for the object. For example both 'MOON' and '301'
#               are legitimate strings that indicate the Moon is the
#               observer.
#
#   the call:
#
#      [spoint, trgepc, srfvec] = subpnt( method, target, ...
#                                                et,     fixref, ...
#                                                abcorr, obsrvr)
#
#   returns:
#
#      spoint   a double precision 3x1 array defining the sub-observer point
#               on the target body.
#
#               The sub-observer point is defined either as the point
#               on the target body that is closest to the observer,
#               or the target surface intercept of the line from the
#               observer to the target's center; the input argument
#               'method' selects the definition to be used.
#
#               'spoint' is expressed in Cartesian coordinates,
#               relative to the body-fixed target frame designated by
#               'fixref'. The body-fixed target frame is evaluated at
#               the sub-observer epoch 'trgepc' (see description below).
#
#               When light time correction is used, the duration of
#               light travel between 'spoint' to the observer is
#               considered to be the one way light time.
#
#               When aberration corrections are used, 'spoint' is
#               computed using target body position and orientation
#               that have been adjusted for the corrections
#               applicable to 'spoint' itself rather than to the target
#               body's center. In particular, if the stellar
#               aberration correction applicable to 'spoint' is
#               represented by a shift vector 's', then the light-time
#               corrected position of the target is shifted by 's'
#               before the sub-observer point is computed.
#
#               The components of 'spoint' have units of km.
#
#      trgepc   the scalar double precision "sub-observer point epoch."
#              'trgepc' is defined as follows: letting 'lt' be the one-way
#               light time between the observer and the sub-observer point,
#               'trgepc' is the epoch et-lt, et+lt, or 'et' depending on
#               whether the requested aberration correction is,
#               respectively, for received radiation, transmitted
#               radiation, or omitted. 'lt' is computed using the
#               method indicated by 'abcorr'.
#
#              'trgepc' is expressed as seconds past J2000 TDB.
#
#      srfvec   a double precision 3x1 array defining the position vector
#               from the observer at 'et' to 'spoint'. 'srfvec'
#               is expressed in the target body-fixed  reference frame
#               designated by 'fixref', evaluated at  'trgepc'.
#
#               The components of 'srfvec' are given in units of km.
#
#               One can use the CSPICE function vnorm_c to obtain the
#               distance between the observer and 'spoint':
#
#                  dist = norm( srfvec )
#
#               The observer's position 'obspos', relative to the
#               target body's center, where the center's position is
#               corrected for aberration effects as indicated by
#               'abcorr', can be computed with:
#
#                  obspos = spoint - srfvec
#
#               To transform the vector 'srfvec' from a reference frame
#               'fixref' at time 'trgepc' to a time-dependent reference
#               frame 'ref' at time 'et', the routine 'cspice_pxfrm2' should be
#               called. Let 'xform' be the 3x3 matrix representing the
#               rotation from the reference frame 'fixref' at time
#               'trgepc' to the reference frame 'ref' at time 'et'. Then
#               'srfvec' can be transformed to the result 'refvec' as
#               follows:
#
#                  xform  = cspice_pxfrm2 ( fixref, ref, trgepc, et )
#                  refvec = xform * srfvec
#
#-Particulars
#
#   A sister version of this routine exists named mice_subpnt that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine subpnt_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # subpnt
#       (spoint::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        trgepc::Float64,  # Ptr{SpiceDouble}
#        srfvec::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        subpnt(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            fixref::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        spoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        spoint_ptr = pointer(spoint)
        trgepc = Array{Float64}(1);  # Ptr{SpiceDouble}
        trgepc_ptr = pointer(trgepc)
        srfvec = Array{Float64,1}(3);  # Array_3_SpiceDouble
        srfvec_ptr = pointer(srfvec)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:subpnt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_SpiceDouble,Ptr{SpiceDouble},Array_3_SpiceDouble),method,target,et,fixref,abcorr,obsrvr,spoint,trgepc,srfvec)
        ccall((:subpnt_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            method,target,et,fixref,abcorr,obsrvr,spoint_ptr,trgepc_ptr,srfvec_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return spoint, trgepc[1], srfvec
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Find the sub-Earth point on Mars for a specified time. Perform
#      the computation twice, using both the "intercept" and "near
#      point" options. Display the location of both the Earth and the
#      sub-Earth point using both planetocentric and planetographic
#      coordinates.
#
#      %
#      % Load kernel files via the meta-kernel.
#      %
#      cspice_furnsh( 'standard.tm' );
#
#      %
#      % Convert the UTC request time to ET (seconds past
#      % J2000, TDB).
#      %
#      et = cspice_str2et( '2008 aug 11 00:00:00' );
#
#      %
#      % Look up the target body's radii. We'll use these to
#      % convert Cartesian to planetodetic coordinates. Use
#      % the radii to compute the flattening coefficient of
#      % the reference ellipsoid.
#      %
#      radii  = cspice_bodvrd( 'MARS', 'RADII', 3 );
#
#      %
#      % Let RE and RP be, respectively, the equatorial and
#      % polar radii of the target.
#      %
#      re = radii(1);
#      rp = radii(3);
#      f = ( re-rp)/re;
#
#      %
#      % Compute sub-observer point using light time and stellar
#      % aberration corrections. Use the "target surface intercept"
#      % definition of the sub-observer point on the first loop
#      % iteration, and use the "near point" definition on the
#      % second.
#      %
#
#      method = { 'Intercept:  ellipsoid', 'Near point: ellipsoid' };
#
#      for i=1:2
#
#         [spoint, trgepc, srfvec] = subpnt( method(i), ...
#                         'MARS', et, 'IAU_MARS', 'LT+S', 'EARTH' );
#
#         %
#         % Compute the observer's distance from SPOINT.
#         %
#         odist = norm(srfvec);
#
#         %
#         % Convert the sub-observer point's rectangular coordinates
#         % to planetographic longitude, latitude and altitude.
#         % Convert radians to degrees.
#         %
#         [ spglon, spglat, spgalt] = cspice_recpgr( 'mars', spoint, re, f );
#
#         spglon = spglon * cspice_dpr;
#         spglat = spglat * cspice_dpr;
#
#         %
#         % Convert sub-observer point's rectangular coordinates to
#         % planetocentric radius, longitude, and latitude. Convert
#         % radians to degrees.
#         %
#         [ spcrad, spclon, spclat ] =cspice_reclat( spoint ) ;
#
#         spclon = spclon * cspice_dpr;
#         spclat = spclat * cspice_dpr;
#
#         %
#         % Compute the observer's position relative to the center of the
#         % target, where the center's location has been adjusted using
#         % the aberration corrections applicable to the sub-point.
#         % Express the observer's location in geodetic coordinates.
#         %
#         obspos = spoint - srfvec;
#
#         [ opglon, opglat, opgalt] = cspice_recpgr( 'mars', obspos, re, f );
#
#         opglon = opglon * cspice_dpr;
#         opglat = opglat * cspice_dpr;
#
#         %
#         % Convert the observer's rectangular coordinates to planetodetic
#         % longitude, latitude and altitude. Convert radians to degrees.
#         %
#         [opcrad, opclon, opclat] = cspice_reclat( obspos ) ;
#
#         opclon = opclon * cspice_dpr;
#         opclat = opclat * cspice_dpr;
#
#         fprintf( 'Computational Method %s\n\n', char(method(i)) )
#
#         fprintf( 'Observer altitude                      %21.9f km\n', ...
#                                                                   opgalt )
#         fprintf( 'Length of SRFVEC                       %21.9f km\n', ...
#                                                                   odist  )
#         fprintf( 'Sub-observer point altitude            %21.9f km\n', ...
#                                                                   spgalt )
#         fprintf( 'Sub-observer planetographic longitude  %21.9f deg\n', ...
#                                                                   spglon )
#         fprintf( 'Observer planetographic longitude      %21.9f deg\n', ...
#                                                                   opglon )
#         fprintf( 'Sub-observer planetographic latitude   %21.9f deg\n', ...
#                                                                   spglat )
#         fprintf( 'Observer planetographic latitude       %21.9f deg\n', ...
#                                                                   opglat )
#         fprintf( 'Sub-observer planetocentric longitude  %21.9f deg\n', ...
#                                                                   spclon )
#         fprintf( 'Observer planetocentric longitude      %21.9f deg\n', ...
#                                                                   opclon )
#         fprintf( 'Sub-observer planetocentric latitude   %21.9f deg\n', ...
#                                                                   spclat )
#         fprintf( 'Observer planetocentric latitude       %21.9f deg\n', ...
#                                                                   opclat )
#         fprintf( '\n')
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Computational Method Intercept:  ellipsoid
#
#      Observer altitude                        349199089.604656994
#      Length of SRFVEC                         349199089.641352594
#      Sub-observer point altitude                     -0.000000000
#      Sub-observer planetographic longitude          199.302304818
#      Observer planetographic longitude              199.302304818
#      Sub-observer planetographic latitude            26.262401078
#      Observer planetographic latitude                25.994936593
#      Sub-observer planetocentric longitude          160.697695182
#      Observer planetocentric longitude              160.697695182
#      Sub-observer planetocentric latitude            25.994934013
#      Observer planetocentric latitude                25.994934013
#
#      Computational Method Near point: ellipsoid
#
#      Observer altitude                        349199089.604648590
#      Length of SRFVEC                         349199089.604648590
#      Sub-observer point altitude                     -0.000000000
#      Sub-observer planetographic longitude          199.302304819
#      Observer planetographic longitude              199.302304819
#      Sub-observer planetographic latitude            25.994936593
#      Observer planetographic latitude                25.994936593
#      Sub-observer planetocentric longitude          160.697695181
#      Observer planetocentric longitude              160.697695181
#      Sub-observer planetocentric latitude            25.729407071
#      Observer planetocentric latitude                25.994934013
#
#-Version
#
#   -Mice Version 1.0.2, 25-OCT-2011, SCK (JPL)
#
#      References to the new 'cspice_pxfrm2' routine were
#      added to the 'I/O returns' section.
#
#   -Mice Version 1.0.1, 12-MAY-2009, EDW (JPL)
#
#      Corrected type in I/O call description. The call description
#      lacked the 'fixref' argument.
#
#   -Mice Version 1.0.0, 30-JAN-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  #####   #####    #####
#    #       #    #  #    #  #    #     #
#     ####   #    #  #####   #    #     #
#         #  #    #  #    #  #####      #
#    #    #  #    #  #    #  #          #
#     ####    ####   #####   #          #
#
#   DEPRECATED sub-observer point
#
################################################################################
#-Abstract
#
#   subpt determines the coordinates of the sub-observer point
#   on a target body at a particular epoch, optionally corrected
#   for planetary (light time) and stellar aberration. The call also
#   returns the observer's altitude above the target body.
#
#   Deprecated: This routine has been superseded by the routine
#   cspice_subpnt. This routine is supported for purposes of
#   backward compatibility only.
#
#-I/O
#
#   Given:
#
#      method   the scalar string name of the computation method.
#               The choices are:
#
#                  'Near point'       The sub-observer point is
#                                     defined as the nearest point on
#                                     the target relative to the
#                                     observer.
#
#                  'Intercept'        The sub-observer point is
#                                     defined as the target surface
#                                     intercept of the line
#                                     containing the observer and the
#                                     target's center.
#
#               In both cases, the intercept computation treats the
#               surface of the target body as a triaxial ellipsoid.
#               The ellipsoid's radii must be available in the kernel
#               pool.
#
#               Neither case nor white space are significant in
#               'method'.  For example, the string ' NEARPOINT' is
#               valid.
#
#      target   the scalar string name of the observed target body. 'target'
#               is case-insensitive, and leading and trailing blanks in
#               'target' are not significant. Optionally, you may supply
#               a string containing the integer ID code for the object.
#               For example both 'MOON' and '301' are legitimate strings
#               that indicate the moon is the target body.
#
#               This routine assumes that the target body is modeled by
#               a tri-axial ellipsoid, and that a PCK file containing
#               its radii has been loaded into the kernel pool via
#               cspice_furnsh.
#
#      et       the double precision scalar or 1xN array of epochs in
#               ephemeris seconds past J2000 at which to compute the
#               sub-observer point on the target body.
#
#      abcorr   the scalar string indicating the aberration corrections to
#               apply when computing the observer-target state.  'abcorr'
#               may be any of the following.
#
#                  'NONE'     Apply no correction. Return the
#                             geometric sub-observer point on the
#                             target body.
#
#                  'LT'       Correct for planetary (light time)
#                             aberration.  Both the state and rotation
#                             of the target body are corrected for
#                             light time.
#
#                  'LT+S'     Correct for planetary (light time) and
#                             stellar aberration. Both the state and
#                             rotation of the target body are
#                             corrected for light time.
#
#                  'CN'       Converged Newtonian light time correction.
#                             This option produces a solution that is at
#                             least as accurate at that obtainable 
#                             with the 'LT' option. Whether the 'CN' 
#                             solution is substantially more accurate 
#                             depends on the geometry of the 
#                             participating objects and on the 
#                             accuracy of the input data. In all 
#                             cases this routine will execute more 
#                             slowly when a converged solution is 
#                             computed. See the section titled "The 
#                             Computation of Light Time" in the SPK
#                             Required Reading document spk.req for 
#                             details.
#
#                  'CN+S'     Converged Newtonian light time
#                             and stellar aberration corrections. 
#                             Both the state and rotation of the
#                             target body are corrected for light
#                             time.
#
#      obsrvr   the scalar string name of the observing body.  This is
#               typically a spacecraft, the earth, or a surface point on the
#               earth. 'obsrvr' is case-insensitive, and leading and trailing
#               blanks in 'obsrvr' are not significant. Optionally, you may
#               supply a string containing the integer ID code for the object.
#               For example both 'EARTH' and '399' are legitimate strings that
#               indicate the earth is the observer.
#
#   the call:
#
#      [spoint, alt] = subpt( method, target, et, abcorr, obsrvr)
#
#   returns:
#
#      spoint   a double precision 3x1 array or 3xN array of
#               coordinates of the 'obsrvr' subpoint on 'target'
#               at 'et'  expressed relative to the body-fixed frame of the
#               target body.
#
#               The sub-observer point is defined either as the point
#               on the target body that is closest to the observer,
#               or the target surface intercept of the line from the
#               observer to the target's center; the input argument
#               'method' selects the definition to be used.
#
#               The body-fixed frame, which is time-dependent, is
#               evaluated at 'et' if 'abcorr' is 'NONE'; otherwise the
#               frame is evaluated at et-lt, where 'lt' is the one-way
#               light time from target to observer.
#
#               The state of the target body is corrected for
#               aberration as specified by 'abcorr'; the corrected
#               state is used in the geometric computation.  As
#               indicated above, the rotation of the target is
#               retarded by one-way light time if 'abcorr' specifies
#               that light time correction is to be done.
#
#      alt      the double precision scalar or Nx1 array of altitudes of
#               'obsrvr' above 'target'. When 'method' specifies a
#               "near point" computation, 'alt' is truly altitude in the
#               standard geometric sense:  the length of a segment dropped
#               from the observer to the target's surface, such that the
#               segment is perpendicular to the surface at the
#               contact point 'spoint'.
#
#               When 'method' specifies an "intercept" computation, 'alt'
#               is still the length of the segment from the observer
#               to the surface point 'spoint', but this segment in
#               general is not perpendicular to the surface.
#               above 'target'
#
#               'spoint' and 'alt' return with the same vectorization
#                measure (N) as 'et'.
#
#-Particulars
#
#   A sister version of this routine exists named mice_subpt that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine subpt_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # subpt
#       (spoint::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        alt::Float64) =   # Ptr{SpiceDouble}
        subpt(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        spoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        spoint_ptr = pointer(spoint)
        alt = Array{Float64}(1);  # Ptr{SpiceDouble}
        alt_ptr = pointer(alt)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:subpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_SpiceDouble,Ptr{SpiceDouble}),method,target,et,abcorr,obsrvr,spoint,alt)
        ccall((:subpt_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64}),
            method,target,et,abcorr,obsrvr,spoint_ptr,alt_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return spoint, alt[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example(1):
#
#      %
#      % Find the sub point position of the moon on the earth at
#      % epoch JAN 1, 2006 using the "near point" then the "intercept"
#      % options. Apply light time correction to return apparent position.
#      %
#      %
#      % Load the meta kernel listing the needed SPK, PCK, LSK
#      % kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Calculate the location of the sub point of the moon
#      % on the earth .
#
#      et = cspice_str2et( 'JAN 1, 2006' );
#
#      %
#      % First use option 'Near Point'
#      %
#      [point1,alt1] = subpt( 'near point', 'earth', et, 'lt+s', 'moon');
#
#      disp( 'Sub-point location  coordinates - near point:' )
#      fprintf( '    %15.8f\n', point1 )
#
#      disp( 'Sub-point observer altitude:' )
#      fprintf( '    %15.8f\n', alt1 )
#
#      disp(' ')
#
#      %
#      % Now use option 'Intercept'
#      %
#      [point2,alt2] = subpt( 'intercept', 'earth', et, 'lt+s', 'moon');
#
#      disp( 'Sub-point location coordinates - intercept:' )
#      fprintf( '    %15.8f\n', point2 )
#
#      disp( 'Sub-point observer altitude:' )
#      fprintf( '    %15.8f\n', alt2 )
#
#      %
#      % Calculate the Euclidean distance between the two locations
#      % and the angular separation between the position vectors.
#      %
#      dist = norm( point1 - point2);
#      sep  = cspice_vsep(point1, point2 )*cspice_dpr;
#
#      disp(' ')
#
#      fprintf( 'Distance between locations           : %8.5f km\n', dist);
#      fprintf( 'Angular separation between locations : %8.5f deg\n', sep );
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#        Sub-point location  coordinates - near point:
#             -5532.84463404
#             -1443.48660124
#             -2816.23526241
#        Sub-point observer altitude:
#            356091.70776573
#
#        Sub-point location coordinates - intercept
#             -5525.64311958
#             -1441.60776851
#             -2831.19585471
#        Sub-point observer altitude:
#            356091.73014965
#
#        Distance between locations           : 16.70961 km
#        Angular separation between locations :  0.15020 deg
#
#   Example(2):
#
#      %
#      % Find the sub body position of the moon on the earth at
#      % at epoch JAN 1, 2006 and for the next 12 months. Use the
#      % 'near point' option to calculate the physically
#      % closest point between the two bodies.
#      %
#      % Load the meta kernel listing the needed SPK, PCK, LSK
#      % kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Convert the calendar string to ephemeris time.
#      %
#      et0 = cspice_str2et( 'JAN 1, 2006' );
#
#      %
#      % Fill an array with epochs, start with the epoch above then
#      % epochs in steps on one month ( thirty days in seconds)
#      %
#      et  = [0:12]*cspice_spd*30. + et0;
#
#      %
#      % Calculate the nearpoint of the moon with respect to earth at
#      % the epochs defined in 'et'.
#      %
#      [point,alt] = subpt( 'near point', 'earth', et, 'lt+s', 'moon');
#
#      %
#      % Convert the subpoint coordinates to lat/lon expressed in degrees with
#      % the radius.
#      %
#      % Note, 'radius' and 'alt' do not refer to the same quantity.
#      %
#      [radius, longitude, latitude] = cspice_reclat(point);
#      longitude                     = longitude * cspice_dpr;
#      latitude                      = latitude  * cspice_dpr;
#
#      %
#      % Convert the 'et' epochs to calendar format.
#      %
#      utc = cspice_et2utc( et, 'C', 3 );
#
#      for n=1:13
#         txt = sprintf( 'Moon subpoint epoch: %s', utc(n,:) );
#         disp( txt )
#
#         txt = sprintf( '              : longitude %8.4f deg', longitude(n) );
#         disp( txt )
#
#         txt = sprintf( '              : latitude  %8.4f deg', latitude(n) );
#         disp( txt )
#         disp( ' ' )
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#                 ... partial output ...
#
#      Moon subpoint epoch: 2006 JUL 30 00:00:00.001
#                    (deg): longitude -127.7548
#                    (deg): latitude   -0.1948
#
#      Moon subpoint epoch: 2006 AUG 29 00:00:00.001
#                    (deg): longitude -128.2727
#                    (deg): latitude  -15.0349
#
#      Moon subpoint epoch: 2006 SEP 28 00:00:00.002
#                    (deg): longitude -123.9021
#                    (deg): latitude  -25.9738
#
#      Moon subpoint epoch: 2006 OCT 28 00:00:00.001
#                    (deg): longitude -113.7475
#                    (deg): latitude  -27.7753
#
#      Moon subpoint epoch: 2006 NOV 27 00:00:00.001
#                    (deg): longitude -104.0459
#                    (deg): latitude  -17.9194
#
#      Moon subpoint epoch: 2006 DEC 27 00:00:00.000
#                    (deg): longitude -98.2728
#                    (deg): latitude   -0.5411
#
#-Version
#
#   -Mice Version 1.0.3, 23-JUN-2014, NJB (JPL)
#
#      Updated description of converged Newtonian light time
#      correction. Replaced double quotes with single quotes
#      in constant strings appearing in comments.
#
#   -Mice Version 1.0.2, 18-MAY-2010, BVS (JPL)
#
#      Index line now states that this routine is deprecated.
#
#   -Mice Version 1.0.1, 11-NOV-2008, EDW (JPL)
#
#      Edits to header; Abstract now states that this routine is
#      deprecated.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  #####    ####   #       #####
#    #       #    #  #    #  #       #       #    #
#     ####   #    #  #####    ####   #       #    #
#         #  #    #  #    #       #  #       #####
#    #    #  #    #  #    #  #    #  #       #   #
#     ####    ####   #####    ####   ######  #    #
#
#   find sub-solar point on target body
#   find nearest point to Sun on target body
#
################################################################################
#-Abstract
#
#   subslr compute the rectangular coordinates of the sub-solar
#   point on a target body at a specified epoch, optionally corrected for
#   light time and stellar aberration.
#
#   This routine supersedes cspice_subsol, which does not have an input
#   argument for the target body-fixed frame name.
#
#-I/O
#
#   Given:
#
#      method   a scalar string providing parameters defining
#               the computation method to be used.
#
#               The supported values of 'method' are listed below.
#               Please note that the colon is a required delimiter;
#               using a blank will not work.
#
#                     'Near point: ellipsoid'   The sub-solar point
#                                               computation uses a
#                                               triaxial ellipsoid to
#                                               model the surface of the
#                                               target body. The
#                                               sub-solar point is
#                                               defined as the nearest
#                                               point on the target
#                                               relative to the Sun.
#
#                     'Intercept: ellipsoid'    The sub-solar point
#                                               computation uses a
#                                               triaxial ellipsoid to
#                                               model the surface of the
#                                               target body. The
#                                               sub-solar point is
#                                               defined as the target
#                                               surface intercept of the
#                                               line containing the
#                                               Sun and the
#                                               target's center.
#
#               Neither case nor white space are significant in
#               'method'. For example, the string
#
#                    ' nearpoint:ELLIPSOID '
#
#               is valid.
#
#      target   the scalar string name of the target body. The target
#               body is an ephemeris object (its trajectory is given by
#               SPK data), and is an extended object.
#
#               The string 'target' is case-insensitive, and leading
#               and trailing blanks in 'target' are not significant.
#               Optionally, you may supply a string containing the
#               integer ID code for the object. For example both
#               'MOON' and '301' are legitimate strings that indicate
#               the moon is the target body.
#
#               When the target body's surface is represented by a
#               tri-axial ellipsoid, this routine assumes that a
#               kernel variable representing the ellipsoid's radii is
#               present in the kernel pool. Normally the kernel
#               variable would be defined by loading a PCK file.
#
#
#      et       the double precision scalar epoch, expressed as seconds
#               past J2000 TDB, of the observer: 'et' is
#               the epoch at which the observer's state is computed.
#
#               When aberration corrections are not used, 'et' is also
#               the epoch at which the position and orientation of
#               the target body are computed.
#
#               When aberration corrections are used, 'et' is the epoch
#               at which the observer's state relative to the solar
#               system barycenter is computed; in this case the
#               position and orientation of the target body are
#               computed at et-lt or et+lt, where 'lt' is the one-way
#               light time between the sub-solar point and the
#               observer, and the sign applied to 'lt' depends on the
#               selected correction. See the description of 'abcorr'
#               below for details.
#
#      fixref   the scalar string name of the body-fixed, body-centered
#               reference frame associated with the target body.
#               The output sub-solar point 'spoint' will be
#               expressed relative to this reference frame.
#
#      abcorr   the scalar string aberration correction to apply
#               when computing the observer-target state and the
#               orientation of the target body.
#
#               For remote sensing applications, where the apparent
#               sub-solar point seen by the observer is desired,
#               normally either of the corrections
#
#                     'LT+S'
#                     'CN+S'
#
#               should be used. These and the other supported options
#               are described below. 'abcorr' may be any of the
#               following:
#
#                     'NONE'     Apply no correction. Return the
#                                geometric sub-solar point on the
#                                target body.
#
#               Let 'lt' represent the one-way light time between the
#               observer and the sub-solar point (note: NOT
#               between the observer and the target body's center).
#               The following values of 'abcorr' apply to the
#               "reception" case in which photons depart from the
#               sub-solar point's location at the light-time
#               corrected epoch et-lt and *arrive* at the observer's
#               location at 'et':
#
#                     'LT'       Correct for one-way light time (also
#                                called "planetary aberration") using a
#                                Newtonian formulation. This correction
#                                yields the location of sub-solar
#                                point at the moment it emitted photons
#                                arriving at the observer at 'et'.
#
#                                The light time correction uses an
#                                iterative solution of the light time
#                                equation. The solution invoked by the
#                                'LT' option uses one iteration.
#
#                                Both the target position as seen by the
#                                observer, and rotation of the target
#                                body, are corrected for light time.
#
#                     'LT+S'     Correct for one-way light time and
#                                stellar aberration using a Newtonian
#                                formulation. This option modifies the
#                                state obtained with the 'LT' option to
#                                account for the observer's velocity
#                                relative to the solar system
#                                barycenter. The result is the apparent
#                                sub-solar point as seen by the
#                                observer.
#
#                     'CN'       Converged Newtonian light time
#                                correction. In solving the light time
#                                equation, the 'CN' correction iterates
#                                until the solution converges. Both the
#                                position and rotation of the target
#                                body are corrected for light time.
#
#                     'CN+S'     Converged Newtonian light time and
#                                stellar aberration corrections. This
#                                option produces a solution that is at
#                                least as accurate at that obtainable
#                                with the 'LT+S' option. Whether the 'CN+S'
#                                solution is substantially more accurate
#                                depends on the geometry of the
#                                participating objects and on the
#                                accuracy of the input data. In all
#                                cases this routine will execute more
#                                slowly when a converged solution is
#                                computed.
#
#      obsrvr   the scalar string name of the observing body. The
#               observing body is an ephemeris object: it typically
#               is a spacecraft, the earth, or a surface point on the
#               earth. 'obsrvr' is case-insensitive, and leading and
#               'obsrvr' are not significant. Optionally, you may
#               trailing blanks in supply a string containing the integer
#               ID code for the object. For example both 'MOON' and '301'
#               are legitimate strings that indicate the Moon is the
#               observer.
#
#   the call:
#
#      [spoint, trgepc, srfvec] = subslr( method, target, et, ...
#                                                fixref, abcorr, obsrvr )
#
#   returns:
#
#   spoint   a double precision 3x1 array defining the sub-solar point
#            on the target body.
#
#            The sub-solar point is defined either as the point
#            on the target body that is closest to the Sun,
#            or the target surface intercept of the line from the
#            Sun to the target's center; the input argument
#            'method' selects the definition to be used.
#
#            'spoint' is expressed in Cartesian coordinates,
#            relative to the body-fixed target frame designated by
#            'fixref'. The body-fixed target frame is evaluated at
#            the sub-solar epoch 'trgepc' (see description below).
#
#            When light time correction is used, the duration of
#            light travel between 'spoint' to the observer is
#            considered to be the one way light time.
#
#            When aberration corrections are used, 'spoint' is
#            computed using target body position and orientation
#            that have been adjusted for the corrections
#            applicable to 'spoint' itself rather than to the target
#            body's center. In particular, if the stellar
#            aberration correction applicable to 'spoint' is
#            represented by a shift vector 's', then the light-time
#            corrected position of the target is shifted by 's'
#            before the sub-solar point is computed.
#
#            The components of 'spoint' have units of km.
#
#   trgepc   the scalar double precision "sub-solar point epoch."
#           'trgepc' is defined as follows: letting 'lt' be the one-way
#            light time between the observer and the sub-solar point,
#            'trgepc' is the epoch et-lt, et+lt, or 'et' depending on
#            whether the requested aberration correction is,
#            respectively, for received radiation, transmitted
#            radiation, or omitted. 'lt' is computed using the
#            method indicated by 'abcorr'.
#
#            'trgepc' is expressed as seconds past J2000 TDB.
#
#   srfvec   a double precision 3x1 array defining the position
#            vector from the observer at 'et' to 'spoint'. 'srfvec'
#            is expressed in the target body-fixed reference frame
#            designated by 'fixref', evaluated at 'trgepc'.
#
#            The components of 'srfvec' are given in units of km.
#
#            One can use the CSPICE function vnorm_c to obtain the
#            distance between the observer and 'spoint':
#
#                  dist = norm( srfvec )
#
#            The observer's position 'obspos', relative to the
#            target body's center, where the center's position is
#            corrected for aberration effects as indicated by
#            'abcorr', can be computed with:
#
#                  obspos = spoint - srfvec
#
#            To transform the vector 'srfvec' from a reference frame
#            'fixref' at time 'trgepc' to a time-dependent reference
#            frame 'ref' at time 'et', the routine 'cspice_pxfrm2' should be
#            called. Let 'xform' be the 3x3 matrix representing the
#            rotation from the reference frame 'fixref' at time
#            'trgepc' to the reference frame 'ref' at time 'et'. Then
#            'srfvec' can be transformed to the result 'refvec' as
#            follows:
#
#                  xform  = cspice_pxfrm2 ( fixref, ref, trgepc, et )
#                  refvec = xform * srfvec
#
#-Particulars
#
#   A sister version of this routine exists named mice_subslr that returns
#   the output arguments as fields in a single structure.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine subslr_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # subslr
#       (spoint::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        trgepc::Float64,  # Ptr{SpiceDouble}
#        srfvec::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        subslr(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            fixref::AbstractString, # Ptr{ConstSpiceChar}
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        spoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        spoint_ptr = pointer(spoint)
        trgepc = Array{Float64}(1);  # Ptr{SpiceDouble}
        trgepc_ptr = pointer(trgepc)
        srfvec = Array{Float64,1}(3);  # Array_3_SpiceDouble
        srfvec_ptr = pointer(srfvec)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:subslr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_SpiceDouble,Ptr{SpiceDouble},Array_3_SpiceDouble),method,target,et,fixref,abcorr,obsrvr,spoint,trgepc,srfvec)
        ccall((:subslr_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{UInt8},Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            method,target,et,fixref,abcorr,obsrvr,spoint_ptr,trgepc_ptr,srfvec_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return spoint, trgepc[1], srfvec
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Find the sub-solar point on Mars as seen from the Earth for a
#      specified time. Perform the computation twice, using both the
#      "intercept" and "near point" options. Display the locations of
#      the Sun and the sub-solar point using both planetocentric
#      and planetographic coordinates.
#
#      %
#      % Load kernel files via the meta-kernel.
#      %
#      cspice_furnsh( 'standard.tm' );
#
#      %
#      % Convert the UTC request time to ET (seconds past
#      % J2000, TDB).
#      %
#      et = cspice_str2et( '2008 aug 11 00:00:00' );
#
#      %
#      % Look up the target body's radii. We'll use these to
#      % convert Cartesian to planetodetic coordinates. Use
#      % the radii to compute the flattening coefficient of
#      % the reference ellipsoid.
#      %
#      radii  = cspice_bodvrd( 'MARS', 'RADII', 3 );
#
#      %
#      % Let RE and RP be, respectively, the equatorial and
#      % polar radii of the target.
#      %
#      re = radii(1);
#      rp = radii(3);
#      f = ( re-rp)/re;
#
#      %
#      % Compute the sub-solar point using light time and stellar
#      % aberration corrections. Use the "target surface intercept"
#      % definition of the sub-solar point on the first loop
#      % iteration, and use the "near point" definition on the
#      % second.
#      %
#      method = { 'Intercept:  ellipsoid', 'Near point: ellipsoid' };
#
#      for i=1:2
#
#         [spoint, trgepc, srfvec] = subslr( method(i), ...
#                         'MARS', et, 'IAU_MARS', 'LT+S', 'EARTH' );
#
#         %
#         % Convert the sub-solar point's rectangular coordinates
#         % to planetographic longitude, latitude and altitude.
#         % Convert radians to degrees.
#        %
#         [spglon, spglat, spgalt ] = cspice_recpgr( 'mars', spoint, re, f);
#
#         spglon = spglon * cspice_dpr;
#         spglat = spglat * cspice_dpr;
#
#         %
#         % Convert sub-solar point's rectangular coordinates to
#         % planetodetic longitude, latitude and altitude. Convert radians
#         % to degrees.
#         %
#         [ spcrad, spclon, spclat ] =cspice_reclat( spoint ) ;
#
#         spclon = spclon * cspice_dpr;
#         spclat = spclat * cspice_dpr;
#
#         %
#         % Compute the Sun's apparent position relative to the
#         % center of the target at `trgepc'. Express the Sun's
#         % location in planetographic coordinates.
#         %
#         [sunpos,  sunlt] = cspice_spkpos( 'sun', trgepc, 'iau_mars', ...
#                                                     'lt+s', 'mars');
#
#         [ supgln, supglt, supgal] = cspice_recpgr( 'mars', sunpos, re, f );
#
#         supgln = supgln * cspice_dpr;
#         supglt = supglt * cspice_dpr;
#
#         %
#         % Convert the Sun's rectangular coordinates to
#         % planetocentric radius, longitude, and latitude.
#         % Convert radians to degrees.
#         %
#         [ supcrd, supcln, supclt ] = cspice_reclat( sunpos);
#
#         supcln = supcln * cspice_dpr;
#         supclt = supclt * cspice_dpr;
#
#        fprintf( 'Computational Method %s\n\n', char(method(i)) )
#
#        fprintf( '  Sub-solar point altitude            %21.9f\n', ...
#                                                                spgalt )
#        fprintf( '  Sub-solar planetographic longitude %21.9f\n', ...
#                                                                spglon )
#        fprintf( '  Sun  planetographic longitude      %21.9f\n', ...
#                                                                supgln)
#        fprintf( '  Sub-solar planetographic latitude  %21.9f\n', ...
#                                                                spglat )
#        fprintf( '  Sun  planetographic latitude       %21.9f\n', ...
#                                                                supglt)
#        fprintf( '  Sub-solar planetocentric longitude %21.9f\n', ...
#                                                                spclon)
#        fprintf( '  Sun  planetocentric longitude      %21.9f\n', ...
#                                                                supcln )
#        fprintf( '  Sub-solar planetocentric latitude  %21.9f\n', ...
#                                                                spclat )
#        fprintf( '  Sun  planetocentric latitude       %21.9f\n', ...
#                                                                supclt )
#        fprintf( '\n')
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Computational Method Intercept:  ellipsoid
#
#        Sub-solar point altitude                     -0.000000000
#        Sub-solar planetographic longitude         175.810721418
#        Sun  planetographic longitude              175.810721416
#        Sub-solar planetographic latitude           23.668549969
#        Sun  planetographic latitude                23.420823052
#        Sub-solar planetocentric longitude        -175.810721418
#        Sun  planetocentric longitude             -175.810721416
#        Sub-solar planetocentric latitude           23.420819627
#        Sun  planetocentric latitude                23.420819627
#
#      Computational Method Near point: ellipsoid
#
#        Sub-solar point altitude                      0.000000000
#        Sub-solar planetographic longitude         175.810721404
#        Sun  planetographic longitude              175.810721402
#        Sub-solar planetographic latitude           23.420823052
#        Sun  planetographic latitude                23.420823052
#        Sub-solar planetocentric longitude        -175.810721404
#        Sun  planetocentric longitude             -175.810721402
#        Sub-solar planetocentric latitude           23.175085271
#        Sun  planetocentric latitude                23.420819627
#
#-Version
#
#   -Mice Version 1.0.2, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.1, 25-OCT-2011, SCK (JPL)
#
#      References to the new 'cspice_pxfrm2' routine were
#      added to the 'I/O returns' section. A problem description
#      was added to the 'Examples' section.
#
#   -Mice Version 1.0.0, 30-JAN-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  #####    ####    ####   #
#    #       #    #  #    #  #       #    #  #
#     ####   #    #  #####    ####   #    #  #
#         #  #    #  #    #       #  #    #  #
#    #    #  #    #  #    #  #    #  #    #  #
#     ####    ####   #####    ####    ####   ######
#
#   DEPRECATED sub-solar point
#
################################################################################
#-Abstract
#
#   subsol determines the coordinates of the sub-solar
#   point on a target  body as seen by a specified observer at a
#   specified epoch, optionally corrected for planetary (light time)
#   and stellar aberration.
#
#   Deprecated: This routine has been superseded by the routine
#   cspice_subslr. This routine is supported for purposes of
#   backward compatibility only.
#
#-I/O
#
#   Given:
#
#      method   the scalar sting specifying the computation method
#               to be used.  The choices are:
#
#                  'Near point'    The sub-solar point is defined
#                                  as the nearest point on the
#                                  target to the sun.
#
#                  'Intercept'     The sub-observer point is defined
#                                  as the target surface intercept of
#                                  the line containing the target's
#                                  center and the sun's center.
#
#               In both cases, the intercept computation treats the
#               surface of the target body as a triaxial ellipsoid.
#               The ellipsoid's radii must be available in the kernel
#               pool.
#
#               Neither case nor white space are significant in
#               method.  For example, the string ' NEARPOINT' is
#               valid.
#
#
#      target   the scalar sting describing the name of the target body.
#               'target' is case-insensitive, and leading and trailing
#               blanks in 'target' are not significant. Optionally, you
#               may supply a string containing the integer ID code for
#               the object. For example both 'MOON' and '301' are legitimate
#               strings that indicate the moon is the target body.
#
#               This routine assumes that the target body is modeled by
#               a tri-axial ellipsoid, and that a PCK file containing
#               its radii has been loaded into the kernel pool via
#               cspice_furnsh.
#
#      et       the double precision scalar or 1xN array of ephemeris
#               time expressed as ephemeris seconds past J2000 at which
#               the sub-solar point on the target body is to be
#               computed.
#
#      abcorr   the scalar string identifying the aberration corrections to
#               apply when computing the observer-target state.  'abcorr'
#               may be any of the following.
#
#                  'NONE'   Apply no correction. Return the
#                           geometric sub-solar point on the target
#                           body.
#
#                  'LT'     Correct for planetary (light time)
#                           aberration.  Both the state and rotation
#                           of the target body are corrected for one
#                           way light time from target to observer.
#
#                           The state of the sun relative to the
#                           target is corrected for one way light
#                           from the sun to the target; this state
#                           is evaluated at the epoch obtained by
#                           retarding et by the one way light time
#                           from target to observer.
#
#                  'LT+S'   Correct for planetary (light time) and
#                           stellar aberrations.  Light time
#                           corrections are the same as in the 'LT'
#                           case above.  The target state is
#                           additionally corrected for stellar
#                           aberration as seen by the observer, and
#                           the sun state is corrected for stellar
#                           aberration as seen from the target.
#
#                  'CN'     Converged Newtonian light time correction.
#                           This option produces a solution that is at
#                           least as accurate at that obtainable 
#                           with the 'LT' option. Whether the 'CN' 
#                           solution is substantially more accurate 
#                           depends on the geometry of the 
#                           participating objects and on the 
#                           accuracy of the input data. In all 
#                           cases this routine will execute more 
#                           slowly when a converged solution is 
#                           computed. See the section titled "The 
#                           Computation of Light Time" in the SPK
#                           Required Reading document spk.req for 
#                           details.
#
#                  'CN+S'   Converged Newtonian light time
#                           and stellar aberration corrections. 
#                           Light time and stellar aberration
#                           corrections are applied as in the
#                           'LT+S' case.
#
#      obsrvr   the scalar sting describing the name of the observing body.
#               This is typically a spacecraft, the earth, or a surface point
#               on the earth.  `obsrvr' is case-insensitive, and leading and
#               trailing blanks in `obsrvr' are not significant.
#               Optionally, you may supply a string containing the
#               integer ID code for the object.  For example both
#               'EARTH' and '399' are legitimate strings that indicate
#               the earth is the observer.
#
#   the call:
#
#      spoint = subsol( method, target, et, abcorr, obsrvr )
#
#   returns:
#
#      spoint   the double precision 3x1 array or 3xN array describing the
#               sub-solar point on the target body at 'et',
#               expressed relative to the body-fixed frame of the
#               target body.
#
#-Particulars
#
#   subsol computes the sub-solar point on a target body, as seen by
#   a specified observer.
#
#   There are two different popular ways to define the sub-solar point:
#   "nearest point on target to the sun" or "target surface intercept of
#   line containing target and sun."  These coincide when the target is
#   spherical and generally are distinct otherwise.
#
#   When comparing sub-point computations with results from sources
#   other than SPICE, it's essential to make sure the same geometric
#   definitions are used.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine subsol_c.
#
#   MICE.REQ
#   FRAMES.REQ
#   PCK.REQ
#   SPK.REQ
#   TIME.REQ
#
    function # subsol
#       (spoint::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        subsol(
            method::AbstractString, # Ptr{ConstSpiceChar}
            target::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64, # SpiceDouble
            abcorr::AbstractString, # Ptr{ConstSpiceChar}
            obsrvr::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        spoint = Array{Float64,1}(3);  # Array_3_SpiceDouble
        spoint_ptr = pointer(spoint)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:subsol_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_3_SpiceDouble),method,target,et,abcorr,obsrvr,spoint)
        ccall((:subsol_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{UInt8},Ptr{UInt8},Ptr{Float64}),
            method,target,et,abcorr,obsrvr,spoint_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return spoint
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Find the sub solar position on the earth as seen from the moon at
#      % at epoch JAN 1, 2006 using the 'near point' then the 'intercept'
#      % options. Apply light time correction to return apparent position.
#      %
#      % Load the meta kernel listing the needed SPK, PCK, LSK
#      % kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      et = cspice_str2et( 'JAN 1, 2006' );
#
#      %
#      % First use option 'Near Point'
#      %
#      point1 = subsol( 'near point', 'earth', et, 'lt+s', 'moon');
#
#      disp( 'Sub solar location coordinates - near point:' )
#      fprintf( '    %15.8f\n', point1 )
#
#      disp(' ')
#
#      %
#      % Now use option 'Intercept'
#      %
#      point2 = subsol( 'intercept', 'earth', et, 'lt+s', 'moon');
#
#      disp( 'Sub solar location coordinates - intercept' )
#      fprintf( '    %15.8f\n', point2 )
#
#      %
#      % Calculate the Euclidean distance between the two locations
#      % and the angular separation between the position vectors.
#      %
#      dist = norm( point1 - point2);
#      sep  = cspice_vsep(point1, point2 )*cspice_dpr;
#
#      disp(' ')
#
#      fprintf( 'Distance between locations            (km): %8.5f\n', dist);
#      fprintf( 'Angular separation between locations (deg): %8.5f\n', sep );
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#     Sub solar location coordinates - near point:
#          -5872.12723742
#            -91.14115623
#          -2479.72440750
#
#     Sub solar location coordinates - intercept
#          -5866.09275043
#            -91.04749509
#          -2493.87447851
#
#     Distance between locations            (km): 15.38338
#     Angular separation between locations (deg):  0.13826
#
#-Version
#
#   -Mice Version 1.0.3, 23-JUN-2014, NJB (JPL)
#
#      Updated description of converged Newtonian light time
#      correction.
#
#   -Mice Version 1.0.2, 18-MAY-2010, BVS (JPL)
#
#      Index line now states that this routine is deprecated.
#
#   -Mice Version 1.0.1, 11-NOV-2008, EDW (JPL)
#
#      Edits to header; Abstract now states that this routine is
#      deprecated.
#
#   -Mice Version 1.0.0, 07-MAR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  #####   ######  #    #  #    #
#    #       #    #  #    #  #       ##   #  ##  ##
#     ####   #    #  #    #  #####   # #  #  # ## #
#         #  #    #  #####   #       #  # #  #    #
#    #    #  #    #  #   #   #       #   ##  #    #
#     ####    ####   #    #  #       #    #  #    #
#
#   surface normal vector on an ellipsoid
#
################################################################################
#-Abstract
#
#   surfnm computes the double precision, outward-pointing
#   normal unit 3-vector at a point defined on the surface of an
#   ellipsoid.
#
#-I/O
#
#   Given:
#
#      a,       the scalar double precision values of the ellipsoid's
#      b,       triaxial radii ellipsoid, where:
#      c
#                  'a' is length in kilometers of the semi-axis of the ellipsoid
#                   parallel to the x-axis of the body-fixed reference frame
#
#                  'b' is length in kilometers of the semi-axis of the ellipsoid
#                   parallel to the y-axis of the body-fixed reference frame
#
#                  'c' is length in kilometers of the semi-axis of the ellipsoid
#                   parallel to the z-axis of the body-fixed reference frame
#
#      point   a double precision 3-vector or a 3xN array of 3-vectors defining
#              some location(s) on the ellipsoid
#
#   the call:
#
#      normal = surfnm( a, b, c, point)
#
#   returns:
#
#      normal   a double precision unit 3-vector or 3XN array of unit vectors
#               normal to the ellipsoid at 'point' in the direction away
#               from the ellipsoid
#
#               'normal' returns with the same vectorization measure (N)
#                as 'point'.
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine surfnm_c.
#
#   MICE.REQ
#
    function # surfnm
#       (normal::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        surfnm(
            a::Float64, # SpiceDouble
            b::Float64, # SpiceDouble
            c::Float64, # SpiceDouble
            point::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(point) != 3
            error("Incorrect size for parameter 4")
        end
#       allocate the output parameters
        normal = Array{Float64,1}(3);  # Array_3_SpiceDouble
        normal_ptr = pointer(normal)
        
#       make transposed copies of all input arrays and their pointers
        point_t = point'
        point_ptr = pointer(point_t)
        
#       ccall((:surfnm_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceDouble,SpiceDouble,SpiceDouble,Array_3_ConstSpiceDouble,Array_3_SpiceDouble),a,b,c,point,normal)
        ccall((:surfnm_c,libNasaSpice),Void,
            (Float64,Float64,Float64,Ptr{Float64},Ptr{Float64}),
            a,b,c,point_ptr,normal_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return normal
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define the radii of an ellipsoid.
#      %
#      a  =  1.;
#      b  =  2.;
#      c  =  3.;
#
#      %
#      % Select a set of locations, three 3-vectors.
#      %
#      point = [ [ 0.; 0.; 3.], [ 0.; 2.; 0.], [-1; 0; 0] ];
#
#      %
#      % Calculate the surface normal to the ellipsoid at 'point'.
#      %
#      out_norm = surfnm( a, b, c, point)
#
#   MATLAB outputs:
#
#      out_norm =
#
#           0     0    -1
#           0     1     0
#           1     0     0
#
#      Three 3-vectors:
#         the normal at (0,0,3) equals (0,0,1)
#         the normal at (0,2,0) equals (0,0,1)
#         the normal at (-1,0,0) equals (-1,0,0)
#
#-Version
#
#   -Mice Version 1.0.0, 15-JUN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  #####   ######  #####    #####
#    #       #    #  #    #  #       #    #     #
#     ####   #    #  #    #  #####   #    #     #
#         #  #    #  #####   #       #####      #
#    #    #  #    #  #   #   #       #          #
#     ####    ####   #    #  #       #          #
#
#   GF distance search
#
################################################################################
#-Abstract
#
#     surfpt determines the intersection of a line-of-sight vector with
#     the surface of an ellipsoid.
#
#-I/O
#
#    Given:
#
#       Arguments-
#
#       positn   the double precision position 3-vector position
#                of an observer with respect to the center of an
#                ellipsoid expressed in the body fixed coordinates of
#                the ellipsoid
#
#       u        the double precision direction 3-vector emanating from
#                'positn'
#
#       a,       the scalar double precision values of the ellipsoid's
#       b,       triaxial radii ellipsoid, where:
#       c
#                   'a' is length in kilometers of the semi-axis of the
#                    ellipsoid parallel to the x-axis of the body-fixed
#                    reference frame
#
#                   'b' is length in kilometers of the semi-axis of the
#                    ellipsoid parallel to the y-axis of the body-fixed
#                    reference frame
#
#                   'c' is length in kilometers of the semi-axis of the
#                    ellipsoid parallel to the z-axis of the body-fixed
#                    reference frame
#
#    the call:
#
#       [point, found] = surfpt ( positn, u, a, b, c )
#
#
#    returns:
#
#       point   a double precision 3-vector defining the location
#               on the ellipsoid at which the 'u' intercepts
#               the ellipsoid if the interception exists, 'point' returns
#               (0.d, 0.d, 0.d) if 'u' does not intersect the ellipsoid
#
#       found   a boolean indicating whether the intersection
#               between the ellipse and 'u' exists (TRUE) or
#               not (FALSE)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine surfpt_c.
#
#   MICE.REQ
#   ELLIPSES.REQ
#
    function # surfpt
#       (point::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        found::Int32) =   # Ptr{SpiceBoolean}
        surfpt(
            positn::Array{Float64,1}, # Array_3_ConstSpiceDouble
            u::Array{Float64,1}, # Array_3_ConstSpiceDouble
            a::Float64, # SpiceDouble
            b::Float64, # SpiceDouble
            c::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(positn) != 3
            error("Incorrect size for parameter 1")
        end
        if length(u) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        point = Array{Float64,1}(3);  # Array_3_SpiceDouble
        point_ptr = pointer(point)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        positn_t = positn'
        positn_ptr = pointer(positn_t)
        u_t = u'
        u_ptr = pointer(u_t)
        
#       ccall((:surfpt_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,SpiceDouble,SpiceDouble,SpiceDouble,Array_3_SpiceDouble,Ptr{SpiceBoolean}),positn,u,a,b,c,point,found)
        ccall((:surfpt_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Float64,Float64,Float64,Ptr{Float64},Ptr{Int32}),
            positn_ptr,u_ptr,a,b,c,point_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return point, convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Suppose that MGS has taken a picture of Mars at time 'etrec' with
#      the MOC narrow angle camera. We want to know the latitude and
#      longitude associated with two pixels projected to Mars'
#      surface:  the boresight and one along the boundary of the
#      field of view (FOV). Due to light time, the photons taken in
#      the picture left Mars at time 'etemit', when Mars was at a
#      different state than at time 'etrec'.
#
#      In order to solve this problem, we could use the 'cspice_sincpt'
#      routine for both pixels, but this would be slow.  Instead, we
#      will assume that the light time for each pixel is the same. We
#      will call 'cspice_sincpt' once to get the light time and surface point
#      associated with the boresight. Then, we will rotate the first
#      FOV boundary vector from the camera frame at 'etrec' to the
#      body-fixed Mars frame at 'etemit', and call the faster routine
#      'surfpt' to retrieve the surface point for the FOV boundary
#      vector.
#
#      This example problem could be extended to find the latitude
#      and longitude associated with every pixel in an instrument's
#      field of view, but this example is simplified to only solve
#      for two pixels:  the boresight and one along the boundary of
#      the field of view.
#
#      Assumptions:
#
#         1)  The light times from the surface points in the camera's
#             field of view to the camera are equal.
#
#         2)  The camera offset from the center of gravity of the
#             spacecraft is zero. If the data are more accurate
#             and precise, this assumption can be easily discarded.
#
#         3)  An ellipsoid shape model for the target body is
#             sufficient.
#
#         4)  The boundary field of view vector returned from 'cspice_getfov'
#             is associated with a boundary field of view pixel. If
#             this example were extended to include a geometric camera
#             model, this assumption would not be needed since the
#             direction vectors associated with each pixel would be
#             calculated from the geometric camera model.
#
#       Example program starts here.
#
#         % --------------------- Program Setup ---------------------
#
#         metakr = 'mgs_ex.tm';
#         camera = 'MGS_MOC_NA';
#         NCORNR = 4;
#         ABCORR = 'CN+S';
#
#         %
#         % Load kernels
#         %
#         cspice_furnsh( metakr );
#
#         %
#         % Convert the time the picture was taken from a
#         % UTC time string to seconds past J2000, TDB.
#         %
#         etrec = cspice_str2et( '2003 OCT 13 06:00:00 UTC' );
#
#         %
#         % Assume the one-way light times from different
#         % surface points on Mars to MGS within the camera's
#         % FOV are equal. This means the photons that make
#         % up different pixels were all emitted from Mars at
#         % 'etemit' and received by MGS at 'etrec'.  It would be
#         % slow to process images using 'cspice_sincpt' for every
#         % pixel.  Instead, we will use 'cspice_sincpt' on the
#         % boresight pixel and use 'surfpt' for the first FOV
#         % boundary pixel.  If this example program were extended
#         % to include all of the camera's pixels, 'surfpt' would
#         % be used for the remaining pixels.
#         %
#         % Get the MGS MOC Narrow angle camera (MGS_MOC_NA)
#         % ID code. Then look up the field of view (FOV)
#         % parameters by calling 'cspice_getfov'.
#         %
#         [camid, found] = cspice_bodn2c( camera );
#
#         if ( ~found )
#             txt = sprintf( ['SPICE(NOTRANSLATION)' ...
#                             'Could not find ID code for instrument %s.' ], ...
#                             camera );
#             error( txt )
#         end
#
#         %
#         % 'cspice_getfov' will return the name of the camera-fixed frame
#         % in the string OBSREF, the camera boresight vector in
#         % the array BSIGHT, and the FOV corner vectors in the
#         % array BOUNDS.
#         %
#         [shape, obsref, bsight, bounds] = cspice_getfov( camid, NCORNR);
#
#         fprintf( '\nObservation Reference Frame:  %s\n', obsref );
#
#         %
#         % ----------- Boresight Surface Intercept -----------
#         %
#         % Retrieve the time, surface intercept point, and vector
#         % from MGS to the boresight surface intercept point
#         % in IAU_MARS coordinates.
#         %
#         [ spoint, etemit, srfvec, found ] = ...
#                 cspice_sincpt( 'Ellipsoid', 'Mars', etrec,  'IAU_MARS', ...
#                                 ABCORR,     'MGS' , obsref,  bsight );
#
#         if ( ~found )
#             txt = sprintf(['SPICE(NOINTERCEPT)' ...
#                            'Intercept not found for boresight vector.']);
#             error( txt )
#         end
#
#         %
#         % Convert the intersection point of the boresight
#         % vector and Mars from rectangular into latitudinal
#         % coordinates. Convert radians to degrees.
#         %
#         [ radius, lon, lat ] = cspice_reclat( spoint );
#
#         lon = lon * cspice_dpr;
#         lat = lat * cspice_dpr;
#
#         fprintf( ['\n'                                         ...
#                   'Boresight surface intercept coordinates:\n' ...
#                   '    Radius    (km) :  %f\n'                 ...
#                   '    Latitude  (deg):  %f\n'                 ...
#                   '    Longitude (deg):  %f\n' ],              ...
#                    radius, lat, lon );
#
#         %
#         % ------ 1st Boundary FOV Surface Intercept (surfpt) -----
#         %
#         % Now we will transform the first FOV corner vector into the
#         % IAU_MARS frame so the surface intercept point can be
#         % calculated using surfpt, which is faster than
#         % cspice_subpnt.
#         %
#         % If this example program were extended to include all
#         % of the pixels in the camera's FOV, a few steps, such as
#         % finding the rotation matrix from the camera frame to the
#         % IAU_MARS frame, looking up the semi-axis values for Mars,
#         % and finding the position of MGS with respect to Mars could
#         % be done once and used for every pixel.
#         %
#         % Find the rotation matrix from the ray's reference
#         % frame at the time the photons were received (etrec)
#         % to IAU_MARS at the time the photons were emitted
#         % (etemit).
#         %
#         [rotate] = cspice_pxfrm2( obsref, 'IAU_MARS', etrec, etemit );
#
#         %
#         % Look up the semi-axis values for Mars.
#         %
#         radii = cspice_bodvrd( 'MARS', 'RADII', 3 );
#
#         %
#         % Find the position of the center of Mars with respect
#         % to MGS.  The position of the observer with respect
#         % to Mars is required for the call to 'surfpt'.  Note:
#         % the apparent position of MGS with respect to Mars is
#         % not the same as the negative of Mars with respect to MGS.
#         %
#         pos_mgs_wrt_mars = spoint - srfvec;
#
#         %
#         % The first boundary FOV pixel must be rotated into the
#         % IAU_MARS reference frame.
#         %
#         bndvec = rotate * bounds(:,1);
#
#         %
#         % Calculate the surface point of the boundary FOV
#         % vector.
#         %
#         [surface_point, found] = surfpt ( pos_mgs_wrt_mars, ...
#                                                  bndvec, radii(1), ...
#                                                  radii(2), radii(3) );s
#
#         if ( ~found )
#             txt = 'SPICE(NOTFOUND)Could not calculate surface point.';
#             error( txt )
#         end
#
#         surf_point_using_surfpt = surface_point;
#
#         %
#         % Convert the intersection point of the boundary
#         % FOV vector and Mars from rectangular into
#         % latitudinal coordinates. Convert radians
#         % to degrees.
#         %
#         [ radius, lon, lat ] = cspice_reclat( surface_point );
#
#         lon = lon * cspice_dpr;
#         lat = lat * cspice_dpr;
#
#         fprintf( ['\n'                                        ...
#                   'Boundary vector surface intercept\n'       ...
#                   'coordinates using surfpt:\n'        ...
#                   '    Radius    (km) :  %f\n'                ...
#                   '    Latitude  (deg):  %f\n'                ...
#                   '    Longitude (deg):  %f\n'                ...
#                   '    Emit time using boresight LT (s):  %10.9f\n'], ...
#                    radius, lat, lon, etemit );
#
#         %
#         % ------ 1st Boundary FOV Surface Intercept Verification ----
#         %
#         % For verification only, we will calculate the surface
#         % intercept coordinates for the first boundary vector
#         % using 'cspice_sincpt' and compare to the faster
#         % 'surfpt' method.
#         %
#         [ surface_point, etemit, srfvec, found ] = ...
#                  cspice_sincpt( 'Ellipsoid', 'Mars', etrec,  'IAU_MARS', ...
#                                  ABCORR,     'MGS' , obsref,  bounds(:,1) );
#
#         if ( ~found )
#             txt = sprintf( ['SPICE(NOTFOUND)' ...
#                             'Intercept not found for the boundary ' ...
#                             'FOV vector.'] );
#             error( txt )
#         end
#
#         %
#         % Convert the intersection point of the first boundary
#         % vector and Mars from rectangular into latitudinal
#         % coordinates. Convert radians to degrees.
#         %
#         [ radius, lon, lat ] = cspice_reclat( surface_point );
#
#         lon = lon * cspice_dpr;
#         lat = lat * cspice_dpr;
#
#         fprintf( ['\n'                                              ...
#                   'Boundary vector surface intercept\n'             ...
#                   'coordinates using cspice_sincpt:\n'              ...
#                   '    Radius    (km) :  %f\n'                      ...
#                   '    Latitude  (deg):  %f\n'                      ...
#                   '    Longitude (deg):  %f\n'                      ...
#                   '    Emit time using boresight LT (s):  %10.9f\n\n'], ...
#                    radius, lat, lon, etemit );
#
#         distance = cspice_vdist ( surf_point_using_surfpt, surface_point );
#
#         fprintf( [ 'Distance between surface points of the first\n' ...
#                    'boundary vector using surfpt and\n'      ...
#                    'cspice_sincpt:\n'                               ...
#                    '    Distance (mm):   %f\n' ],                   ...
#                    distance*10^6 );
#
#         %
#         % It's always good form to unload kernels after use,
#         % particularly in MATLAB due to data persistence.
#         %
#         cspice_kclear
#
#
#   MATLAB outputs:
#
#             Observation Reference Frame:  MGS_MOC_NA
#
#             Boresight surface intercept coordinates:
#                 Radius    (km) :  3384.940410
#                 Latitude  (deg):  -48.479580
#                 Longitude (deg):  -123.436454
#
#             Boundary vector surface intercept
#             coordinates using surfpt:
#                 Radius    (km) :  3384.941136
#                 Latitude  (deg):  -48.477482
#                 Longitude (deg):  -123.474080
#                 Emit time using boresight LT (s):  119296864.181059480
#
#             Boundary vector surface intercept
#             coordinates using cspice_sincpt:
#                 Radius    (km) :  3384.941136
#                 Latitude  (deg):  -48.477482
#                 Longitude (deg):  -123.474079
#                 Emit time using boresight LT (s):  119296864.181059465
#
#             Distance between surface points of the first
#             boundary vector using surfpt and
#             cspice_sincpt:
#                 Distance (mm):   32.139880
#
#-Version
#
#   -Mice Version 1.0.0, 24-OCT-2011, SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     ####   #    #  ######   ####   #####   #    #
#    #        #  #   #       #    #  #    #  ##  ##
#     ####     ##    #####   #    #  #    #  # ## #
#         #    ##    #       #    #  #####   #    #
#    #    #   #  #   #       #    #  #   #   #    #
#     ####   #    #  #        ####   #    #  #    #
#
#   Find a state transformation matrix
#
################################################################################
#-Abstract
#
#   sxform returns the state transformation matrix from one
#   frame to another at a specified epoch.
#
#-I/O
#
#   Given:
#
#      from   the scalar string name of a reference frame in which
#             a position is known.
#
#      to     the scalar string name of a reference frame in which
#             it is desired to represent the position.
#
#      et     the double precision scalar or 1XN-vector of epochs in
#             ephemeris seconds past the epoch of J2000 (TDB) at which
#             the state transformation matrix should be evaluated.
#
#   the call:
#
#      xform = sxform( from, to, et )
#
#   returns:
#
#      xform   a double precision, 6x6 or 6x6xN array state
#              transformation matrix that transforms states from the
#              reference frame 'from' to frame 'to' at epoch 'et'
#
#              'xform' returns with the same vectorization measure (N)
#               as 'et'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine sxform_c.
#
#   MICE.REQ
#   ROTATION.REQ
#   FRAMES.REQ
#
    function # sxform
#       (xform::Array{Float64,2}(6,6)) =   # Array_6_Array_6_SpiceDouble
        sxform(
            from::AbstractString, # Ptr{ConstSpiceChar}
            to::AbstractString, # Ptr{ConstSpiceChar}
            et::Float64) # SpiceDouble
        
#       enforce input array sizes
#       allocate the output parameters
        xform = Array{Float64,2}(6,6);  # Array_6_Array_6_SpiceDouble
        xform_ptr = pointer(xform)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:sxform_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},SpiceDouble,Array_6_Array_6_SpiceDouble),from,to,et,xform)
        ccall((:sxform_c,libNasaSpice),Void,
            (Ptr{UInt8},Ptr{UInt8},Float64,Ptr{Float64}),
            from,to,et,xform_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return xform'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Suppose you have geodetic coordinates of a station on the
#      % surface of Earth and that you need the inertial (J2000)
#      % state of this station.  The following code fragment
#      % illustrates how to transform the geodetic state of the
#      % station to a J2000 state.
#      %
#
#      %
#      % Load the SPK, PCK and LSK kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Define a geodetic longitude, latitude, altitude
#      % coordinate set. These coordinates are defined in the
#      % non-inertial, earth fixed frame "IAU_EARTH".
#      %
#      lon = 118.25 * cspice_rpd;
#      lat = 34.05  * cspice_rpd;
#      alt = 0.;
#
#      %
#      % Define a UTC time of interest. Convert the 'utc' string
#      % to ephemeris time J2000.
#      %
#      utc = 'January 1, 1990';
#      et = cspice_str2et( utc );
#
#      %
#      % Retrieve the equatorial and polar axis of the earth (body 399).
#      %
#      abc = cspice_bodvrd( 'EARTH', 'RADII', 3 );
#      equatr =  abc(1);
#      polar  =  abc(3);
#
#      %
#      % Calculate the flattening factor for earth.
#      %
#      f =  ( equatr - polar  ) / equatr;
#
#      %
#      % Calculate the Cartesian coordinates on earth for the
#      % location at 'lon', 'lat', 'alt'.
#      %
#      estate = cspice_georec( lon, lat, alt, equatr, f);
#
#      %
#      % cspice_georec returned the position vector of the geodetic
#      % coordinates, but we want the state vector. Since it is a fixed
#      % location referenced in the "IAU_EARTH" frame, the location has
#      % no velocity. We need to extend estate to a 6-vector, the final
#      % three elements with value 0.d.
#      %
#      estate = [ estate; [0.; 0.; 0.] ];
#
#      %
#      % Retrieve the transformation matrix from "IAU_EARTH"
#      % to "J2000" at epoch 'et'.
#      %
#      xform = sxform( 'IAU_EARTH', 'J2000', et );
#
#      jstate = xform * estate;
#
#      disp( 'Scalar' )
#      txt = sprintf( 'Cartesian position in J2000 frame at epoch: %f ', et );
#      disp( txt )
#      txt = sprintf( '%16.8f %16.8f %16.8f ', jstate(1:3) );
#      disp( txt )
#
#      disp( 'Cartesian velocity in J2000 frame' )
#      txt = sprintf( '%16.8f %16.8f %16.8f ', jstate(4:6) );
#      disp( txt )
#
#      %
#      % Return the state transformation matrices from "IAU_EARTH"
#      % to "J2000" approximately every month for the time
#      % interval January 1, 1990 to January 1, 2010 (UTC).
#      %
#      %
#      % Define the time bounds for the time interval,
#      % 20 years,  convert to ephemeris time J2000.
#      %
#      utc_bounds = strvcat( '1 Jan 1990', '1 Jan 2010' );
#      et_bounds = cspice_str2et( utc_bounds );
#
#      %
#      % Step in units of a month. 20 years ~ 240 months.
#      %
#      step = (et_bounds(2) - et_bounds(1) ) / 240.;
#
#      %
#      % Create an array of 240 ephemeris times starting at
#      % et_bound(1) in intervals of 'step'.
#      %
#      et = [0:239]*step + et_bounds(1);
#
#      %
#      % Convert the 240-vector of 'et' to an array of corresponding
#      % transformation matrices (dimensions (6,6,240) ).
#      %
#      xform = sxform( 'IAU_EARTH', 'J2000', et );
#
#      %
#      % Show the dimensions of the 'xform'.
#      %
#      disp (' ' )
#      disp( 'Vector' )
#      disp( 'Dimension of xform:' )
#      disp( size(xform) )
#
#      %
#      % Apply the first and last of the transform matrices to the
#      % 'estate' vector.
#      %
#      % Transform the Cartesian state vector from "IAU_EARTH"
#      % to "J2000" at et(1) (initial epoch).
#      %
#      jstate = xform(:,:,1) * estate;
#
#      txt = sprintf( 'Cartesian position in J2000 frame at epoch: %f', et(1) );
#      disp( txt )
#      txt =  sprintf( '%24.8f %24.8f %24.8f', jstate(1:3) );
#      disp( txt )
#
#      disp( 'Cartesian velocity in J2000 frame ')
#      txt =  sprintf( '%24.12f %24.12f %24.12f', jstate(4:6) );
#      disp( txt )
#
#      disp (' ' )
#
#      %
#      % Same transformation, but at et(240) (final epoch).
#      %
#      jstate = xform(:,:,240) * estate;
#
#      txt = ...
#         sprintf( 'Cartesian position in J2000 frame at epoch: %f', et(240) );
#      disp( txt )
#
#      txt =  sprintf( '%24.8f %24.8f %24.8f', jstate(1:3) );
#      disp( txt )
#
#      disp( 'Cartesian velocity in J2000 frame ')
#      txt =  sprintf( '%24.12f %24.12f %24.12f', jstate(4:6) );
#      disp( txt )
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Scalar
#      Cartesian position in J2000 frame at epoch: -315575942.816070
#        -4131.46296088   -3308.37067191    3547.02152550
#      Cartesian velocity in J2000 frame
#            0.24124981      -0.30101944       0.00023422
#
#      Vector
#      Dimension of xform:
#           6     6   240
#
#      Cartesian position in J2000 frame at epoch: -315575942.816070
#                -4131.46296088        -3308.37067191       3547.02152550
#      Cartesian velocity in J2000 frame
#                0.241249810257       -0.301019439927       0.000234215852
#
#      Cartesian position in J2000 frame at epoch: 312946264.154758
#                 4533.62043540        2731.85929290        3546.67378733
#      Cartesian velocity in J2000 frame
#               -0.199210494903        0.330347334014       0.000192387677
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     #####  #    #  #    #  #####    ####   #    #
#       #    #   #   #    #  #    #  #       ##   #
#       #    ####    #    #  #    #   ####   # #  #
#       #    #  #    #    #  #####        #  #  # #
#       #    #   #    #  #   #   #   #    #  #   ##
#       #    #    #    ##    #    #   ####   #    #
#
#   Return version strings
################################################################################
#-Abstract
#
#   tkvrsn returns the latest version string given an item such
#   as the Toolkit or an entry point name
#
#-I/O
#
#   Given:
#
#      item   is the item for which a version string is to be
#             returned.
#
#             Currently, the only item supported is "toolkit"
#             and it will return the toolkit version number.
#
#             Any other 'item' will return "No version found."
#
#   the call:
#
#      value = tkvrsn( item )
#
#   returns:
#
#      value   a scalar string corresponding to the latest version
#              string for the specified 'item'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine tkvrsn_c.
#
#   MICE.REQ
#
    function # tkvrsn
#       (value::AbstractString) =   # Ptr{ConstSpiceChar}
        tkvrsn(
            item::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        value = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        value_ptr = pointer(value)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:tkvrsn_c,"/home/don/.julia/v0.3/cspice.so"),Ptr{ConstSpiceChar},(Ptr{ConstSpiceChar},),item)
        return ccall((:tkvrsn_c,libNasaSpice),AbstractString,
            (Ptr{UInt8},Ptr{AbstractString}),
            item,value_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> disp( tkvrsn('toolkit') )
#
#   MATLAB outputs:
#
#      CSPICE_N0060
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 26-NOV-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     #####   ####   ######   #####   #   #  #####
#       #    #       #          #      # #   #    #
#       #     ####   #####      #       #    #    #
#       #         #  #          #       #    #####
#       #    #    #  #          #       #    #   #
#       #     ####   ######     #       #    #    #
#
#   Set the interval of expansion for abbreviated years
#
################################################################################
#-Abstract
#
#   tsetyr sets the lower bound on the 100 year range.
#
#-I/O
#
#   Given:
#
#      year   the scalar integer year associated with the lower
#             bound on all year expansions
#
#   the call:
#
#      tsetyr( year )
#
#   returns:
#
#      None.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine tsetyr_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # tsetyr
#       (year::Int32) =   # SpiceInt
        tsetyr()
        
#       enforce input array sizes
#       allocate the output parameters
        year = Array{Int32}(1);  # SpiceInt
        year_ptr = pointer(year)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:tsetyr_c,"/home/don/.julia/v0.3/cspice.so"),Void,(SpiceInt,),year)
        ccall((:tsetyr_c,libNasaSpice),Void,
            (Ptr{Int32},),
            year_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return year[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Set the lower bound for two digit century representation to 1980.
#
#      tsetyr(1980)
#
#   This cause the SPICE time system to interpret two digit year
#   values in the following manner:
#
#      year value      implied value
#      ----------      -----------
#      00              2000
#      01              2001
#       .                .
#       .                .
#      79              2079  <- lower bound + 99 years
#      80              1980  <- lower bound
#       .                .
#       .                .
#       .                .
#      99              1999
#
#-Version
#
#   -Mice Version 1.0.0, 12-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     #####  #    #   ####   #####      #
#       #    #    #  #    #  #    #     #
#       #    #    #  #    #  #    #     #
#       #    # ## #  #    #  #####      #
#       #    ##  ##  #    #  #          #
#       #    #    #   ####   #          #
#
#   twice the value of pi
#
################################################################################
#-Abstract
#
#   twopi returns the value of the constant 2*pi.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      twopi = twopi
#
#   returns:
#
#      twopi  twice the value of pi.
#
#             [1,1] = size(twopi); double = class(twopi)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine twopi_c.
#
#   MICE.REQ
#
    function # twopi
        twopi()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:twopi_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:twopi_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> sprintf( 'Two PI %16.12f', twopi )
#
#      ans =
#
#      Two PI =   6.283185307180
#
#-Version
#
#   -Mice Version 1.0.1, 11-JUN-2013, EDW (JPL)
#
#       I/O descriptions edits to conform to Mice documentation format.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     #####  #    #   ####   #    #  ######   ####
#       #    #    #  #    #  #    #  #       #    #
#       #    #    #  #    #  #    #  #####   #
#       #    # ## #  #    #  #    #  #       #
#       #    ##  ##  #    #   #  #   #       #    #
#       #    #    #   ####     ##    ######   ####
#
#   define an orthonormal frame from two vectors
#
################################################################################
#-Abstract
#
#   CSPICE_calculates the transformation matrix to the
#   right-handed reference frame having an input vector as a
#   specified axis and a second input vector lying in a
#   define coordinate plane.
#
#-I/O
#
#   Given:
#
#      axdef    a double precision 3x1 array defining the principal
#               axes of a coordinate frame
#
#      indexa   the integer scalar signifying which of the three coordinate
#               axes contains 'axdef' (1, 2 or 3)
#
#                  If 'indexa' is 1 then axdef defines the X axis of the
#                  coordinate frame.
#
#                  If 'indexa' is 2 then axdef defines the Y axis of the
#                  coordinate frame.
#
#                  If 'indexa' is 3 then axdef defines the Z axis of the
#                  coordinate frame
#
#      plndef   a double precision 3x1 array defining a vector in the same
#               plane as 'axdef'
#
#      indexp   the integer scalar signifying the second principle axis,
#               orthogonal to 'axdef' (1, 2 or 3)
#
#                  If 'indexp' is 1, the second axis of the principal
#                  plane is the X-axis.
#
#                  If 'indexp' is 2, the second axis of the principal
#                  plane is the Y-axis.
#
#                  If 'indexp' is 3, the second axis of the principal plane
#                  is the Z-axis.
#
#   the call:
#
#      mout = twovec( axdef, indexa, plndef, indexp)
#
#   returns:
#
#      mout   a double precision 3x3 array defining a rotation matrix from
#             the frame of the original vectors to the new frame
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine twovec_c.
#
#   MICE.REQ
#
    function # twovec
#       (mout::Array{Float64,2}(3,3)) =   # Array_3_Array_3_SpiceDouble
        twovec(
            axdef::Array{Float64,1}, # Array_3_ConstSpiceDouble
            indexa::Int32, # SpiceInt
            plndef::Array{Float64,1}, # Array_3_ConstSpiceDouble
            indexp::Int32) # SpiceInt
        
#       enforce input array sizes
        if length(axdef) != 3
            error("Incorrect size for parameter 1")
        end
        if length(plndef) != 3
            error("Incorrect size for parameter 3")
        end
#       allocate the output parameters
        mout = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        mout_ptr = pointer(mout)
        
#       make transposed copies of all input arrays and their pointers
        axdef_t = axdef'
        axdef_ptr = pointer(axdef_t)
        plndef_t = plndef'
        plndef_ptr = pointer(plndef_t)
        
#       ccall((:twovec_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,SpiceInt,Array_3_ConstSpiceDouble,SpiceInt,Array_3_Array_3_SpiceDouble),axdef,indexa,plndef,indexp,mout)
        ccall((:twovec_c,libNasaSpice),Void,
            (Ptr{Float64},Int32,Ptr{Float64},Int32,Ptr{Float64}),
            axdef_ptr,indexa,plndef_ptr,indexp,mout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return mout'
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example:
#
#      %
#      % A trivial example. Define the reference vectors...
#      %
#      %  The i unit vector
#      %
#      axdef  = [ 1.; 0; 0.];
#      indexa = 1 ;
#
#      %
#      %  The -j unit vector. For this example, any vector
#      %  in the x-y plane linearly independent of 'axdef'
#      %  will suffice.
#      %
#      plndef = [ 0.; -1.; 0.];
#      indexp = 2;
#
#      %
#      % Calculate the transformation matrix. The new frame
#      % has 'axdef' as axis 'indexa', with 'plndef' in the same
#      % plane, the direction axis 'indexp' in that plane
#      % and orthogonal to 'axdef'. A third direction vector
#      % completes the right handed frame.
#      %
#      mout = twovec( axdef, indexa, plndef, indexp )
#
#   MATLAB outputs:
#
#      mout =
#
#           1     0     0
#           0    -1     0
#           0     0    -1
#
#-Version
#
#    -Mice Version 1.0.0, 10-JAN-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#     #####   #   #  ######    ##    #####
#       #      # #   #        #  #   #    #
#       #       #    #####   #    #  #    #
#       #       #    #       ######  #####
#       #       #    #       #    #  #   #
#       #       #    ######  #    #  #    #
#
#   Number of seconds per tropical year
#
################################################################################
#-Abstract
#
#   tyear returns the double precision value of the number
#   of seconds in a tropical year: 31556926.
#
#-I/O
#
#   Given:
#
#      No input required.
#
#   the call:
#
#      tyear = tyear
#
#   returns:
#
#      A double precision scalar, the number of seconds per tropical
#      year.  This value is taken from the 1992 Explanatory Supplement
#      to the Astronomical Almanac.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine tyear_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # tyear
        tyear()
        
#       enforce input array sizes
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:tyear_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,())
        return ccall((:tyear_c,libNasaSpice),Float64,
            ())
            
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> tyear = tyear
#
#      tyear =
#
#           3.155692597470000e+07
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #    #     #     #####     #    #    #
#    #    #  ##   #     #       #       #    ##  ##
#    #    #  # #  #     #       #       #    # ## #
#    #    #  #  # #     #       #       #    #    #
#    #    #  #   ##     #       #       #    #    #
#     ####   #    #     #       #       #    #    #
#
#   Transform between two uniform numeric time systems
#   Transform between two additive numeric time systems
#   Convert one uniform numeric time system to another
#   Convert one additive numeric time system to another
#
################################################################################
#-Abstract
#
#   unitim returns the double precision value of an input epoch converted
#   from one uniform time scale to another.
#
#-I/O
#
#   Given:
#
#      epoch    epoch(s) relative to the 'insys' time scale.
#
#               [1,n] = size(epoch); double = class(epoch)
#
#      insys    naming the uniform time scale of 'epoch'. Acceptable values:
#
#               [1,m] = size(insys); char = class(insys)
#
#                  'TAI'     International Atomic Time.
#
#                  'TDB'     Barycentric Dynamical Time.
#
#                  'TDT'     Terrestrial Dynamical Time.
#
#                  'ET'      Ephemeris time (in the SPICE system, this is
#                            equivalent to TDB).
#
#                  'JDTDB'   Julian Date relative to TDB.
#
#                  'JDTDT'   Julian Date relative to TDT.
#
#                  'JED'     Julian Ephemeris Date (in the SPICE system
#                            this is equivalent to JDTDB).
#
#               The routine is not sensitive to the case of insys;
#               'tai' 'Tai' and 'TAI' are all equivalent from the point of
#               view of this routine.
#
#      outsys   naming the uniform time scale to which 'epoch' should be
#               converted. Acceptable values are the same as for 'insys'.
#
#               [1,m] = size(outsys); char = class(outsys)
#
#               The routine is not sensitive to the case of 'outsys'.
#
#   the call:
#
#      [unitim] = unitim( epoch, insys, outsys )
#
#   returns:
#
#      unitim   time(s) in the system specified by 'outsys' equivalent to the
#               'epoch' in the 'insys' time scale.
#
#               [1,n] = size(unitim); double = class(unitim)
#
#               'unitimt' returns with the same vectorization measure (N)
#               as 'epoch'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine unitim_c.
#
#   MICE.REQ
#   TIME.REQ
#
    function # unitim
#       (output::Float64) =   # SpiceDouble
        unitim(
            epoch::Float64, # SpiceDouble
            insys::AbstractString, # Ptr{ConstSpiceChar}
            outsys::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
#       allocate the output parameters
        output = Array{Float64}(1);  # SpiceDouble
        output_ptr = pointer(output)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:unitim_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(SpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar}),epoch,insys,outsys)
        return ccall((:unitim_c,libNasaSpice),Float64,
            (Float64,Ptr{UInt8},Ptr{UInt8},Ptr{Float64}),
            epoch,insys,outsys,output_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( '/kernels/gen/lsk/naif0009.tls'
#                                '/kernels/gen/spk/de421.bsp'
#                                '/kernels/gen/pck/pck00009.tpc'
#                      )
#
#         \begintext
#
#
#      %
#      % Load a leapseconds kernel, use a meta kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      et = cspice_str2et( 'Dec 19 2003' );
#
#      converted_et = unitim(et, 'ET','JED')
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      converted_et =
#
#           2.452992500742865e+06
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #    #  #        ####     ##    #####
#    #    #  ##   #  #       #    #   #  #   #    #
#    #    #  # #  #  #       #    #  #    #  #    #
#    #    #  #  # #  #       #    #  ######  #    #
#    #    #  #   ##  #       #    #  #    #  #    #
#     ####   #    #  ######   ####   #    #  #####
#
#   Unload a SPICE kernel
#
################################################################################
#-Abstract
#
#   unload unloads a SPICE kernel file (of any type)
#   from MATLAB.
#
#-I/O
#
#   Given:
#
#      file   the string scalar or NXM character array of SPICE
#             kernel file names, 'file' (or any kernel listed in 'file')
#             should be one loaded through the interface cspice_furnsh
#
#   the call:
#
#      unload( file )
#
#      removes the file and all associated data from the kernel
#      sub-system. If file is a meta-text kernel, the sub-system
#      unloads all files listed in the kernel.
#
#      Note: a unload call deletes ALL kernel variables except
#      those loaded into the kernel pool via a cspice_furnsh kernel
#      load  call, i.e. unload erases kernel variables placed
#      in the pool by the pool functions: cspice_pipool, cspice_pdpool,
#      and cspice_pcpool.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine unload_c.
#
#   MICE.REQ
#   KERNEL.REQ
#   PCK.REQ
#
    function # unload
#       (file::AbstractString) =   # Ptr{ConstSpiceChar}
        unload()
        
#       enforce input array sizes
#       allocate the output parameters
        file = Array{AbstractString}(1);  # Ptr{ConstSpiceChar}
        file_ptr = pointer(file)
        
#       make transposed copies of all input arrays and their pointers
        
#       ccall((:unload_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Ptr{ConstSpiceChar},),file)
        ccall((:unload_c,libNasaSpice),Void,
            (Ptr{AbstractString},),
            file_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return file[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK
#      %  file and a leapseconds file. Use a meta
#      %  kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % When the kernel variable
#      %
#      %    BODY399_RADII
#      %
#      % is present in the kernel pool---normally because a PCK
#      % defining this variable has been loaded (as is the case
#      % here)---the call
#      %
#      try
#         values = cspice_bodvrd( 'EARTH', 'RADII', 3);
#         disp('Expected result, found kernel data')
#      catch
#         disp('ERROR: Unexpected result, no kernel data found')
#      end
#
#      %
#      %  Now unload the kernel and try again.
#      %
#      unload( 'standard.tm' )
#
#      try
#         values = cspice_bodvrd( 'EARTH', 'RADII', 3);
#         disp('ERROR: Unexpected result, found kernel data')
#      catch
#         disp('Expected result, no kernel data found')
#      end
#
#-Version
#
#   -Mice Version 1.1.0, 17-DEC-2008, EDW (JPL)
#
#      Added zzmice_str call on input 'file' to convert string cells to
#      character arrays if 'file' has type string cells. Properly
#      identified 'file' as a vectorizable string/character array.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #    #   ####   #####   #    #
#    #    #  ##   #  #    #  #    #  ##  ##
#    #    #  # #  #  #    #  #    #  # ## #
#    #    #  #  # #  #    #  #####   #    #
#    #    #  #   ##  #    #  #   #   #    #
#     ####   #    #   ####   #    #  #    #
#
#   3-dimensional unit vector and norm
#
################################################################################
#-Abstract
#
#   unorm normalizes a double precision 3-vector and
#   returns its magnitude.
#
#-I/O
#
#   Given:
#
#      v1   any arbitrary 3-vector(s).
#
#           [3,n] = size(v1); double = class(v1)
#
#   the call:
#
#      [vout, vmag] = unorm(v1)
#
#   returns:
#
#      vout   unit vector(s) in the direction of 'v1'. If 'v1'
#             represents the zero vector, then 'vout' will also be
#             the zero vector.
#
#             vout =   v1
#                    ------
#                    ||v1||
#
#             [3,n] = size(vout); double = class(vout)
#
#      vmag   the positive definite magnitude(s) of 'v1', ||v1||, calculated
#              in a numerically stable way.
#
#             [1,n] = size(vmag); double = class(vmag)
#
#             'vout' and 'vmag' return with the same measure of vectorization
#              (N) as 'v1'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine unorm_c.
#
#   MICE.REQ
#
    function # unorm
#       (vout::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        vmag::Float64) =   # Ptr{SpiceDouble}
        unorm(
            v1::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(v1) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        vout = Array{Float64,1}(3);  # Array_3_SpiceDouble
        vout_ptr = pointer(vout)
        vmag = Array{Float64}(1);  # Ptr{SpiceDouble}
        vmag_ptr = pointer(vmag)
        
#       make transposed copies of all input arrays and their pointers
        v1_t = v1'
        v1_ptr = pointer(v1_t)
        
#       ccall((:unorm_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_SpiceDouble,Ptr{SpiceDouble}),v1,vout,vmag)
        ccall((:unorm_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            v1_ptr,vout_ptr,vmag_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return vout, vmag[1]
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#   Example(1):
#
#      >> v1 = [ 5; 12; 0]
#
#      v1 =
#
#           5
#          12
#           0
#
#      >> [vout, vmag] = unorm(v1 )
#
#   MATLAB outputs:
#
#      vout =
#
#          0.3846
#          0.9231
#               0
#
#      vmag =
#
#          13
#
#   Example(2):
#
#      >> v2 = [ 1D-7; 2D-7; 2D-7]
#
#      v2 =
#
#         1.0e-06 *
#
#          0.1000
#          0.2000
#          0.2000
#
#      >> [vout, vmag] = unorm(v2)
#
#   MATLAB outputs:
#
#      vout =
#
#          0.3333
#          0.6667
#          0.6667
#
#      vmag =
#
#         3.0000e-07
#
#   Example(3):
#
#      >> v = [v1, v2 ]
#
#      v =
#
#          5.0000    0.0000
#         12.0000    0.0000
#               0    0.0000
#
#      >> [vout, vmag] = unorm(v )
#
#   MATLAB outputs:
#
#      vout =
#
#          0.3846    0.3333
#          0.9231    0.6667
#               0    0.6667
#
#      vmag =
#
#         13.0000    0.0000
#
#   The second element of 'vmag' displays as 0.0 due to the eight
#   orders of magnitude difference between that element and the first.
#   Confirm the expected value:
#
#      >> vmag(2)
#
#   MATLAB outputs:
#
#      ans =
#
#         3.0000e-07
#
#-Version
#
#   -Mice Version 1.0.2, 09-NOV-2012, EDW (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.1, 21-APR-2010, EDW (JPL)
#
#      Corrected description of call example to list all output arguments,
#      from:
#
#         vout = unorm(v1)
#
#      to
#
#         [vout, vmag] = unorm(v1)
#
#   -Mice Version 1.0.0, 25-APR-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####      #     ####    #####
#    #    #  #    #     #    #          #
#    #    #  #    #     #     ####      #
#    #    #  #    #     #         #     #
#     #  #   #    #     #    #    #     #
#      ##    #####      #     ####      #
#
#   distance between 3-dimensional vectors
#
################################################################################
#-Abstract
#
#   vdist returns the distance between two
#   three-dimensional vectors.
#
#-I/O
#
#   Given:
#
#      v1   an arbitrary double precision, 3-dimensional vector
#           or 3xN array
#
#      v2   also an arbitrary double precision, 3-dimensional vector
#           or 3xN array
#
#   the call:
#
#      dist = vdist(v1, v2)
#
#   returns:
#
#      dist   the double precision, positive definite, scalar or 1xN array
#             describing the distance(s) between 'v1' and 'v2', distance
#             defined as:
#
#                ||  v1 - v2  ||,
#
#                      _                                               _
#             where || x || indicates the Euclidean norm of the vector x.
#
#             'dist' returns with the same vectorization measure (N)
#              as 'v1' and 'v2'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vdist_c.
#
#   MICE.REQ
#
    function # vdist
#       (dist::Float64) =   # SpiceDouble
        vdist(
            v1::Array{Float64,1}, # Array_3_ConstSpiceDouble
            v2::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(v1) != 3
            error("Incorrect size for parameter 1")
        end
        if length(v2) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        dist = Array{Float64}(1);  # SpiceDouble
        dist_ptr = pointer(dist)
        
#       make transposed copies of all input arrays and their pointers
        v1_t = v1'
        v1_ptr = pointer(v1_t)
        v2_t = v2'
        v2_ptr = pointer(v2_t)
        
#       ccall((:vdist_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble),v1,v2)
        return ccall((:vdist_c,libNasaSpice),Float64,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            v1_ptr,v2_ptr,dist_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define a set of vectors, calculate the distance
#      % between the coordinates.
#      %
#      v1 = [1; 0; 0]
#      v2 = [1; 0; 0]
#
#      vdist = vdist( v1, v2 )
#
#   MATLAB outputs:
#
#      v1 =
#
#           1
#           0
#           0
#
#      v2 =
#
#           1
#           0
#           0
#
#      vdist =
#
#           0
#
#      %
#      % Another vector set.
#      %
#      v1 = [1; 0; 0]
#      v2 = [0; 1; 0]
#
#      vdist = vdist( v1, v2 )
#
#   MATLAB outputs:
#
#      v1 =
#
#           1
#           0
#           0
#
#      v2 =
#
#           0
#           1
#           0
#
#      dist =
#
#         1.41421356237310
#
#      %
#      % Instead of two calls with 3-vectors,
#      % vectorize the input as two 3X2 array.
#      %
#      v1 = [ [1; 0; 0], [1; 0; 0] ]
#      v2 = [ [1; 0; 0], [0; 1; 0] ]
#
#      vdist = vdist( v1, v2 )
#
#   MATLAB outputs:
#
#      v1 =
#
#           1     1
#           0     0
#           0     0
#
#      v2 =
#
#           1     0
#           0     1
#           0     0
#
#      dist =
#
#         0   1.41421356237310
#
#-Version
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #    #    ##     #####
#    #    #  #    #   #  #      #
#    #    #  ######  #    #     #
#    #    #  #    #  ######     #
#     #  #   #    #  #    #     #
#      ##    #    #  #    #     #
#
#   unitize a 3-dimensional vector
#
################################################################################
#-Abstract
#
#   vhat returns the unit vector along a double precision
#   3-dimensional vector.
#
#-I/O
#
#   Given:
#
#      v1   an arbitrary double precision, 3-dimensional vector
#           or 3xN array
#
#   the call:
#
#      vout = vhat(v1)
#
#   returns:
#
#      vout   contains the unit 3-vector or 3xN array of unit vectors
#             in the direction of 'v1'.
#
#                   ^       --
#                 vhat =    v1
#                        --------
#                           --
#                        || v1 ||
#
#                      _                                               _
#             where || x || indicates the Euclidean norm of the vector x.
#
#             If 'v1' represents the zero vector, then 'vout' will
#             also be the zero vector.
#
#             'vout' returns with the same vectorization measure as 'v1'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vhat_c.
#
#   MICE.REQ
#
    function # vhat
#       (vout::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        vhat(
            v1::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(v1) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        vout = Array{Float64,1}(3);  # Array_3_SpiceDouble
        vout_ptr = pointer(vout)
        
#       make transposed copies of all input arrays and their pointers
        v1_t = v1'
        v1_ptr = pointer(v1_t)
        
#       ccall((:vhat_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_SpiceDouble),v1,vout)
        ccall((:vhat_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64}),
            v1_ptr,vout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return vout
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      >> v1 = [ 5; 12; 0]
#
#      v1 =
#
#           5
#          12
#           0
#
#      >> vhat(v1)
#
#   MATLAB outputs:
#
#      ans =
#
#          0.3846
#          0.9231
#               0
#
#      >> v2 = [ 1D-7; 2D-7; 2D-7]
#
#      v2 =
#
#         1.0e-06 *
#
#          0.1000
#          0.2000
#          0.2000
#
#      >> vhat(v2)
#
#   MATLAB outputs:
#
#      ans =
#
#          0.3333
#          0.6667
#          0.6667
#
#      >> v = [v1, v2 ]
#
#      v =
#
#          5.0000    0.0000
#         12.0000    0.0000
#               0    0.0000
#
#      >> vhat(v)
#
#   MATLAB outputs:
#
#      ans =
#
#          0.3846    0.3333
#          0.9231    0.6667
#               0    0.6667
#
#-Version
#
#   -Mice Version 1.0.1, 30-DEC-2008, EDW (JPL)
#
#      Corrected misspellings.
#
#   -Mice Version 1.0.0, 25-APR-2006, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #    #   ####   #####   #    #
#    #    #  ##   #  #    #  #    #  ##  ##
#    #    #  # #  #  #    #  #    #  # ## #
#    #    #  #  # #  #    #  #####   #    #
#     #  #   #   ##  #    #  #   #   #    #
#      ##    #    #   ####   #    #  #    #
#
#   norm of 3-dimensional vector
#
################################################################################
#-Abstract
#
#   vnorm returns the magnitude of a double precision, 3-dimensional
#   array or set of such arrays.
#
#-I/O
#
#   Given:
#
#      v1   any arbitrary 3-vector(s).
#
#           [3,n] = size(v1); double = class(v1)
#
#   the call:
#
#      vnorm = vnorm(v1)
#
#   returns:
#
#      vnorm   the positive definite magnitude(s) of 'v1', ||v1||, calculated
#              in a numerically stable way.
#
#              [1,n] = size(vnorm); double = class(vnorm)
#
#              'vnorm' returns with the same measure of vectorization (N)
#              as 'v1'.
#
#-Particulars
#
#   The magnitude calculation takes care to avoid overflow while computing
#   the norm of the input vector 'v1'. The logic determines the component of
#   'v1' whose magnitude is the largest. Calling this magnitude v1max, the
#   norm is computed using the formula
#
#       vnorm  =  v1max *  ||  (1/v1max) * v1  ||
#
#   where the notation ||x|| indicates the norm of the vector x.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vnorm_c.
#
#   MICE.REQ
#
    function # vnorm
#       (vnorm::Float64) =   # SpiceDouble
        vnorm(
            v1::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(v1) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        vnorm = Array{Float64}(1);  # SpiceDouble
        vnorm_ptr = pointer(vnorm)
        
#       make transposed copies of all input arrays and their pointers
        v1_t = v1'
        v1_ptr = pointer(v1_t)
        
#       ccall((:vnorm_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(Array_3_ConstSpiceDouble,),v1)
        return ccall((:vnorm_c,libNasaSpice),Float64,
            (Ptr{Float64},Ptr{Float64}),
            v1_ptr,vnorm_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Set a size for the Nx1 array of ephemeris times.
#      %
#      N = 1000;
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK
#      %  file and a leapseconds file. Use a meta
#      %  kernel for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Set a reference epoch, convert the string representation
#      % to ET.
#      %
#      utc = 'Jan 1 2010 12:34:56';
#      et_0 = cspice_str2et( utc );
#
#      %
#      % Create an array of N elements off the reference epoch in
#      % steps of one day in ET seconds.
#      %
#      et = [1:N]*cspice_spd() + et_0;
#
#      %
#      % Calculate the geometric position of Mercury with respect to
#      % the earth, without aberration correction, at time 'et'.
#      %
#      target   = 'Mercury';
#      frame    = 'J2000';
#      abcorr   = 'none';
#      observer = 'Earth';
#
#      disp('Scalar')
#
#      [pos, ltime] = cspice_spkpos( target, et_0, frame, abcorr, observer );
#
#      %
#      % Calculate the  magnitude of the position vector returned
#      % from cspice_spkpos.
#      %
#      vmag = [ vnorm( pos ) ]'
#
#
#      disp('Vectorized')
#
#      [pos, ltime] = cspice_spkpos( target, et, frame, abcorr, observer );
#
#      %
#      % Calculate the 1xN array of magnitudes of the N position vectors
#      % returned from cspice_spkpos.
#      %
#      vmag = [ vnorm( pos ) ]'
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in Matlab due to data persistence.
#      %
#      cspice_kclear
#
#   Matlab outputs:
#
#      Scalar
#
#      vmag =
#
#           1.041179020016839e+08
#
#      Vectorized
#
#      vmag =
#
#           1.025277808532095e+08
#           1.013810734850024e+08
#           1.006917331078249e+08
#           1.004611905399685e+08
#           1.006785378087216e+08
#           1.013217510356714e+08
#
#                   ...
#
#           2.076962759877405e+08
#           2.072238879729207e+08
#           2.066729526239417e+08
#           2.060458187524104e+08
#           2.053445529777324e+08
#           2.045709570882183e+08
#
#-Version
#
#   -Mice Version 1.0.0, 24-APR-2010 (EDW)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   ######  #####   #####
#    #    #  #    #  #       #    #  #    #
#    #    #  #    #  #####   #    #  #    #
#    #    #  #####   #       #####   #####
#     #  #   #       #       #   #   #
#      ##    #       ######  #    #  #
#
#   perpendicular component of a 3-vector
#
################################################################################
#-Abstract
#
#   vperp calculates the component of a vector perpendicular to a
#   second vector.
#
#-I/O
#
#   Given:
#
#      a   the 3-vector(s) whose component orthogonal to 'b' is sought.
#
#          [3,n] = size(a); double = class(a)
#
#          (There is a unique decomposition of a into a sum v + p, where v is
#          parallel to b and p is orthogonal to b.  We want the component p.)
#
#      b   the second 3-vector(s) used as a reference for the decomposition
#          of 'a'.
#
#          [3,n] = size(b); double = class(b)
#
#      An implicit assumption exists that 'a' and 'b' are specified
#      in the same reference frame. If this is not the case, the numerical
#      result has no meaning.
#
#   the call:
#
#      p = vperp( a, b )
#
#   returns:
#
#      p       the 3-vector(s) containing the component of 'a' orthogonal
#              to 'b'.
#
#              [3,n] = size(p); double = class(p)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vperp_c.
#
#   MICE.REQ
#
    function # vperp
#       (p::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        vperp(
            a::Array{Float64,1}, # Array_3_ConstSpiceDouble
            b::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(a) != 3
            error("Incorrect size for parameter 1")
        end
        if length(b) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        p = Array{Float64,1}(3);  # Array_3_SpiceDouble
        p_ptr = pointer(p)
        
#       make transposed copies of all input arrays and their pointers
        a_t = a'
        a_ptr = pointer(a_t)
        b_t = b'
        b_ptr = pointer(b_t)
        
#       ccall((:vperp_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_SpiceDouble),a,b,p)
        ccall((:vperp_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            a_ptr,b_ptr,p_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return p
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define two vector sets.
#      %
#      a = [ [ 6, 6, 6]', ...
#            [ 6, 6, 6]', ...
#            [ 6, 6, 0]', ...
#            [ 6, 0, 0]' ]
#
#      b = [ [ 2, 0, 0]', ...
#            [-3, 0, 0]', ...
#            [ 0, 7, 0]', ...
#            [ 0, 0, 9]' ]
#
#      %
#      % Calculate the decomposition.
#      %
#      p = vperp( a, b )
#
#   MATLAB outputs:
#
#      a =
#
#           6     6     6     6
#           6     6     6     0
#           6     6     0     0
#
#
#      b =
#
#           2    -3     0     0
#           0     0     7     0
#           0     0     0     9
#
#
#      p =
#
#           0     0     6     6
#           6     6     0     0
#           6     6     0     0
#
#-Version
#
#   -Mice Version 1.0.1, 09-NOV-2012, EDW (JPL)
#
#      Edited I/O section to conform to NAIF standard for Mice documentation.
#
#   -Mice Version 1.0.0, 22-APR-2010, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   #####        #  #####
#    #    #  #    #  #    #       #  #    #
#    #    #  #    #  #    #       #  #    #
#    #    #  #####   #####        #  #####
#     #  #   #       #   #   #    #  #
#      ##    #       #    #   ####   #
#
#   vector projection onto plane
#
################################################################################
#-Abstract
#
#   vprjp orthogonally projects a vector onto a specified plane.
#
#-I/O
#
#   Given:
#
#      vin     the 3-vector to orthogonally project onto a specified plane.
#
#              [3,1] = size(vin); double = class(vin)
#
#      plane   a structure describing a SPICE plane onto which to
#              project 'vin'.
#
#              [1,1] = size(plane); struct = class(plane)
#
#              The structure has the fields:
#
#                 normal:     [3,1] = size(normal); double = class(normal)
#                 constant:   [1,1] = size(constant); double = class(constant)
#
#   the call:
#
#      vout = vprjp( vin, plane )
#
#   returns:
#
#      vout   3-vector resulting from the orthogonal projection of 'vin'
#             onto 'plane'. 'vout' is the closest point in the specified
#             plane to 'vin'.
#
#             [3,1] = size(vout); double = class(vout)
#
#-Particulars
#
#   Projecting a vector v orthogonally onto a plane can be thought of
#   as finding the closest vector in the plane to v.  This `closest
#   vector' always exists; it may be coincident with the original
#   vector.
#
#   Two related routines are vprjpi, which inverts an orthogonal
#   projection of a vector onto a plane, and cspice_vproj, which projects
#   a vector orthogonally onto another vector.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vprjp_c.
#
#   MICE.REQ
#
    function # vprjp
#       (vout::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        vprjp(
            vin::Array{Float64,1}, # Array_3_ConstSpiceDouble
            plane::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
        if length(vin) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        vout = Array{Float64,1}(3);  # Array_3_SpiceDouble
        vout_ptr = pointer(vout)
        
#       make transposed copies of all input arrays and their pointers
        vin_t = vin'
        vin_ptr = pointer(vin_t)
        ioplane = IOBuffer()
        StrPack.pack( ioplane, plane)
        plane_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioplane.data) ) )
        
#       ccall((:vprjp_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{ConstSpicePlane},Array_3_SpiceDouble),vin,plane,vout)
        ccall((:vprjp_c,libNasaSpice),Void,
            (Ptr{Float64},NasaSpice.Plane,Ptr{Float64}),
            vin_ptr,plane,vout_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return vout
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Find the closest point in the ring plane of a planet to a
#      % spacecraft located at vec1 (in body-fixed coordinates).
#      %
#      vec1 = [ -5., 7., 2.2]';
#
#      %
#      % Define the vector normal as the normal to the
#      % equatorial ring plane, and the origin at body/ring center
#      %
#      norm = [ 0., 0., 1. ]';
#      orig = [ 0., 0., 0. ]';
#
#      %
#      % Create the plane structure.
#      %
#      ring_plane = cspice_nvp2pl( norm, orig );
#
#      %
#      % Project the position vector onto the ring plane...
#      %
#      proj = vprjp( vec1, ring_plane )
#
#   MATLAB outputs:
#
#      proj =
#
#          -5
#           7
#           0
#
#-Version
#
#   -Mice Version 1.0.0, 27-AUG-2012, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   #####        #  #####      #
#    #    #  #    #  #    #       #  #    #     #
#    #    #  #    #  #    #       #  #    #     #
#    #    #  #####   #####        #  #####      #
#     #  #   #       #   #   #    #  #          #
#      ##    #       #    #   ####   #          #
#
#   vector projection onto plane
#
################################################################################
#-Abstract
#
#   vprjpi calculates the vector in a specified plane that
#   maps under orthogonal projection to a specified vector in
#   another plane.
#
#-I/O
#
#   Given:
#
#      vin      a 3-vector.
#
#               [3,1] = size(vin); double = class(vin)
#
#      projpl   a SPICE plane that represents the geometric plane containing
#               'vin'. The structure has the fields:
#
#               SPICE plane STRUCTURE
#
#                  normal     constant  
#                             [3,1] = size(normal); double = class(normal)
#
#      invpl    a SPICE plane that represents the geometric plane containing
#               the inverse image of 'vin' under orthogonal projection onto
#               'projpl'. The structure has the fields:
#
#               SPICE plane STRUCTURE
#
#                  normal     constant 
#                             [3,1] = size(normal); double = class(normal)
#
#   the call:
#
#      [vout, found] = vprjpi( vin, projpl, invpl )
#
#   returns:
#
#      vout     inverse orthogonal projection of 'vin'. This is the vector
#               lying in the plane 'invpl' whose orthogonal projection onto the
#               plane 'projpl' is 'vin'. 'vout' is valid only when 'found' is
#               true. Otherwise, 'vout' is undefined.
#
#               [3,1] = size(vout); double = class(vout)
#
#      found    indicating whether the inverse orthogonal projection of 'vin'
#               could be computed. 'found' is true if so, false otherwise.
#
#               [1,1] = size(found); logical = class(found)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vprjpi_c.
#
#   MICE.REQ
#
    function # vprjpi
#       (vout::Array{Float64,1}(3),  # Array_3_SpiceDouble
#        found::Int32) =   # Ptr{SpiceBoolean}
        vprjpi(
            vin::Array{Float64,1}, # Array_3_ConstSpiceDouble
            projpl::NasaSpice.Plane, # Ptr{ConstSpicePlane}
            invpl::NasaSpice.Plane) # Ptr{ConstSpicePlane}
        
#       enforce input array sizes
        if length(vin) != 3
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        vout = Array{Float64,1}(3);  # Array_3_SpiceDouble
        vout_ptr = pointer(vout)
        found = Array{Int32}(1);  # Ptr{SpiceBoolean}
        found_ptr = pointer(found)
        
#       make transposed copies of all input arrays and their pointers
        vin_t = vin'
        vin_ptr = pointer(vin_t)
        ioprojpl = IOBuffer()
        StrPack.pack( ioprojpl, projpl)
        projpl_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioprojpl.data) ) )
        ioinvpl = IOBuffer()
        StrPack.pack( ioinvpl, invpl)
        invpl_ptr = convert( Ptr{Ptr{ConstSpicePlane}}, convert( Ptr{Void}, pointer(ioinvpl.data) ) )
        
#       ccall((:vprjpi_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Ptr{ConstSpicePlane},Ptr{ConstSpicePlane},Array_3_SpiceDouble,Ptr{SpiceBoolean}),vin,projpl,invpl,vout,found)
        ccall((:vprjpi_c,libNasaSpice),Void,
            (Ptr{Float64},NasaSpice.Plane,NasaSpice.Plane,Ptr{Float64},Ptr{Int32}),
            vin_ptr,projpl,invpl,vout_ptr,found_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return vout, convert( Bool, found[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Construct 2 planes via cspice_nvc2pl. Define the normal
#      % vectors and constants for the planes.
#      %
#      norm1 = [ 0, 0, 1]';
#      norm2 = [ 1, 0, 1]';
#      con1  = 1.2;
#      con2  = 0.65;
#
#      %
#      % Use the normals and constants to create the plane structures,
#      % plane1 and plane2.
#      %
#      plane1 = cspice_nvc2pl( norm1, con1 );
#      plane2 = cspice_nvc2pl( norm2, con2 );
#
#      %
#      % Define a vector in plane1...
#      %
#      vec = [ 1, 1, 0]';
#
#      %
#      % Calculate the inverse projection to plane2.
#      %
#      [ vec_iproj, found] = vprjpi( vec, plane1, plane2);
#
#      if ( found )
#         disp( 'Found inverse vector:' )
#         vec_iproj
#      else
#         disp( 'Could not find the inverse vector.' )
#      end
#
#   MATLAB outputs:
#
#      Found inverse vector:
#
#      vec_iproj =
#
#           1.000000000000000e+00
#           1.000000000000000e+00
#          -3.500000000000000e-01
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####   #####    ####        #
#    #    #  #    #  #    #  #    #       #
#    #    #  #    #  #    #  #    #       #
#    #    #  #####   #####   #    #       #
#     #  #   #       #   #   #    #  #    #
#      ##    #       #    #   ####    ####
#
#   3-vector projection
#
################################################################################
#-Abstract
#
#   vproj calculates the projection of a set of 3-vectors onto
#   another set of 3-vectors.
#
#-I/O
#
#   Given:
#
#      a   the vector(s) to project onto the vector(s) 'b'.
#
#          [3,n] = size(a); double = class(a)
#
#      b   the vector(s) to receive the projection(s).
#
#          [3,n] = size(b); double = class(b)
#
#      An implicit assumption exists that 'a' and 'b' are specified
#      in the same reference frame. If this is not the case, the numerical
#      result has no meaning.
#
#   the call:
#
#      p = vproj( a, b )
#
#   returns:
#
#      p       vector containing the projection(s) of 'a' onto 'b' ('p' is
#              necessarily parallel to 'b'.)  If 'b' equals the zero vector
#              then the zero vector will return as 'p'.
#
#              [3,n] = size(p); double = class(p)
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vproj_c.
#
#   MICE.REQ
#
    function # vproj
#       (p::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        vproj(
            a::Array{Float64,1}, # Array_3_ConstSpiceDouble
            b::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(a) != 3
            error("Incorrect size for parameter 1")
        end
        if length(b) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        p = Array{Float64,1}(3);  # Array_3_SpiceDouble
        p_ptr = pointer(p)
        
#       make transposed copies of all input arrays and their pointers
        a_t = a'
        a_ptr = pointer(a_t)
        b_t = b'
        b_ptr = pointer(b_t)
        
#       ccall((:vproj_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,Array_3_SpiceDouble),a,b,p)
        ccall((:vproj_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            a_ptr,b_ptr,p_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return p
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define two vector sets.
#      %
#      a = [ [ 6, 6, 6]', ...
#            [ 6, 6, 6]', ...
#            [ 6, 6, 0]', ...
#            [ 6, 0, 0]' ]
#
#      b = [ [ 2, 0, 0]', ...
#            [-3, 0, 0]', ...
#            [ 0, 7, 0]', ...
#            [ 0, 0, 9]' ]
#
#      %
#      % Calculate the projection.
#      %
#      p = vproj( a, b )
#
#   MATLAB outputs:
#
#      a =
#
#           6     6     6     6
#           6     6     6     0
#           6     6     0     0
#
#
#      b =
#
#           2    -3     0     0
#           0     0     7     0
#           0     0     0     9
#
#
#      p =
#
#           6     6     0     0
#           0     0     6     0
#           0     0     0     0
#
#-Version
#
#   -Mice Version 1.0.0, 12-MAR-2012, EDW (JPL), SCK (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  #####    ####    #####  #    #
#    #    #  #    #  #    #     #    #    #
#    #    #  #    #  #    #     #    #    #
#    #    #  #####   #    #     #    #    #
#     #  #   #   #   #    #     #     #  #
#      ##    #    #   ####      #      ##
#
#   vector rotation about an axis
#
################################################################################
#-Abstract
#
#   vrotv rotates a double precision 3-vector about a specified
#   axis vector by a specified angle (measured in radians) then
#   returns the rotated vector.
#
#-I/O
#
#   Given:
#
#      v       a double precision 3x1 array to rotate
#
#      axis    a double precision 3x1 array defining the axis about which
#              to rotate 'v'
#
#      theta   a double precision scalar angle measured in radians through which
#              which rotate 'v' about 'axis'
#
#   the call:
#
#      r = vrotv( v, axis, theta )
#
#   returns:
#
#      r   a double precision 3x1 array, the result of rotating 'v' about
#          'axis' through an angle of 'theta'.
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vrotv_c.
#
#   MICE.REQ
#   ROTATION.REQ
#
    function # vrotv
#       (r::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        vrotv(
            v::Array{Float64,1}, # Array_3_ConstSpiceDouble
            axis::Array{Float64,1}, # Array_3_ConstSpiceDouble
            theta::Float64) # SpiceDouble
        
#       enforce input array sizes
        if length(v) != 3
            error("Incorrect size for parameter 1")
        end
        if length(axis) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        r = Array{Float64,1}(3);  # Array_3_SpiceDouble
        r_ptr = pointer(r)
        
#       make transposed copies of all input arrays and their pointers
        v_t = v'
        v_ptr = pointer(v_t)
        axis_t = axis'
        axis_ptr = pointer(axis_t)
        
#       ccall((:vrotv_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble,SpiceDouble,Array_3_SpiceDouble),v,axis,theta,r)
        ccall((:vrotv_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Float64,Ptr{Float64}),
            v_ptr,axis_ptr,theta,r_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return r
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Given an axis of rotation and angle of rotation.
#      %
#      axis  = [ 0.; 0.; 1.];
#      theta = cspice_halfpi;
#
#      %
#      % Perform rotations on various vectors...
#      %
#
#   Example(1):
#
#      v1 = [ 1.; 2.; 3. ];
#
#      r1 = vrotv( v1, axis, theta )
#
#   MATLAB outputs:
#
#      r1 =
#
#         -2.0000
#          1.0000
#          3.0000
#
#   Example(2):
#
#      v2 = [ 1.; 0.; 0. ];
#
#      r2 = vrotv( v2, axis, theta )
#
#   MATLAB outputs:
#
#      r2 =
#
#          0.0000
#          1.0000
#               0
#
#   Example(3):
#
#      v3 = [ 0.; 1.; 0. ];
#
#      r3 = vrotv( v3, axis, theta )
#
#   MATLAB outputs:
#
#      r3 =
#
#         -1.0000
#          0.0000
#               0
#
#-Version
#
#   -Mice Version 1.0.1, 14-JUL-2010, EDW (JPL)
#
#      Corrected minor typo in header.
#
#   -Mice Version 1.0.0, 17-APR-2008, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #   ####   ######  #####
#    #    #  #       #       #    #
#    #    #   ####   #####   #    #
#    #    #       #  #       #####
#     #  #   #    #  #       #
#      ##     ####   ######  #
#
#   angular separation of 3-dimensional vectors
#
################################################################################
#-Abstract
#
#   vsep returns the scalar double precision
#   separation angle in radians between two double precision,
#   3-vectors.  This angle is defined as zero if either vector
#   is zero.
#
#-I/O
#
#   Given:
#
#      v1   is an arbitrary double precision, 3-dimensional vector
#           or 3xN array
#
#      v2   is also an arbitrary double precision, 3-dimensional
#           vector or 3xN array
#
#              'v1' or 'v2' or both may be the zero vector.
#
#      An implicit assumption exists that 's1' and 's2' are specified
#      in the same reference frame. If this is not the case, the numerical
#      result has no meaning.
#
#   the call:
#
#      vsep = vsep(v1, v2)
#
#   returns:
#
#      vsep   the double precision, positive definite, scalar or
#             1xN array of the angular separation(s) between 'v1' and 'v2'
#             expressed in radians. If either 'v1' or 'v2' is the zero
#             vector, then vsep return value has value 0 radians.
#
#             'sep' returns with the same measure of vectorization (N) as
#             'v1' and 'v2'
#
#-Particulars
#
#   None.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine vsep_c.
#
#   MICE.REQ
#
    function # vsep
#       (sep::Float64) =   # SpiceDouble
        vsep(
            v1::Array{Float64,1}, # Array_3_ConstSpiceDouble
            v2::Array{Float64,1}) # Array_3_ConstSpiceDouble
        
#       enforce input array sizes
        if length(v1) != 3
            error("Incorrect size for parameter 1")
        end
        if length(v2) != 3
            error("Incorrect size for parameter 2")
        end
#       allocate the output parameters
        sep = Array{Float64}(1);  # SpiceDouble
        sep_ptr = pointer(sep)
        
#       make transposed copies of all input arrays and their pointers
        v1_t = v1'
        v1_ptr = pointer(v1_t)
        v2_t = v2'
        v2_ptr = pointer(v2_t)
        
#       ccall((:vsep_c,"/home/don/.julia/v0.3/cspice.so"),SpiceDouble,(Array_3_ConstSpiceDouble,Array_3_ConstSpiceDouble),v1,v2)
        return ccall((:vsep_c,libNasaSpice),Float64,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            v1_ptr,v2_ptr,sep_ptr)
    
#       unpack any structures and transpose back any returned arrays
        
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      % Define a set of vectors, calculate angular
#      % separation as measured in radians.
#      %
#      v1 = [1; 0; 0]
#      v2 = [1; 0; 0]
#
#      sep = vsep( v1, v2 )
#
#   MATLAB outputs:
#
#      v1 =
#
#           1
#           0
#           0
#
#      v2 =
#
#           1
#           0
#           0
#
#      sep =
#
#           0
#
#      %
#      % Another vector set.
#      %
#
#      v1 = [1; 0; 0]
#      v2 = [0; 1; 0]
#
#      sep = vsep( v1, v2 )
#
#   MATLAB outputs:
#
#      v1 =
#
#           1
#           0
#           0
#
#      v2 =
#
#           0
#           1
#           0
#
#      sep =
#
#         1.57079632679490
#
#      %
#      % Instead of two calls with 3-vectors,
#      % vectorize the input as two 3X2 array.
#      %
#      v1 = [ [1; 0; 0], [1; 0; 0] ]
#      v2 = [ [1; 0; 0], [0; 1; 0] ]
#
#      sep = vsep( v1, v2 )
#
#   MATLAB outputs:
#
#      v1 =
#
#           1     1
#           0     0
#           0     0
#
#      v2 =
#
#           1     0
#           0     1
#           0     0
#
#      sep =
#
#         0   1.57079632679490
#
#-Version
#
#   -Mice Version 1.0.0, 10-APR-2010, EDW (JPL)
#
#      Edits to header I/O section.
#
#   -Mice Version 1.0.0, 22-NOV-2005, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                    #####
#    #    #  ###### #     #  ######  #    #  #
#     #  #   #            #  #       #    #  #
#      ##    #####   #####   #####   #    #  #
#      ##    #      #        #       #    #  #
#     #  #   #      #        #       #    #  #
#    #    #  #      #######  ######   ####   ######
#
#   Euler angles and derivatives from state transformation
#
################################################################################
#-Abstract
#
#   xf2eul converts a state transformation matrix to
#   Euler angles and their derivatives with respect to a specified
#   set of axes.
#
#   The companion routine cspice_eul2xf converts Euler angles
#   and their derivatives with respect to a specified set of axes
#   to a state transformation matrix.
#
#-I/O
#
#   Given:
#
#      xform   a double precision 6x6 or double precision 6x6xN
#              array of a state transformation matrices from some frame
#              frame1 to another frame frame2
#
#      axisa
#      axisb
#      axisc   the scalar integers defining the axes desired for the
#              factorization of "r". All must be in the range from 1 to 3.
#              Moreover it must be the case that 'axisa' and 'axisb' are
#              distinct and that 'axisb' and 'axisc' are distinct.
#
#              Every rotation matrix can be represented as a product
#              of three rotation matrices about the principal axes
#              of a reference frame.
#
#                   r =  [ alpha ]     [ beta ]     [ gamma ]
#                                 axisa        axisb         axisc
#
#              The value 1 corresponds to the X axis.
#              The value 2 corresponds to the Y axis.
#              The value 3 corresponds to the Z axis.
#
#   the call:
#
#      [eulang, unique] = xf2eul(xform,  axisa, axisb, axisc)
#
#   returns:
#
#       eulang   the double precision 6x1 or double precision 6xN
#                array of Euler angles corresponding to the
#                specified factorization
#
#                If we represent r as shown here:
#
#                   r =  [ alpha ]     [ beta ]     [ gamma ]
#                                 axisa        axisb         axisc
#
#                then (6x1)
#
#                  eulang[1] = alpha
#                  eulang[2] = beta
#                  eulang[3] = gamma
#                  eulang[4] = dalpha/dt
#                  eulang[5] = dbeta/dt
#                  eulang[6] = dgamma/dt
#
#                or (6xN)
#
#                  eulang[:,N] = alpha_N
#                  eulang[:,N] = beta_N
#                  eulang[:,N] = gamma_N
#                  eulang[:,N] = dalpha_N/dt
#                  eulang[:,N] = dbeta_N/dt
#                  eulang[:,N] = dgamma_N/dt
#
#                The range of alpha and gamma is (-pi, pi].
#
#                The range of beta depends on the exact set of
#                axes used for the factorization.  For
#                factorizations in which the first and third axes
#                are the same, the range of beta is [0, pi].
#
#                For factorizations in which the first and third
#                axes are different, the range of beta is
#                [-pi/2, pi/2].
#
#                For rotations such that alpha and gamma are not
#                uniquely determined, alpha and dalpha/dt will
#                always be set to zero; gamma and dgamma/dt are
#                then uniquely determined.
#
#       unique   a boolean scalar or boolean 1XN array whether or not the
#                values in 'eulang' are uniquely determined.  If
#                the values are unique then 'unique' will be set to
#                true.  If the values are not unique and some
#                components ( eulang[1] and eulang[4] ) have value
#                zero, then 'unique' will have the value false.
#
#                'eulang' and 'unique' return with the same vectorization
#                measure (N) as 'xform'.
#
#-Particulars
#
#   This function is intended to provide an inverse for the function
#   cspice_eul2xf.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine xf2eul_c.
#
#   MICE.REQ
#
    function # xf2eul
#       (eulang::Array{Float64,1}(6),  # Array_6_SpiceDouble
#        unique::Int32) =   # Ptr{SpiceBoolean}
        xf2eul(
            xform::Array{Float64,2}, # Array_6_Array_6_ConstSpiceDouble
            axisa::Int32, # SpiceInt
            axisb::Int32, # SpiceInt
            axisc::Int32) # SpiceInt
        
#       enforce input array sizes
        if size(xform) != (6,6)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        eulang = Array{Float64,1}(6);  # Array_6_SpiceDouble
        eulang_ptr = pointer(eulang)
        unique = Array{Int32}(1);  # Ptr{SpiceBoolean}
        unique_ptr = pointer(unique)
        
#       make transposed copies of all input arrays and their pointers
        xform_t = xform'
        xform_ptr = pointer(xform_t)
        
#       ccall((:xf2eul_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_Array_6_ConstSpiceDouble,SpiceInt,SpiceInt,SpiceInt,Array_6_SpiceDouble,Ptr{SpiceBoolean}),xform,axisa,axisb,axisc,eulang,unique)
        ccall((:xf2eul_c,libNasaSpice),Void,
            (Ptr{Float64},Int32,Int32,Int32,Ptr{Float64},Ptr{Int32}),
            xform_ptr,axisa,axisb,axisc,eulang_ptr,unique_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return eulang, convert( Bool, unique[1] )
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#            File name                     Contents
#            ---------                     --------
#            de421.bsp                     Planetary ephemeris
#            pck00009.tpc                  Planet orientation and
#                                          radii
#            naif0009.tls                  Leapseconds
#
#
#         \begindata
#
#            KERNELS_TO_LOAD = ( '/kernels/gen/lsk/naif0009.tls'
#                                '/kernels/gen/spk/de421.bsp'
#                                '/kernels/gen/pck/pck00009.tpc'
#                      )
#
#         \begintext
#
#
#      %
#      % Load the SPK, PCK and LSK kernels.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Suppose that you wish to determine the rate of change of
#      % the right ascension and declination of the pole of the moon,
#      % from the state transformation matrix that transforms J2000
#      % states to object fixed states.
#      %
#      % Using this routine with the routine sxform_c you can determine
#      % these instantaneous rates.
#      %
#      % Recall that the rotation component of tsipm is given by
#      %
#      %  [w]  [halfpi_c-dec] [ra+halfpi_c]
#      %     3               1             3
#      %
#      % Define the number of ephemeris times to perform the calculation.
#      %
#      N = 100;
#
#      %
#      % Calculate the separation of each ephemeris time, in seconds,
#      % over an eighteen year span.
#      %
#      STEP = 18 * 365 * cspice_spd/N;
#
#      %
#      % Base the ephemeris time set at May 15, 2007.
#      %
#      et = [0:N]*STEP +  cspice_str2et( 'May 15, 2007' );
#
#      %
#      % Calculate the state transformation matrices corresponding
#      % to 'et', then convert those matrices to Euler angles (3-1-3).
#      %
#      tsipm              = cspice_sxform( 'J2000', 'IAU_MOON', et );
#      [ eulang, unique ] = xf2eul( tsipm , 3, 1, 3 );
#
#      %
#      % From the Euler angles, calculate right ascension and declination.
#      % Form the UTC time string from 'et' (for output purposes).
#      %
#      ra  = eulang(3,:) - cspice_halfpi;
#      dec = cspice_halfpi - eulang(2,:);
#      utc = cspice_et2utc( et, 'c', 3 );
#
#      %
#      % As a convenience, output in a loop.
#      %
#      for m=1:N+1
#
#         if( unique(m) )
#            fprintf( 'UTC: %s\n', utc(m,:)                 )
#            fprintf( 'w        = %12.6f\n'  , eulang(1,m)  )
#            fprintf( 'dec      = %12.6f\n'  , dec(m)       )
#            fprintf( 'ra       = %12.6f\n'  , ra(m)        )
#            fprintf( 'd w/dt   = %14.9f\n'  , eulang(4,m)  )
#            fprintf( 'd dec/dt = %14.9f\n'  ,-eulang(5,m)  )
#            fprintf( 'd ra/dt  = %14.9f\n\n', eulang(6,m)  )
#         else
#            disp( 'The values in ''eulang'' not uniquely determined.' )
#         end
#
#      end
#
#      %
#      % It's always good form to unload kernels after use,
#      % particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#      %
#      % It is left as an exercise to the user to graphically display
#      % a plot of ra vs dec.
#      %
#      % plot(ra,dec)
#      %
#
#   MATLAB outputs:
#
#      The final five output sets, radians.
#
#               ...
#
#      UTC: 2024 AUG 20 04:48:00.002
#      w        =     2.719238
#      dec      =     1.188057
#      ra       =    -1.581646
#      d w/dt   =    0.000002658
#      d dec/dt =   -0.000000001
#      d ra/dt  =    0.000000004
#
#      UTC: 2024 OCT 24 21:36:00.003
#      w        =    -1.026611
#      dec      =     1.188773
#      ra       =    -1.576003
#      d w/dt   =    0.000002662
#      d dec/dt =    0.000000001
#      d ra/dt  =   -0.000000000
#
#      UTC: 2024 DEC 29 14:24:00.001
#      w        =     1.514167
#      dec      =     1.188984
#      ra       =    -1.573372
#      d w/dt   =    0.000002663
#      d dec/dt =   -0.000000001
#      d ra/dt  =   -0.000000001
#
#      UTC: 2025 MAR 05 07:12:00.000
#      w        =    -2.231256
#      dec      =     1.188290
#      ra       =    -1.567771
#      d w/dt   =    0.000002658
#      d dec/dt =    0.000000000
#      d ra/dt  =    0.000000004
#
#      UTC: 2025 MAY 10 00:00:00.000
#      w        =     0.307001
#      dec      =     1.188934
#      ra       =    -1.562882
#      d w/dt   =    0.000002663
#      d dec/dt =    0.000000001
#      d ra/dt  =   -0.000000001
#
#-Version
#
#   -Mice Version 1.2.0, 10-MAY-2011, EDW (JPL)
#
#      "logical" call replaced with "zzmice_logical."
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 02-APR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#                    #####
#    #    #  ###### #     #  #####     ##    #    #
#     #  #   #            #  #    #   #  #   #    #
#      ##    #####   #####   #    #  #    #  #    #
#      ##    #      #        #####   ######  #    #
#     #  #   #      #        #   #   #    #   #  #
#    #    #  #      #######  #    #  #    #    ##
#
#   State transformation to rotation and angular velocity
#
################################################################################
#-Abstract
#
#   xf2rav determines the rotation matrix and angular
#   velocity of the rotation from a state transformation matrix.
#
#-I/O
#
#   Given:
#
#      xform   a double precision 6x6 or double precision 6x6xN
#              array of a state transformations from some frame
#              "frame1" to another frame "frame2"
#
#   the call:
#
#      [rot, av] = xf2rav(xform)
#
#   returns:
#
#      rot   a double precision 3x3 or double precision 3x3xN array of
#            rotation matrices that gives the transformation from some
#            frame "frame1" to another frame "frame2"
#
#      av    the double precision 3x1 array or double precision
#            3xN array of angular velocities of the transformation
#
#            If 'p' is the position of a fixed point in "frame2,"
#            then from the point of view of "frame1," 'p' rotates
#            (in a right handed sense) about an axis parallel to
#            'av'.  Moreover the rate of rotation in radians per unit
#            time is given by the length of 'av'.
#
#            More formally, the velocity 'v' of 'p' in "frame1" is
#            given by
#                                  t
#               v  = av x ( rot * p )
#
#            The components of 'av' are given relative to "frame1."
#
#            'rot' and 'av' return with the same vectorization
#            measure (N) as 'xform'.
#
#-Particulars
#
#   This routine is an inverse of the routine cspice_rav2xf.
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine xf2rav_c.
#
#   MICE.REQ
#
    function # xf2rav
#       (rot::Array{Float64,2}(3,3),  # Array_3_Array_3_SpiceDouble
#        av::Array{Float64,1}(3)) =   # Array_3_SpiceDouble
        xf2rav(
            xform::Array{Float64,2}) # Array_6_Array_6_ConstSpiceDouble
        
#       enforce input array sizes
        if size(xform) != (6,6)
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        rot = Array{Float64,2}(3,3);  # Array_3_Array_3_SpiceDouble
        rot_ptr = pointer(rot)
        av = Array{Float64,1}(3);  # Array_3_SpiceDouble
        av_ptr = pointer(av)
        
#       make transposed copies of all input arrays and their pointers
        xform_t = xform'
        xform_ptr = pointer(xform_t)
        
#       ccall((:xf2rav_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_Array_6_ConstSpiceDouble,Array_3_Array_3_SpiceDouble,Array_3_SpiceDouble),xform,rot,av)
        ccall((:xf2rav_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{Float64},Ptr{Float64}),
            xform_ptr,rot_ptr,av_ptr)
    
#       unpack any structures and transpose back any returned arrays
        return rot', av
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#      %
#      %  Load a set of kernels: an SPK file, a PCK file
#      %  and a leapseconds file. Use a meta kernel
#      %  for convenience.
#      %
#      cspice_furnsh( 'standard.tm' )
#
#      %
#      % Create an array of 10001 ephemeris times based at July 1 2007.
#      %
#      et    = [0: 10000]* cspice_spd + cspice_str2et( 'July 1 2007' );
#
#      %
#      % Calculate the state transformation matrices from J2000 to IAU_MOON
#      % for 'et'.
#      %
#      xform = cspice_sxform( 'J2000', 'IAU_MOON', et );
#
#      %
#      % Convert the set of 'xform' matrices to the corresponding rotation
#      % matrices and angular velocity vectors.
#      %
#      [ rot, av ] = xf2rav(xform);
#
#      %
#      % Use the converted outputs from xf2rav to recompute a set
#      % of state transformation matrices.
#      %
#      strans = cspice_rav2xf( rot, av );
#
#      %
#      % Calculate the maximum value of the absolute difference between
#      % 'xform' and 'strans'.
#      %
#      disp( 'Vector:' )
#      fprintf(                                                              ...
#         'Maximum absolute difference between rotation matrices: %8.6e\n', ...
#                                   max( max( max( abs(strans - xform) ) ) )   )
#
#      %
#      %  It's always good form to unload kernels after use,
#      %  particularly in MATLAB due to data persistence.
#      %
#      cspice_kclear
#
#   MATLAB outputs:
#
#      Maximum absolute difference between rotation matrices: 1.694066e-21
#
#      In this case, a value on the order of -21 indicates numerical
#      equivalence.
#
#-Version
#
#   -Mice Version 1.0.1, 06-MAY-2009, EDW (JPL)
#
#      Added MICE.REQ reference to the Required Reading section.
#
#   -Mice Version 1.0.0, 11-APR-2007, EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA  INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED
#   "AS-IS" TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING
#   ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR
#   A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY,
#   OR NASA BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING,
#   BUT NOT LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF
#   ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY
#   AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR
#   NASA BE ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL
#   KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE
#   OF THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO
#   INDEMNIFY CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING
#   FROM THE ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


################################################################################
#   
#    #    #  ######  #    #   ####    #####    ##
#     #  #   #       ##  ##  #          #     #  #
#      ##    #####   # ## #   ####      #    #    #
#      ##    #       #    #       #     #    ######
#     #  #   #       #    #  #    #     #    #    #
#    #    #  #       #    #   ####      #    #    #
#
#   state transformation between coordinate systems
#   convert state
#
################################################################################
#-Abstract
#
#   xfmsta transforms a state between coordinate systems.
#
#-I/O
#
#   Given:
#
#
#      Arguments-
#
#      input_state       is a state vector in the input ('input_coord_sys')
#                        coordinate system representing position and velocity.
#
#                        [6,n] = size(input_state); double = class(input_state)
#
#                        All angular measurements must be in radians.
#
#                        Note: body radii values taken from the kernel
#                        pool are used when converting to or from geodetic or
#                        planetographic coordinates. It is the user's
#                        responsibility to verify the distance inputs are in
#                        the same units as the radii in the kernel pool,
#                        typically kilometers.
#
#      input_coord_sys   is the name of the coordinate system that the input
#                        state vector ('input_state') is currently in.
#
#                        [1,c1] = size(input_coord_sys)
#                        char = class(input_coord_sys)
#
#                          or
#
#                        [1,1] = size(output_coord_sys)
#                        cell = class(output_coord_sys)
#
#                        'input_coord_sys' may be any of the following:
#
#                              'RECTANGULAR'
#                              'CYLINDRICAL'
#                              'LATITUDINAL'
#                              'SPHERICAL'
#                              'GEODETIC'
#                              'PLANETOGRAPHIC'
#
#                        Leading spaces, trailing spaces, and letter case
#                        are ignored. For example, ' cyLindRical  ' would
#                        be accepted.
#
#      output_coord_sys  is the name of the coordinate system that the state
#                        should be converted to. Please see the description of
#                        'input_coord_sys' for details.
#
#                        [1,c2] = size(output_coord_sys)
#                        char = class(output_coord_sys)
#
#                          or
#
#                        [1,1] = size(output_coord_sys)
#                        cell = class(output_coord_sys)
#
#      body              is the name or NAIF ID of the body associated with the
#                        planetographic or geodetic coordinate system.
#
#                        [1,c3] = size(body); char = class(body)
#
#                          or
#
#                        [1,1] = size(body); cell = class(body)
#
#                        If one of the coordinate system choices is not
#                        geodetic or planetographic, 'body' may be an empty
#                        string (' ').
#
#                        Examples of accepted body names or IDs are:
#                                 'Earth'
#                                 '399'
#
#                        Leading spaces, trailing spaces, and letter case are
#                        ignored.
#
#   the call:
#
#      output_state = xfmsta ( input_state,      input_coord_sys, ...
#                                     output_coord_sys, body )
#
#   returns:
#
#      output_state      is the state vector that has been converted to the
#                        output coordinate system ('output_coord_sys').
#
#                        [6,n] = size(output_state)
#                        double = class(output_state)
#
#-Particulars
#
#   Input Order
#   -------------------------------------------
#
#      The input and output states will be structured by the
#      following descriptions.
#
#      For rectangular coordinates, the state vector is the following
#      in which X, Y, and Z are the rectangular position components and
#      DX, DY, and DZ are the time derivatives of each.
#              ISTATE = ( X, Y, Z, DX, DY, DZ )
#
#      For cylindrical coordinates, the state vector is the following
#      in which R is the radius, LONG is the longitude, Z is the
#      height, and DR, DLONG, and DZ are the time derivatives of each.
#              ISTATE = ( R, LONG, Z, DR, DLONG, DZ )
#
#      For latitudinal coordinates, the state vector is the following
#      in which R is the radius, LONG is the longitude, LAT is the
#      latitude, and DR, DLONG, and DLAT are the time derivatives of
#      each.
#              ISTATE = ( R, LONG, LAT, DR, DLONG, DLAT )
#
#      For spherical coordinates, the state vector is the following in
#      which R is the radius, COLAT is the colatitude, LONG is the
#      longitude, and DR, DCOLAT, and DLONG are the time derivatives of
#      each.
#              ISTATE = ( R, COLAT, LONG, DR, DCOLAT, DLONG )
#
#      For geodetic coordinates, the state vector is the following in
#      which LONG is the longitude, LAT is the latitude, ALT is the
#      altitude, and DLONG, DLAT, and DALT are the time derivatives of
#      each.
#              ISTATE = ( LONG, LAT, ALT, DLONG, DLAT, DALT )
#
#      For planetographic coordinates, the state vector is the
#      following in which LONG is the longitude, LAT is the latitude,
#      ALT is the altitude, and DLONG, DLAT, and DALT are the time
#      derivatives of each.
#              ISTATE = ( LONG, LAT, ALT, DLONG, DLAT, DALT )
#
#   Input Boundaries
#   -------------------------------------------
#
#      There are intervals the input angles must fall within if
#      the input coordinate system is not rectangular.  These
#      intervals are provided below.
#
#         Input variable    Input meaning   Input interval [rad]
#         --------------    -------------   ------------------------
#             LONG           Longitude        0     <= LONG  <  2*pi
#             LAT            Latitude        -pi/2  <= LAT   <= pi/2
#             COLAT          Colatitude       0     <= COLAT <= pi
#
#-Required Reading
#
#   For important details concerning this module's function, please refer to
#   the CSPICE routine xfmsta_c.
#
    function # xfmsta
        xfmsta(
            input_state::Array{Float64,1}, # Array_6_ConstSpiceDouble
            input_coord_sys::AbstractString, # Ptr{ConstSpiceChar}
            output_coord_sys::AbstractString, # Ptr{ConstSpiceChar}
            body::AbstractString) # Ptr{ConstSpiceChar}
        
#       enforce input array sizes
        if length(input_state) != 6
            error("Incorrect size for parameter 1")
        end
#       allocate the output parameters
        
#       make transposed copies of all input arrays and their pointers
        input_state_t = input_state'
        input_state_ptr = pointer(input_state_t)
        
#       ccall((:xfmsta_c,"/home/don/.julia/v0.3/cspice.so"),Void,(Array_6_ConstSpiceDouble,Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Ptr{ConstSpiceChar},Array_6_SpiceDouble),input_state,input_coord_sys,output_coord_sys,body,output_state)
        ccall((:xfmsta_c,libNasaSpice),Void,
            (Ptr{Float64},Ptr{UInt8},Ptr{UInt8},Ptr{UInt8}),
            input_state_ptr,input_coord_sys,output_coord_sys,body)
    
#       unpack any structures and transpose back any returned arrays
        return 
    end
#-Examples
#
#   Any numerical results shown for this example may differ between
#   platforms as the results depend on the SPICE kernels used as input
#   and the machine specific arithmetic implementation.
#
#
#   Example(1):
#
#      Find the apparent state of Phoebe as seen by CASSINI in the
#      J2000 frame at three times starting at 2004 Jun 11 19:32:00.
#      Transform the state from rectangular to latitudinal coordinates.
#      For verification, transform the state back from latitudinal to
#      rectangular coordinates.
#
#      Use the meta-kernel shown below to load the required SPICE
#      kernels.
#
#         KPL/MK
#
#         File name: xfmsta_ex1.tm
#
#         This meta-kernel is intended to support operation of SPICE
#         example programs. The kernels shown here should not be
#         assumed to contain adequate or correct versions of data
#         required by SPICE-based user applications.
#
#         In order for an application to use this meta-kernel, the
#         kernels referenced here must be present in the user's
#         current working directory.
#
#         The names and contents of the kernels referenced
#         by this meta-kernel are as follows:
#
#                File name                     Contents
#                ---------                     --------
#                cpck05Mar2004.tpc             Planet orientation and
#                                              radii
#                naif0009.tls                  Leapseconds
#                020514_SE_SAT105.bsp          Satellite ephemeris for
#                                              Saturn
#                030201AP_SK_SM546_T45.bsp     CASSINI ephemeris
#                981005_PLTEPH-DE405S.bsp      Planetary ephemeris
#
#
#         \begindata
#
#         KERNELS_TO_LOAD = ( 'naif0009.tls'  ,
#                             '020514_SE_SAT105.bsp'  ,
#                             '030201AP_SK_SM546_T45.bsp'  ,
#                             '981005_PLTEPH-DE405S.bsp',
#                             'cpck05Mar2004.tpc'   )
#
#         End of meta-kernel
#
#       Example program starts here.
#
#         metakr = 'xfmsta_ex1.tm';
#         form = 'YYYY-MM-DD HR:MN:SC (TDB) ::TDB';
#
#         %
#         %   Load the meta kernel.
#         %
#         cspice_furnsh ( metakr );
#
#         %
#         %   Calculate the state at 2004 Jun 11 19:32:00 UTC.
#         %
#         times = [ '2004-JUN-11-19:32:00';
#                   '2004-JUN-11-19:40:00';
#                   '2004-JUN-11-19:48:00'];
#         et = cspice_str2et ( times );
#
#         %
#         %   Calculate the apparent state of Phoebe as seen by
#         %   CASSINI in the J2000 frame.
#         %
#         [state_rec, lt] = cspice_spkezr ( 'phoebe', et, 'iau_phoebe', ...
#                                           'lt+s', 'cassini' );
#
#         %
#         %   Transform the state from rectangular to latitudinal.
#         %   Notice that since neither the input nor output
#         %   coordinate frames are 'geodetic' or 'planetographic',
#         %   the input for the body name is a blank string.
#         %
#         state_lat = xfmsta ( state_rec, 'rectangular', ...
#                                     'latitudinal', ' ' );
#
#         %
#         %   Transform the state back to rectangular from latitudinal. The
#         %   result should be very close to 'state_rec'.
#         %
#         state_rec2 = xfmsta ( state_lat, 'latitudinal', ...
#                                      'rectangular', ' ');
#
#         %
#         %   Report the results.
#         %
#         fprintf('\nPhoebe as seen by Cassini - rectangular\n')
#         for i = 1:length(et)
#             fprintf('Time: %s\n', cspice_timout ( et(i), form))
#             fprintf('  Position: %16.6f %16.6f %16.6f\n', state_rec(1:3,i))
#             fprintf('  Velocity: %16.6f %16.6f %16.6f\n', state_rec(4:6,i))
#         end
#
#         fprintf('\nPhoebe as seen by Cassini - latitudinal\n')
#         for i = 1:length(et)
#             fprintf('Time: %s\n', cspice_timout ( et(i), form))
#             fprintf('  Position: %16.6f %16.6f %16.6f\n', state_lat(1:3,i))
#             fprintf('  Velocity: %16.6f %16.6f %16.6f\n', state_lat(4:6,i))
#         end
#
#         fprintf('\nVerification: Phoebe as seen by Cassini - rectangular\n')
#         for i = 1:length(et)
#             fprintf('Time: %s\n', cspice_timout ( et(i), form))
#             fprintf('  Position: %16.6f %16.6f %16.6f\n', state_rec2(1:3,i))
#             fprintf('  Velocity: %16.6f %16.6f %16.6f\n', state_rec2(4:6,i))
#         end
#
#         %
#         %   Unload the kernels.
#         %
#         cspice_kclear
#
#   MATLAB outputs:
#
#         Phoebe as seen by Cassini - rectangular
#         Time: 2004-06-11 19:33:04 (TDB)
#           Position:     -1982.639762      -934.530471      -166.562595
#           Velocity:         3.970832        -3.812496        -2.371663
#         Time: 2004-06-11 19:41:04 (TDB)
#           Position:      -257.857469     -2932.271650     -1304.929678
#           Velocity:         3.200173        -4.493939        -2.371569
#         Time: 2004-06-11 19:49:04 (TDB)
#           Position:      1075.597532     -5231.009547     -2443.280908
#           Velocity:         2.342482        -5.064820        -2.371563
#
#         Phoebe as seen by Cassini - latitudinal
#         Time: 2004-06-11 19:33:04 (TDB)
#           Position:      2198.169858        -2.701121        -0.075846
#           Velocity:        -1.780939         0.002346        -0.001144
#         Time: 2004-06-11 19:41:04 (TDB)
#           Position:      3219.867849        -1.658508        -0.417279
#           Velocity:         4.797399         0.001217        -0.000145
#         Time: 2004-06-11 19:49:04 (TDB)
#           Position:      5872.818108        -1.368003        -0.429078
#           Velocity:         5.926982         0.000239         0.000018
#
#         Verification: Phoebe as seen by Cassini - rectangular
#         Time: 2004-06-11 19:33:04 (TDB)
#           Position:     -1982.639762      -934.530471      -166.562595
#           Velocity:         3.970832        -3.812496        -2.371663
#         Time: 2004-06-11 19:41:04 (TDB)
#           Position:      -257.857469     -2932.271650     -1304.929678
#           Velocity:         3.200173        -4.493939        -2.371569
#         Time: 2004-06-11 19:49:04 (TDB)
#           Position:      1075.597532     -5231.009547     -2443.280908
#           Velocity:         2.342482        -5.064820        -2.371563
#
#   Example(2):
#
#      Example program starts here.
#
#         %   Initialize the cylindrical state.
#         %
#         state_cyl = [1 0.5 0.5 0.2 0.1 -0.2]';
#
#         %
#         %   Load kernels.
#         %
#         cspice_furnsh( 'cpck05Mar2004.tpc' );
#
#         %
#         %   Transform the state from cylindrical to planetographic.
#         %   Note that since one of the coordinate systems is
#         %   planetographic, the body name must be input.
#         %
#         state_plan = xfmsta ( state_cyl, 'cylindrical',  ...
#                                      'planetographic', 'earth' );
#
#         %
#         %   Transform the state back to cylindrical from
#         %   planetographic. The result should be very close to 'state_cyl'.
#         %
#         state_cyl2 = xfmsta ( state_plan, 'planetographic',...
#                                      'cylindrical', 'earth' );
#
#         %
#         %   Report the results.
#         %
#         fprintf('\nCylindrical State\n')
#         fprintf('  Position: %7.3f %7.3f %7.3f\n', state_cyl(1:3))
#         fprintf('  Velocity: %7.3f %7.3f %7.3f\n', state_cyl(4:6))
#
#         fprintf('\nPlanetographic State\n')
#         fprintf('  Position: %7.3f %7.3f %7.3f\n', state_plan(1:3))
#         fprintf('  Velocity: %7.3f %7.3f %7.3f\n', state_plan(4:6))
#
#         fprintf('\nVerification: Cylindrical State\n')
#         fprintf('  Position: %7.3f %7.3f %7.3f\n', state_cyl2(1:3))
#         fprintf('  Velocity: %7.3f %7.3f %7.3f\n', state_cyl2(4:6))
#
#         %
#         %   Unload the kernels.
#         %
#         cspice_kclear
#
#   MATLAB outputs:
#
#         Cylindrical State
#           Position:   1.000   0.500   0.500
#           Velocity:   0.200   0.100  -0.200
#
#         Planetographic State
#           Position:   0.500   1.548 -6356.238
#           Velocity:   0.100  -0.005  -0.195
#
#         Verification: Cylindrical State
#           Position:   1.000   0.500   0.500
#           Velocity:   0.200   0.100  -0.200
#
#-Version
#
#   -Mice Version 1.0.0, 28-AUG-2012, SCK (JPL), EDW (JPL)
#
#-Disclaimer
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
#   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
#   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
#   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
#   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
#   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
#   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
#   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
#   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
#   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
#   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
#   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#
################################################################################


